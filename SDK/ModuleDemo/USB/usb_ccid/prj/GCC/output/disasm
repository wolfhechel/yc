
output/out:     file format elf32-littlearm


Disassembly of section .text:

01000000 <Reset_Handler-0x200>:
	...

01000200 <Reset_Handler>:
 1000200:	4853      	ldr	r0, [pc, #332]	; (1000350 <BT_IRQHandler+0x2>)
 1000202:	4700      	bx	r0

01000204 <hard_fault_handler>:
 1000204:	4853      	ldr	r0, [pc, #332]	; (1000354 <BT_IRQHandler+0x6>)
 1000206:	4700      	bx	r0
 1000208:	46c0      	nop			; (mov r8, r8)

0100020a <svc_handler>:
 100020a:	4853      	ldr	r0, [pc, #332]	; (1000358 <BT_IRQHandler+0xa>)
 100020c:	4700      	bx	r0
 100020e:	46c0      	nop			; (mov r8, r8)

01000210 <pendsv_handler>:
 1000210:	4852      	ldr	r0, [pc, #328]	; (100035c <BT_IRQHandler+0xe>)
 1000212:	4700      	bx	r0
 1000214:	46c0      	nop			; (mov r8, r8)

01000216 <systick>:
 1000216:	4852      	ldr	r0, [pc, #328]	; (1000360 <BT_IRQHandler+0x12>)
 1000218:	4700      	bx	r0
 100021a:	46c0      	nop			; (mov r8, r8)

0100021c <irq0>:
 100021c:	2000      	movs	r0, #0
 100021e:	e03d      	b.n	100029c <isr>

01000220 <irq1>:
 1000220:	2004      	movs	r0, #4
 1000222:	e03b      	b.n	100029c <isr>

01000224 <irq2>:
 1000224:	2008      	movs	r0, #8
 1000226:	e039      	b.n	100029c <isr>

01000228 <irq3>:
 1000228:	200c      	movs	r0, #12
 100022a:	e037      	b.n	100029c <isr>

0100022c <irq4>:
 100022c:	2010      	movs	r0, #16
 100022e:	e035      	b.n	100029c <isr>

01000230 <irq5>:
 1000230:	2014      	movs	r0, #20
 1000232:	e033      	b.n	100029c <isr>

01000234 <irq6>:
 1000234:	2018      	movs	r0, #24
 1000236:	e031      	b.n	100029c <isr>

01000238 <irq7>:
 1000238:	201c      	movs	r0, #28
 100023a:	e02f      	b.n	100029c <isr>

0100023c <irq8>:
 100023c:	2020      	movs	r0, #32
 100023e:	e02d      	b.n	100029c <isr>

01000240 <irq9>:
 1000240:	2024      	movs	r0, #36	; 0x24
 1000242:	e02b      	b.n	100029c <isr>

01000244 <irq10>:
 1000244:	2028      	movs	r0, #40	; 0x28
 1000246:	e029      	b.n	100029c <isr>

01000248 <irq11>:
 1000248:	202c      	movs	r0, #44	; 0x2c
 100024a:	e027      	b.n	100029c <isr>

0100024c <irq12>:
 100024c:	2030      	movs	r0, #48	; 0x30
 100024e:	e025      	b.n	100029c <isr>

01000250 <irq13>:
 1000250:	2034      	movs	r0, #52	; 0x34
 1000252:	e023      	b.n	100029c <isr>

01000254 <irq14>:
 1000254:	2038      	movs	r0, #56	; 0x38
 1000256:	e021      	b.n	100029c <isr>

01000258 <irq15>:
 1000258:	203c      	movs	r0, #60	; 0x3c
 100025a:	e01f      	b.n	100029c <isr>

0100025c <irq16>:
 100025c:	2040      	movs	r0, #64	; 0x40
 100025e:	e01d      	b.n	100029c <isr>

01000260 <irq17>:
 1000260:	2044      	movs	r0, #68	; 0x44
 1000262:	e01b      	b.n	100029c <isr>

01000264 <irq18>:
 1000264:	2048      	movs	r0, #72	; 0x48
 1000266:	e019      	b.n	100029c <isr>

01000268 <irq19>:
 1000268:	204c      	movs	r0, #76	; 0x4c
 100026a:	e017      	b.n	100029c <isr>

0100026c <irq20>:
 100026c:	2050      	movs	r0, #80	; 0x50
 100026e:	e015      	b.n	100029c <isr>

01000270 <irq21>:
 1000270:	2054      	movs	r0, #84	; 0x54
 1000272:	e013      	b.n	100029c <isr>

01000274 <irq22>:
 1000274:	2058      	movs	r0, #88	; 0x58
 1000276:	e011      	b.n	100029c <isr>

01000278 <irq23>:
 1000278:	205c      	movs	r0, #92	; 0x5c
 100027a:	e00f      	b.n	100029c <isr>

0100027c <irq24>:
 100027c:	2060      	movs	r0, #96	; 0x60
 100027e:	e00d      	b.n	100029c <isr>

01000280 <irq25>:
 1000280:	2064      	movs	r0, #100	; 0x64
 1000282:	e00b      	b.n	100029c <isr>

01000284 <irq26>:
 1000284:	2068      	movs	r0, #104	; 0x68
 1000286:	e009      	b.n	100029c <isr>

01000288 <irq27>:
 1000288:	206c      	movs	r0, #108	; 0x6c
 100028a:	e007      	b.n	100029c <isr>

0100028c <irq28>:
 100028c:	2070      	movs	r0, #112	; 0x70
 100028e:	e005      	b.n	100029c <isr>

01000290 <irq29>:
 1000290:	2074      	movs	r0, #116	; 0x74
 1000292:	e003      	b.n	100029c <isr>

01000294 <irq30>:
 1000294:	2078      	movs	r0, #120	; 0x78
 1000296:	e001      	b.n	100029c <isr>

01000298 <irq31>:
 1000298:	207c      	movs	r0, #124	; 0x7c
 100029a:	e7ff      	b.n	100029c <isr>

0100029c <isr>:
 100029c:	4931      	ldr	r1, [pc, #196]	; (1000364 <BT_IRQHandler+0x16>)
 100029e:	5840      	ldr	r0, [r0, r1]
 10002a0:	4700      	bx	r0
 10002a2:	46c0      	nop			; (mov r8, r8)
 10002a4:	46c0      	nop			; (mov r8, r8)
 10002a6:	46c0      	nop			; (mov r8, r8)
 10002a8:	46c0      	nop			; (mov r8, r8)
 10002aa:	46c0      	nop			; (mov r8, r8)
 10002ac:	46c0      	nop			; (mov r8, r8)
 10002ae:	46c0      	nop			; (mov r8, r8)

010002b0 <isr_table>:
 10002b0:	010039e1 	.word	0x010039e1
 10002b4:	0100034f 	.word	0x0100034f
 10002b8:	0100034f 	.word	0x0100034f
 10002bc:	0100034f 	.word	0x0100034f
 10002c0:	0100034f 	.word	0x0100034f
 10002c4:	0100034f 	.word	0x0100034f
 10002c8:	0100034f 	.word	0x0100034f
 10002cc:	0100034f 	.word	0x0100034f
 10002d0:	0100034f 	.word	0x0100034f
 10002d4:	0100034f 	.word	0x0100034f
 10002d8:	0100034f 	.word	0x0100034f
 10002dc:	0100034f 	.word	0x0100034f
 10002e0:	0100034f 	.word	0x0100034f
 10002e4:	0100034f 	.word	0x0100034f
 10002e8:	0100034f 	.word	0x0100034f
 10002ec:	0100034f 	.word	0x0100034f
 10002f0:	0100034f 	.word	0x0100034f
 10002f4:	0100034f 	.word	0x0100034f
 10002f8:	0100034f 	.word	0x0100034f
 10002fc:	0100034f 	.word	0x0100034f
 1000300:	0100034f 	.word	0x0100034f
 1000304:	0100034f 	.word	0x0100034f
 1000308:	0100034f 	.word	0x0100034f
 100030c:	0100034f 	.word	0x0100034f
 1000310:	0100034f 	.word	0x0100034f
 1000314:	0100034f 	.word	0x0100034f
 1000318:	0100034f 	.word	0x0100034f

0100031c <hardware_init>:
 100031c:	4912      	ldr	r1, [pc, #72]	; (1000368 <BT_IRQHandler+0x1a>)
 100031e:	4a13      	ldr	r2, [pc, #76]	; (100036c <BT_IRQHandler+0x1e>)
 1000320:	4b13      	ldr	r3, [pc, #76]	; (1000370 <BT_IRQHandler+0x22>)
 1000322:	1a9b      	subs	r3, r3, r2
 1000324:	dd03      	ble.n	100032e <hardware_init+0x12>
 1000326:	3b04      	subs	r3, #4
 1000328:	58c8      	ldr	r0, [r1, r3]
 100032a:	50d0      	str	r0, [r2, r3]
 100032c:	dcfb      	bgt.n	1000326 <hardware_init+0xa>
 100032e:	4911      	ldr	r1, [pc, #68]	; (1000374 <BT_IRQHandler+0x26>)
 1000330:	4a11      	ldr	r2, [pc, #68]	; (1000378 <BT_IRQHandler+0x2a>)
 1000332:	2000      	movs	r0, #0
 1000334:	1a52      	subs	r2, r2, r1
 1000336:	dd02      	ble.n	100033e <hardware_init+0x22>
 1000338:	3a04      	subs	r2, #4
 100033a:	5088      	str	r0, [r1, r2]
 100033c:	dcfc      	bgt.n	1000338 <hardware_init+0x1c>
 100033e:	480f      	ldr	r0, [pc, #60]	; (100037c <BT_IRQHandler+0x2e>)
 1000340:	4b0f      	ldr	r3, [pc, #60]	; (1000380 <BT_IRQHandler+0x32>)
 1000342:	f003 fd27 	bl	1003d94 <main>

01000346 <delay>:
 1000346:	3801      	subs	r0, #1
 1000348:	d1fd      	bne.n	1000346 <delay>
 100034a:	46c0      	nop			; (mov r8, r8)
 100034c:	4770      	bx	lr

0100034e <BT_IRQHandler>:
 100034e:	e7fe      	b.n	100034e <BT_IRQHandler>
 1000350:	0100031d 	.word	0x0100031d
 1000354:	0100034f 	.word	0x0100034f
 1000358:	0100034f 	.word	0x0100034f
 100035c:	0100034f 	.word	0x0100034f
 1000360:	0100034f 	.word	0x0100034f
 1000364:	010002b0 	.word	0x010002b0
 1000368:	0100585c 	.word	0x0100585c
 100036c:	00020000 	.word	0x00020000
 1000370:	00020144 	.word	0x00020144
 1000374:	00020144 	.word	0x00020144
 1000378:	00021bf8 	.word	0x00021bf8
 100037c:	00012345 	.word	0x00012345
 1000380:	00001111 	.word	0x00001111
 1000384:	00002041 	.word	0x00002041
 1000388:	61656100 	.word	0x61656100
 100038c:	01006962 	.word	0x01006962
 1000390:	00000016 	.word	0x00000016
 1000394:	726f4305 	.word	0x726f4305
 1000398:	2d786574 	.word	0x2d786574
 100039c:	0600304d 	.word	0x0600304d
 10003a0:	094d070c 	.word	0x094d070c
 10003a4:	0001      	.short	0x0001

010003a6 <printfsend>:
#endif

void printfsend(UART_TypeDef UARTx, uint8_t *buf, int len)
{
    uint8_t printbuf[256];
    for (int i = 0; i < len; i++)
 10003a6:	2300      	movs	r3, #0
{
 10003a8:	b530      	push	{r4, r5, lr}
 10003aa:	b0c1      	sub	sp, #260	; 0x104
    for (int i = 0; i < len; i++)
 10003ac:	4293      	cmp	r3, r2
 10003ae:	db04      	blt.n	10003ba <printfsend+0x14>
    else
    {
        UART_SendBuf(UART0, printbuf, len);
    }
#else
    UART_SendBuf(UARTx, printbuf, len);
 10003b0:	4669      	mov	r1, sp
 10003b2:	f001 fb85 	bl	1001ac0 <UART_SendBuf>
#endif
}
 10003b6:	b041      	add	sp, #260	; 0x104
 10003b8:	bd30      	pop	{r4, r5, pc}
        printbuf[i] = buf[i];
 10003ba:	466d      	mov	r5, sp
 10003bc:	5ccc      	ldrb	r4, [r1, r3]
 10003be:	54ec      	strb	r4, [r5, r3]
    for (int i = 0; i < len; i++)
 10003c0:	3301      	adds	r3, #1
 10003c2:	e7f3      	b.n	10003ac <printfsend+0x6>

010003c4 <MyPrintf>:

void MyPrintf(char *format, ...)
{
 10003c4:	b40f      	push	{r0, r1, r2, r3}
 10003c6:	b5f0      	push	{r4, r5, r6, r7, lr}
 10003c8:	b08d      	sub	sp, #52	; 0x34
 10003ca:	ab12      	add	r3, sp, #72	; 0x48
 10003cc:	cb04      	ldmia	r3!, {r2}
 10003ce:	9202      	str	r2, [sp, #8]
    uint32_t ulIdx, ulValue, ulPos, ulCount, ulBase, ulNeg;
    int8_t *pcStr, pcBuf[16], cFill;
    char HexFormat;
    va_list vaArgP;

    va_start(vaArgP, format);
 10003d0:	9307      	str	r3, [sp, #28]

    while (*format)
 10003d2:	9b02      	ldr	r3, [sp, #8]
 10003d4:	781b      	ldrb	r3, [r3, #0]
 10003d6:	2b00      	cmp	r3, #0
 10003d8:	d100      	bne.n	10003dc <MyPrintf+0x18>
 10003da:	e0de      	b.n	100059a <MyPrintf+0x1d6>
 10003dc:	9b02      	ldr	r3, [sp, #8]
 10003de:	9a02      	ldr	r2, [sp, #8]
    {
        // Find the first non-% character, or the end of the string.
        for (ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0'); ulIdx++)
 10003e0:	7819      	ldrb	r1, [r3, #0]
 10003e2:	1a9a      	subs	r2, r3, r2
 10003e4:	001c      	movs	r4, r3
 10003e6:	2925      	cmp	r1, #37	; 0x25
 10003e8:	d002      	beq.n	10003f0 <MyPrintf+0x2c>
 10003ea:	3301      	adds	r3, #1
 10003ec:	2900      	cmp	r1, #0
 10003ee:	d1f6      	bne.n	10003de <MyPrintf+0x1a>
        {}

        // Write this portion of the string.
        if (ulIdx > 0)
 10003f0:	2a00      	cmp	r2, #0
 10003f2:	d003      	beq.n	10003fc <MyPrintf+0x38>
        {
//				printfsend(UART0,format, ulIdx);
            printfsend(UART0, (uint8_t *)format, ulIdx);
 10003f4:	9902      	ldr	r1, [sp, #8]
 10003f6:	2000      	movs	r0, #0
 10003f8:	f7ff ffd5 	bl	10003a6 <printfsend>
        }

        format += ulIdx;

        if (*format == '%')
 10003fc:	7823      	ldrb	r3, [r4, #0]
 10003fe:	9402      	str	r4, [sp, #8]
 1000400:	2b25      	cmp	r3, #37	; 0x25
 1000402:	d1e6      	bne.n	10003d2 <MyPrintf+0xe>
        {
            format++;
 1000404:	1c61      	adds	r1, r4, #1
                if ((format[-1] == '0') && (ulCount == 0))
                {
                    cFill = '0';
                }

                ulCount *= 10;
 1000406:	220a      	movs	r2, #10
            ulCount = 0;
 1000408:	2400      	movs	r4, #0
            cFill = ' ';
 100040a:	3b05      	subs	r3, #5
 100040c:	9303      	str	r3, [sp, #12]
            switch (*format++)
 100040e:	1c4b      	adds	r3, r1, #1
 1000410:	9302      	str	r3, [sp, #8]
 1000412:	780b      	ldrb	r3, [r1, #0]
 1000414:	2b63      	cmp	r3, #99	; 0x63
 1000416:	d036      	beq.n	1000486 <MyPrintf+0xc2>
 1000418:	d814      	bhi.n	1000444 <MyPrintf+0x80>
 100041a:	2b39      	cmp	r3, #57	; 0x39
 100041c:	d807      	bhi.n	100042e <MyPrintf+0x6a>
 100041e:	2b30      	cmp	r3, #48	; 0x30
 1000420:	d226      	bcs.n	1000470 <MyPrintf+0xac>
            }

            case '%':
            {
//					printfsend(UART0, format - 1, 1);
                printfsend(UART0, (uint8_t *)format - 1, 1);
 1000422:	2201      	movs	r2, #1
            switch (*format++)
 1000424:	2b25      	cmp	r3, #37	; 0x25
 1000426:	d035      	beq.n	1000494 <MyPrintf+0xd0>
            }

            default:
            {
//					printfsend(UART0, "ERROR", 5);
                printfsend(UART0, (uint8_t *)"ERROR", 5);
 1000428:	2205      	movs	r2, #5
 100042a:	495e      	ldr	r1, [pc, #376]	; (10005a4 <MyPrintf+0x1e0>)
 100042c:	e032      	b.n	1000494 <MyPrintf+0xd0>
            switch (*format++)
 100042e:	2b58      	cmp	r3, #88	; 0x58
 1000430:	d1fa      	bne.n	1000428 <MyPrintf+0x64>
                ulValue = va_arg(vaArgP, unsigned long);
 1000432:	9a07      	ldr	r2, [sp, #28]
                HexFormat = 'X';
 1000434:	9304      	str	r3, [sp, #16]
                ulValue = va_arg(vaArgP, unsigned long);
 1000436:	1d11      	adds	r1, r2, #4
 1000438:	6812      	ldr	r2, [r2, #0]
 100043a:	9107      	str	r1, [sp, #28]
 100043c:	9206      	str	r2, [sp, #24]
                ulNeg = 0;
 100043e:	2700      	movs	r7, #0
                ulBase = 16;
 1000440:	2310      	movs	r3, #16
 1000442:	e038      	b.n	10004b6 <MyPrintf+0xf2>
            switch (*format++)
 1000444:	2b73      	cmp	r3, #115	; 0x73
 1000446:	d06e      	beq.n	1000526 <MyPrintf+0x162>
 1000448:	d80d      	bhi.n	1000466 <MyPrintf+0xa2>
 100044a:	2b64      	cmp	r3, #100	; 0x64
 100044c:	d026      	beq.n	100049c <MyPrintf+0xd8>
 100044e:	2b70      	cmp	r3, #112	; 0x70
 1000450:	d1ea      	bne.n	1000428 <MyPrintf+0x64>
                ulValue = va_arg(vaArgP, unsigned long);
 1000452:	9b07      	ldr	r3, [sp, #28]
                ulNeg = 0;
 1000454:	2700      	movs	r7, #0
                ulValue = va_arg(vaArgP, unsigned long);
 1000456:	1d1a      	adds	r2, r3, #4
 1000458:	681b      	ldr	r3, [r3, #0]
 100045a:	9207      	str	r2, [sp, #28]
 100045c:	9306      	str	r3, [sp, #24]
                HexFormat = 'x';
 100045e:	2378      	movs	r3, #120	; 0x78
 1000460:	9304      	str	r3, [sp, #16]
                ulBase = 16;
 1000462:	3b68      	subs	r3, #104	; 0x68
 1000464:	e027      	b.n	10004b6 <MyPrintf+0xf2>
            switch (*format++)
 1000466:	2b75      	cmp	r3, #117	; 0x75
 1000468:	d079      	beq.n	100055e <MyPrintf+0x19a>
 100046a:	2b78      	cmp	r3, #120	; 0x78
 100046c:	d0f1      	beq.n	1000452 <MyPrintf+0x8e>
 100046e:	e7db      	b.n	1000428 <MyPrintf+0x64>
                if ((format[-1] == '0') && (ulCount == 0))
 1000470:	2b30      	cmp	r3, #48	; 0x30
 1000472:	d103      	bne.n	100047c <MyPrintf+0xb8>
 1000474:	2c00      	cmp	r4, #0
 1000476:	d101      	bne.n	100047c <MyPrintf+0xb8>
                    cFill = '0';
 1000478:	2130      	movs	r1, #48	; 0x30
 100047a:	9103      	str	r1, [sp, #12]
                ulCount *= 10;
 100047c:	4354      	muls	r4, r2
 100047e:	3c30      	subs	r4, #48	; 0x30
                ulCount += format[-1] - '0';
 1000480:	191c      	adds	r4, r3, r4
            switch (*format++)
 1000482:	9902      	ldr	r1, [sp, #8]
                goto again;
 1000484:	e7c3      	b.n	100040e <MyPrintf+0x4a>
                ulValue = va_arg(vaArgP, unsigned long);
 1000486:	9b07      	ldr	r3, [sp, #28]
                printfsend(UART0, (uint8_t *)&ulValue, 1);
 1000488:	a906      	add	r1, sp, #24
                ulValue = va_arg(vaArgP, unsigned long);
 100048a:	1d1a      	adds	r2, r3, #4
 100048c:	9207      	str	r2, [sp, #28]
                printfsend(UART0, (uint8_t *)&ulValue, 1);
 100048e:	2201      	movs	r2, #1
                ulValue = va_arg(vaArgP, unsigned long);
 1000490:	681b      	ldr	r3, [r3, #0]
 1000492:	9306      	str	r3, [sp, #24]
                printfsend(UART0, (uint8_t *)"ERROR", 5);
 1000494:	2000      	movs	r0, #0
 1000496:	f7ff ff86 	bl	10003a6 <printfsend>
                break;
 100049a:	e79a      	b.n	10003d2 <MyPrintf+0xe>
                ulValue = va_arg(vaArgP, unsigned long);
 100049c:	9b07      	ldr	r3, [sp, #28]
 100049e:	1d1a      	adds	r2, r3, #4
 10004a0:	681b      	ldr	r3, [r3, #0]
 10004a2:	9207      	str	r2, [sp, #28]
                if ((long)ulValue < 0)
 10004a4:	2b00      	cmp	r3, #0
 10004a6:	db02      	blt.n	10004ae <MyPrintf+0xea>
                ulValue = va_arg(vaArgP, unsigned long);
 10004a8:	9306      	str	r3, [sp, #24]
                ulNeg = 0;
 10004aa:	2700      	movs	r7, #0
 10004ac:	e002      	b.n	10004b4 <MyPrintf+0xf0>
                    ulNeg = 1;
 10004ae:	2701      	movs	r7, #1
                    ulValue = -(long)ulValue;
 10004b0:	425b      	negs	r3, r3
 10004b2:	9306      	str	r3, [sp, #24]
                ulBase = 10;
 10004b4:	230a      	movs	r3, #10
                for (ulIdx = 1;
 10004b6:	2601      	movs	r6, #1
                ulBase = 16;
 10004b8:	9301      	str	r3, [sp, #4]
                        (((ulIdx * ulBase) <= ulValue) &&
 10004ba:	9b06      	ldr	r3, [sp, #24]
 10004bc:	9305      	str	r3, [sp, #20]
 10004be:	9d01      	ldr	r5, [sp, #4]
                for (ulIdx = 1;
 10004c0:	9b05      	ldr	r3, [sp, #20]
                        (((ulIdx * ulBase) <= ulValue) &&
 10004c2:	4375      	muls	r5, r6
                for (ulIdx = 1;
 10004c4:	429d      	cmp	r5, r3
 10004c6:	d805      	bhi.n	10004d4 <MyPrintf+0x110>
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
 10004c8:	9901      	ldr	r1, [sp, #4]
 10004ca:	0028      	movs	r0, r5
 10004cc:	f003 fd2e 	bl	1003f2c <__udivsi3>
                        (((ulIdx * ulBase) <= ulValue) &&
 10004d0:	42b0      	cmp	r0, r6
 10004d2:	d049      	beq.n	1000568 <MyPrintf+0x1a4>
 10004d4:	2500      	movs	r5, #0
                if (ulNeg)
 10004d6:	42af      	cmp	r7, r5
 10004d8:	d008      	beq.n	10004ec <MyPrintf+0x128>
                if (ulNeg && (cFill == '0'))
 10004da:	9b03      	ldr	r3, [sp, #12]
                    ulCount--;
 10004dc:	3c01      	subs	r4, #1
                if (ulNeg && (cFill == '0'))
 10004de:	2b30      	cmp	r3, #48	; 0x30
 10004e0:	d104      	bne.n	10004ec <MyPrintf+0x128>
                    pcBuf[ulPos++] = '-';
 10004e2:	222d      	movs	r2, #45	; 0x2d
 10004e4:	003d      	movs	r5, r7
                    ulNeg = 0;
 10004e6:	2700      	movs	r7, #0
                    pcBuf[ulPos++] = '-';
 10004e8:	ab08      	add	r3, sp, #32
 10004ea:	701a      	strb	r2, [r3, #0]
                if ((ulCount > 1) && (ulCount < 16))
 10004ec:	1ea3      	subs	r3, r4, #2
 10004ee:	2b0d      	cmp	r3, #13
 10004f0:	d80a      	bhi.n	1000508 <MyPrintf+0x144>
                    for (ulCount--; ulCount; ulCount--)
 10004f2:	1e63      	subs	r3, r4, #1
 10004f4:	192d      	adds	r5, r5, r4
                        pcBuf[ulPos++] = cFill;
 10004f6:	a908      	add	r1, sp, #32
 10004f8:	1aea      	subs	r2, r5, r3
 10004fa:	9803      	ldr	r0, [sp, #12]
 10004fc:	3a01      	subs	r2, #1
                    for (ulCount--; ulCount; ulCount--)
 10004fe:	3b01      	subs	r3, #1
                        pcBuf[ulPos++] = cFill;
 1000500:	5488      	strb	r0, [r1, r2]
                    for (ulCount--; ulCount; ulCount--)
 1000502:	2b00      	cmp	r3, #0
 1000504:	d1f8      	bne.n	10004f8 <MyPrintf+0x134>
 1000506:	3d01      	subs	r5, #1
                if (ulNeg)
 1000508:	2f00      	cmp	r7, #0
 100050a:	d005      	beq.n	1000518 <MyPrintf+0x154>
                    pcBuf[ulPos++] = '-';
 100050c:	2108      	movs	r1, #8
 100050e:	232d      	movs	r3, #45	; 0x2d
 1000510:	aa06      	add	r2, sp, #24
 1000512:	1852      	adds	r2, r2, r1
 1000514:	5553      	strb	r3, [r2, r5]
 1000516:	3501      	adds	r5, #1
                        pcBuf[ulPos++] = g_pcHex1[(ulValue / ulIdx) % ulBase];//x
 1000518:	4f23      	ldr	r7, [pc, #140]	; (10005a8 <MyPrintf+0x1e4>)
 100051a:	ac08      	add	r4, sp, #32
                for (; ulIdx; ulIdx /= ulBase)
 100051c:	2e00      	cmp	r6, #0
 100051e:	d126      	bne.n	100056e <MyPrintf+0x1aa>
                printfsend(UART0, (uint8_t *)pcBuf, ulPos);
 1000520:	002a      	movs	r2, r5
 1000522:	a908      	add	r1, sp, #32
 1000524:	e7b6      	b.n	1000494 <MyPrintf+0xd0>
                pcStr = (int8_t *)va_arg(vaArgP, char *);
 1000526:	9b07      	ldr	r3, [sp, #28]
 1000528:	6819      	ldr	r1, [r3, #0]
 100052a:	1d1a      	adds	r2, r3, #4
                for (ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
 100052c:	000b      	movs	r3, r1
                pcStr = (int8_t *)va_arg(vaArgP, char *);
 100052e:	9207      	str	r2, [sp, #28]
                for (ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
 1000530:	2000      	movs	r0, #0
 1000532:	1a5d      	subs	r5, r3, r1
 1000534:	3301      	adds	r3, #1
 1000536:	1e5a      	subs	r2, r3, #1
 1000538:	5610      	ldrsb	r0, [r2, r0]
 100053a:	2800      	cmp	r0, #0
 100053c:	d1f8      	bne.n	1000530 <MyPrintf+0x16c>
                printfsend(UART0, (uint8_t *)pcStr, ulIdx);
 100053e:	002a      	movs	r2, r5
 1000540:	f7ff ff31 	bl	10003a6 <printfsend>
                if (ulCount > ulIdx)
 1000544:	42ac      	cmp	r4, r5
 1000546:	d800      	bhi.n	100054a <MyPrintf+0x186>
 1000548:	e743      	b.n	10003d2 <MyPrintf+0xe>
                    ulCount -= ulIdx;
 100054a:	1b64      	subs	r4, r4, r5
                    while (ulCount--)
 100054c:	3c01      	subs	r4, #1
 100054e:	d200      	bcs.n	1000552 <MyPrintf+0x18e>
 1000550:	e73f      	b.n	10003d2 <MyPrintf+0xe>
                        printfsend(UART0, (uint8_t *)" ", 1);
 1000552:	2201      	movs	r2, #1
 1000554:	4915      	ldr	r1, [pc, #84]	; (10005ac <MyPrintf+0x1e8>)
 1000556:	2000      	movs	r0, #0
 1000558:	f7ff ff25 	bl	10003a6 <printfsend>
 100055c:	e7f6      	b.n	100054c <MyPrintf+0x188>
                ulValue = va_arg(vaArgP, unsigned long);
 100055e:	9b07      	ldr	r3, [sp, #28]
 1000560:	1d1a      	adds	r2, r3, #4
 1000562:	9207      	str	r2, [sp, #28]
 1000564:	681b      	ldr	r3, [r3, #0]
 1000566:	e79f      	b.n	10004a8 <MyPrintf+0xe4>
                        ulIdx *= ulBase, ulCount--)
 1000568:	3c01      	subs	r4, #1
 100056a:	002e      	movs	r6, r5
 100056c:	e7a7      	b.n	10004be <MyPrintf+0xfa>
 100056e:	0031      	movs	r1, r6
 1000570:	9805      	ldr	r0, [sp, #20]
 1000572:	f003 fcdb 	bl	1003f2c <__udivsi3>
 1000576:	9901      	ldr	r1, [sp, #4]
 1000578:	f003 fd5e 	bl	1004038 <__aeabi_uidivmod>
                    if (HexFormat == 'x')
 100057c:	9b04      	ldr	r3, [sp, #16]
 100057e:	2b78      	cmp	r3, #120	; 0x78
 1000580:	d108      	bne.n	1000594 <MyPrintf+0x1d0>
                        pcBuf[ulPos++] = g_pcHex1[(ulValue / ulIdx) % ulBase];//x
 1000582:	5c7b      	ldrb	r3, [r7, r1]
                        pcBuf[ulPos++] = g_pcHex2[(ulValue / ulIdx) % ulBase];//X
 1000584:	5563      	strb	r3, [r4, r5]
                for (; ulIdx; ulIdx /= ulBase)
 1000586:	0030      	movs	r0, r6
 1000588:	9901      	ldr	r1, [sp, #4]
 100058a:	f003 fccf 	bl	1003f2c <__udivsi3>
 100058e:	3501      	adds	r5, #1
 1000590:	0006      	movs	r6, r0
 1000592:	e7c3      	b.n	100051c <MyPrintf+0x158>
                        pcBuf[ulPos++] = g_pcHex2[(ulValue / ulIdx) % ulBase];//X
 1000594:	4b06      	ldr	r3, [pc, #24]	; (10005b0 <MyPrintf+0x1ec>)
 1000596:	5c5b      	ldrb	r3, [r3, r1]
 1000598:	e7f4      	b.n	1000584 <MyPrintf+0x1c0>
            }
            }//switch
        }//if
    }//while
    va_end(vaArgP);
}
 100059a:	b00d      	add	sp, #52	; 0x34
 100059c:	bcf0      	pop	{r4, r5, r6, r7}
 100059e:	bc08      	pop	{r3}
 10005a0:	b004      	add	sp, #16
 10005a2:	4718      	bx	r3
 10005a4:	01004244 	.word	0x01004244
 10005a8:	01004218 	.word	0x01004218
 10005ac:	0100425d 	.word	0x0100425d
 10005b0:	01004229 	.word	0x01004229

010005b4 <printv>:

void printv(uint8_t *buf, uint32_t len, uint8_t *s)
{
 10005b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 10005b6:	0005      	movs	r5, r0
 10005b8:	000c      	movs	r4, r1
    uint32_t i = 0;
    uint32_t n = 0;
    MyPrintf("\r\n %s:", s);
 10005ba:	480d      	ldr	r0, [pc, #52]	; (10005f0 <printv+0x3c>)
 10005bc:	0011      	movs	r1, r2
 10005be:	f7ff ff01 	bl	10003c4 <MyPrintf>
    uint32_t n = 0;
 10005c2:	2600      	movs	r6, #0
 10005c4:	192b      	adds	r3, r5, r4
    for (i = 0; i < len; i++)
    {
        if (i % 16 == 0)
 10005c6:	270f      	movs	r7, #15
    for (i = 0; i < len; i++)
 10005c8:	002c      	movs	r4, r5
 10005ca:	9301      	str	r3, [sp, #4]
 10005cc:	9a01      	ldr	r2, [sp, #4]
 10005ce:	1b63      	subs	r3, r4, r5
 10005d0:	4294      	cmp	r4, r2
 10005d2:	d100      	bne.n	10005d6 <printv+0x22>
            n += 16;
        }
        MyPrintf("%02x ", buf[i]);

    }
}
 10005d4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        if (i % 16 == 0)
 10005d6:	423b      	tst	r3, r7
 10005d8:	d104      	bne.n	10005e4 <printv+0x30>
            MyPrintf("\r\n%08x:", n);
 10005da:	0031      	movs	r1, r6
 10005dc:	4805      	ldr	r0, [pc, #20]	; (10005f4 <printv+0x40>)
 10005de:	f7ff fef1 	bl	10003c4 <MyPrintf>
            n += 16;
 10005e2:	3610      	adds	r6, #16
        MyPrintf("%02x ", buf[i]);
 10005e4:	7821      	ldrb	r1, [r4, #0]
 10005e6:	4804      	ldr	r0, [pc, #16]	; (10005f8 <printv+0x44>)
 10005e8:	f7ff feec 	bl	10003c4 <MyPrintf>
 10005ec:	3401      	adds	r4, #1
 10005ee:	e7ed      	b.n	10005cc <printv+0x18>
 10005f0:	0100424a 	.word	0x0100424a
 10005f4:	01004251 	.word	0x01004251
 10005f8:	01004259 	.word	0x01004259

010005fc <_assert_handler>:

void _assert_handler(const char *file, int line, const char *func)
{
 10005fc:	e7fe      	b.n	10005fc <_assert_handler>
	...

01000600 <NVIC_SetPriority>:
#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
/* End of group Configuration_of_CMSIS */

uint32_t NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 1000600:	b530      	push	{r4, r5, lr}
 1000602:	25ff      	movs	r5, #255	; 0xff
 1000604:	2403      	movs	r4, #3
 1000606:	002a      	movs	r2, r5
 1000608:	b2c3      	uxtb	r3, r0
 100060a:	401c      	ands	r4, r3
 100060c:	00e4      	lsls	r4, r4, #3
 100060e:	40a2      	lsls	r2, r4
 1000610:	0189      	lsls	r1, r1, #6
 1000612:	4029      	ands	r1, r5
 1000614:	43d2      	mvns	r2, r2
 1000616:	40a1      	lsls	r1, r4
    if ((int32_t)(IRQn) < 0)
 1000618:	2800      	cmp	r0, #0
 100061a:	da0c      	bge.n	1000636 <NVIC_SetPriority+0x36>
    {
        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 100061c:	200f      	movs	r0, #15
 100061e:	4003      	ands	r3, r0
 1000620:	3b08      	subs	r3, #8
 1000622:	480a      	ldr	r0, [pc, #40]	; (100064c <NVIC_SetPriority+0x4c>)
 1000624:	089b      	lsrs	r3, r3, #2
 1000626:	009b      	lsls	r3, r3, #2
 1000628:	181b      	adds	r3, r3, r0
 100062a:	69d8      	ldr	r0, [r3, #28]
 100062c:	4002      	ands	r2, r0
 100062e:	4311      	orrs	r1, r2
 1000630:	61d9      	str	r1, [r3, #28]
    {
        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
                                    (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    }
    return SUCCESS;
}
 1000632:	2001      	movs	r0, #1
 1000634:	bd30      	pop	{r4, r5, pc}
 1000636:	4b06      	ldr	r3, [pc, #24]	; (1000650 <NVIC_SetPriority+0x50>)
        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 1000638:	0880      	lsrs	r0, r0, #2
 100063a:	0080      	lsls	r0, r0, #2
 100063c:	18c0      	adds	r0, r0, r3
 100063e:	23c0      	movs	r3, #192	; 0xc0
 1000640:	009b      	lsls	r3, r3, #2
 1000642:	58c4      	ldr	r4, [r0, r3]
 1000644:	4022      	ands	r2, r4
 1000646:	4311      	orrs	r1, r2
 1000648:	50c1      	str	r1, [r0, r3]
 100064a:	e7f2      	b.n	1000632 <NVIC_SetPriority+0x32>
 100064c:	e000ed00 	.word	0xe000ed00
 1000650:	e000e100 	.word	0xe000e100

01000654 <trigger_PendSV>:

#define SBC_ICSR_PENDSV_IRQ	28
void trigger_PendSV(void)
{
    SCB->ICSR |= (1 << SBC_ICSR_PENDSV_IRQ);
 1000654:	2380      	movs	r3, #128	; 0x80
 1000656:	4a03      	ldr	r2, [pc, #12]	; (1000664 <trigger_PendSV+0x10>)
 1000658:	055b      	lsls	r3, r3, #21
 100065a:	6851      	ldr	r1, [r2, #4]
 100065c:	430b      	orrs	r3, r1
 100065e:	6053      	str	r3, [r2, #4]
}
 1000660:	4770      	bx	lr
 1000662:	46c0      	nop			; (mov r8, r8)
 1000664:	e000ed00 	.word	0xe000ed00

01000668 <NVIC_EnableIRQ>:
{
    SYSCTRL_CLK_CLS |= 1 << id;
}
static inline void enable_intr(int intid)
{
    NVIC_ISER |= 1 << intid;
 1000668:	2301      	movs	r3, #1
 100066a:	4083      	lsls	r3, r0
 100066c:	4a02      	ldr	r2, [pc, #8]	; (1000678 <NVIC_EnableIRQ+0x10>)
 100066e:	6811      	ldr	r1, [r2, #0]
 1000670:	430b      	orrs	r3, r1
 1000672:	6013      	str	r3, [r2, #0]

void	NVIC_EnableIRQ(IRQn_Type IRQnx)
{
    enable_intr((int) IRQnx);
}
 1000674:	4770      	bx	lr
 1000676:	46c0      	nop			; (mov r8, r8)
 1000678:	e000e100 	.word	0xe000e100

0100067c <NVIC_DisableIRQ>:
}
static inline void disable_intr(int intid)
{
    NVIC_ICER = 1 << intid;
 100067c:	2301      	movs	r3, #1
 100067e:	4083      	lsls	r3, r0
 1000680:	4a01      	ldr	r2, [pc, #4]	; (1000688 <NVIC_DisableIRQ+0xc>)
 1000682:	6013      	str	r3, [r2, #0]

void  NVIC_DisableIRQ(IRQn_Type IRQnx)
{
    disable_intr((int) IRQnx);
}
 1000684:	4770      	bx	lr
 1000686:	46c0      	nop			; (mov r8, r8)
 1000688:	e000e180 	.word	0xe000e180

0100068c <soft_reset>:

void soft_reset(void)
{
    SYSCTRL_RST_EN |= 0x01;
 100068c:	2301      	movs	r3, #1
 100068e:	4a04      	ldr	r2, [pc, #16]	; (10006a0 <soft_reset+0x14>)
 1000690:	6811      	ldr	r1, [r2, #0]
 1000692:	430b      	orrs	r3, r1
 1000694:	6013      	str	r3, [r2, #0]
    SYSCTRL_RESET = 0x55;
 1000696:	2255      	movs	r2, #85	; 0x55
 1000698:	4b02      	ldr	r3, [pc, #8]	; (10006a4 <soft_reset+0x18>)
 100069a:	601a      	str	r2, [r3, #0]
 100069c:	e7fe      	b.n	100069c <soft_reset+0x10>
 100069e:	46c0      	nop			; (mov r8, r8)
 10006a0:	000f8574 	.word	0x000f8574
 10006a4:	000f857c 	.word	0x000f857c

010006a8 <get_primask>:
    while (1);
}

uint32_t get_primask(void)
{
    __asm volatile("mrs r0, primask");
 10006a8:	f3ef 8010 	mrs	r0, PRIMASK
}
 10006ac:	4770      	bx	lr

010006ae <get_msp>:

uint32_t get_msp(void)
{
    __asm volatile("mrs r0, msp");
 10006ae:	f3ef 8008 	mrs	r0, MSP
}
 10006b2:	4770      	bx	lr

010006b4 <set_msp>:
    __asm volatile("msr msp,mainStackPointer");
}
#else
void set_msp(uint32_t mainStackPointer)
{
    __asm volatile("msr msp,r0");
 10006b4:	f380 8808 	msr	MSP, r0
}
 10006b8:	4770      	bx	lr
	...

010006bc <GPIO_Config>:

#include "yc_gpio.h"
#include "yc_lpm.h"

void GPIO_Config(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, GPIO_FunTypeDef function)
{
 10006bc:	b570      	push	{r4, r5, r6, lr}
 10006be:	0005      	movs	r5, r0
 10006c0:	000c      	movs	r4, r1
 10006c2:	0016      	movs	r6, r2
    _ASSERT(ISGPIOGROUP(GPIOx));
 10006c4:	2802      	cmp	r0, #2
 10006c6:	d904      	bls.n	10006d2 <GPIO_Config+0x16>
 10006c8:	4a21      	ldr	r2, [pc, #132]	; (1000750 <GPIO_Config+0x94>)
 10006ca:	210e      	movs	r1, #14
 10006cc:	4821      	ldr	r0, [pc, #132]	; (1000754 <GPIO_Config+0x98>)
 10006ce:	f7ff ff95 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 10006d2:	1e63      	subs	r3, r4, #1
 10006d4:	2b01      	cmp	r3, #1
 10006d6:	d92c      	bls.n	1000732 <GPIO_Config+0x76>
 10006d8:	2204      	movs	r2, #4
 10006da:	1f23      	subs	r3, r4, #4
 10006dc:	4393      	bics	r3, r2
 10006de:	b29b      	uxth	r3, r3
 10006e0:	2b00      	cmp	r3, #0
 10006e2:	d026      	beq.n	1000732 <GPIO_Config+0x76>
 10006e4:	0023      	movs	r3, r4
 10006e6:	320c      	adds	r2, #12
 10006e8:	3b10      	subs	r3, #16
 10006ea:	4393      	bics	r3, r2
 10006ec:	b29b      	uxth	r3, r3
 10006ee:	2b00      	cmp	r3, #0
 10006f0:	d01f      	beq.n	1000732 <GPIO_Config+0x76>
 10006f2:	0023      	movs	r3, r4
 10006f4:	3230      	adds	r2, #48	; 0x30
 10006f6:	3b40      	subs	r3, #64	; 0x40
 10006f8:	4393      	bics	r3, r2
 10006fa:	b29b      	uxth	r3, r3
 10006fc:	2b00      	cmp	r3, #0
 10006fe:	d018      	beq.n	1000732 <GPIO_Config+0x76>
 1000700:	1e63      	subs	r3, r4, #1
 1000702:	4a15      	ldr	r2, [pc, #84]	; (1000758 <GPIO_Config+0x9c>)
 1000704:	3bff      	subs	r3, #255	; 0xff
 1000706:	4213      	tst	r3, r2
 1000708:	d013      	beq.n	1000732 <GPIO_Config+0x76>
 100070a:	4b14      	ldr	r3, [pc, #80]	; (100075c <GPIO_Config+0xa0>)
 100070c:	4a14      	ldr	r2, [pc, #80]	; (1000760 <GPIO_Config+0xa4>)
 100070e:	18e3      	adds	r3, r4, r3
 1000710:	4213      	tst	r3, r2
 1000712:	d00e      	beq.n	1000732 <GPIO_Config+0x76>
 1000714:	4b13      	ldr	r3, [pc, #76]	; (1000764 <GPIO_Config+0xa8>)
 1000716:	4a14      	ldr	r2, [pc, #80]	; (1000768 <GPIO_Config+0xac>)
 1000718:	18e3      	adds	r3, r4, r3
 100071a:	4213      	tst	r3, r2
 100071c:	d009      	beq.n	1000732 <GPIO_Config+0x76>
 100071e:	4b13      	ldr	r3, [pc, #76]	; (100076c <GPIO_Config+0xb0>)
 1000720:	4a13      	ldr	r2, [pc, #76]	; (1000770 <GPIO_Config+0xb4>)
 1000722:	18e3      	adds	r3, r4, r3
 1000724:	4213      	tst	r3, r2
 1000726:	d004      	beq.n	1000732 <GPIO_Config+0x76>
 1000728:	4a09      	ldr	r2, [pc, #36]	; (1000750 <GPIO_Config+0x94>)
 100072a:	210f      	movs	r1, #15
 100072c:	4809      	ldr	r0, [pc, #36]	; (1000754 <GPIO_Config+0x98>)
 100072e:	f7ff ff65 	bl	10005fc <_assert_handler>
    int i;

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (GPIO_Pin & 1 << i)
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = function;
 1000732:	4b10      	ldr	r3, [pc, #64]	; (1000774 <GPIO_Config+0xb8>)
        if (GPIO_Pin & 1 << i)
 1000734:	2201      	movs	r2, #1
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = function;
 1000736:	18ed      	adds	r5, r5, r3
 1000738:	2300      	movs	r3, #0
 100073a:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 100073c:	0021      	movs	r1, r4
 100073e:	4119      	asrs	r1, r3
 1000740:	4211      	tst	r1, r2
 1000742:	d001      	beq.n	1000748 <GPIO_Config+0x8c>
 1000744:	1959      	adds	r1, r3, r5
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = function;
 1000746:	700e      	strb	r6, [r1, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000748:	3301      	adds	r3, #1
 100074a:	2b10      	cmp	r3, #16
 100074c:	d1f6      	bne.n	100073c <GPIO_Config+0x80>
    }
}
 100074e:	bd70      	pop	{r4, r5, r6, pc}
 1000750:	0100541c 	.word	0x0100541c
 1000754:	010053f5 	.word	0x010053f5
 1000758:	0000feff 	.word	0x0000feff
 100075c:	fffffc00 	.word	0xfffffc00
 1000760:	0000fbff 	.word	0x0000fbff
 1000764:	fffff000 	.word	0xfffff000
 1000768:	0000efff 	.word	0x0000efff
 100076c:	ffffc000 	.word	0xffffc000
 1000770:	0000bfff 	.word	0x0000bfff
 1000774:	0000f870 	.word	0x0000f870

01000778 <GPIO_Init>:

void GPIO_Init(GPIO_TypeDef GPIOx, GPIO_InitTypeDef *GPIO_InitStruct)
{
 1000778:	b570      	push	{r4, r5, r6, lr}
 100077a:	0004      	movs	r4, r0
 100077c:	000d      	movs	r5, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 100077e:	2802      	cmp	r0, #2
 1000780:	d904      	bls.n	100078c <GPIO_Init+0x14>
 1000782:	4a2f      	ldr	r2, [pc, #188]	; (1000840 <GPIO_Init+0xc8>)
 1000784:	211c      	movs	r1, #28
 1000786:	482f      	ldr	r0, [pc, #188]	; (1000844 <GPIO_Init+0xcc>)
 1000788:	f7ff ff38 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
 100078c:	882b      	ldrh	r3, [r5, #0]
 100078e:	2b00      	cmp	r3, #0
 1000790:	d104      	bne.n	100079c <GPIO_Init+0x24>
 1000792:	4a2b      	ldr	r2, [pc, #172]	; (1000840 <GPIO_Init+0xc8>)
 1000794:	211d      	movs	r1, #29
 1000796:	482b      	ldr	r0, [pc, #172]	; (1000844 <GPIO_Init+0xcc>)
 1000798:	f7ff ff30 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
 100079c:	78ab      	ldrb	r3, [r5, #2]
 100079e:	3b01      	subs	r3, #1
 10007a0:	2b04      	cmp	r3, #4
 10007a2:	d904      	bls.n	10007ae <GPIO_Init+0x36>
 10007a4:	4a26      	ldr	r2, [pc, #152]	; (1000840 <GPIO_Init+0xc8>)
 10007a6:	211e      	movs	r1, #30
 10007a8:	4826      	ldr	r0, [pc, #152]	; (1000844 <GPIO_Init+0xcc>)
 10007aa:	f7ff ff27 	bl	10005fc <_assert_handler>

    int i;

    switch (GPIO_InitStruct->GPIO_Mode)
 10007ae:	78a8      	ldrb	r0, [r5, #2]
 10007b0:	3801      	subs	r0, #1
 10007b2:	2804      	cmp	r0, #4
 10007b4:	d813      	bhi.n	10007de <GPIO_Init+0x66>
 10007b6:	4b24      	ldr	r3, [pc, #144]	; (1000848 <GPIO_Init+0xd0>)
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0xC0;
        }
        break;

    case GPIO_Mode_Out_PP:
        for (i = 0; i < GPIO_PIN_NUM; i++)
 10007b8:	2200      	movs	r2, #0
 10007ba:	18e3      	adds	r3, r4, r3
        {
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x3E;
 10007bc:	011b      	lsls	r3, r3, #4
    switch (GPIO_InitStruct->GPIO_Mode)
 10007be:	f003 fba1 	bl	1003f04 <__gnu_thumb1_case_uqi>
 10007c2:	0f03      	.short	0x0f03
 10007c4:	271b      	.short	0x271b
 10007c6:	33          	.byte	0x33
 10007c7:	00          	.byte	0x00
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007c8:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x00;
 10007ca:	0014      	movs	r4, r2
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007cc:	8829      	ldrh	r1, [r5, #0]
 10007ce:	4111      	asrs	r1, r2
 10007d0:	4201      	tst	r1, r0
 10007d2:	d001      	beq.n	10007d8 <GPIO_Init+0x60>
 10007d4:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x00;
 10007d6:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 10007d8:	3201      	adds	r2, #1
 10007da:	2a10      	cmp	r2, #16
 10007dc:	d1f6      	bne.n	10007cc <GPIO_Init+0x54>
        break;

    default:
        break;
    }
}
 10007de:	bd70      	pop	{r4, r5, r6, pc}
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007e0:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x40;
 10007e2:	2440      	movs	r4, #64	; 0x40
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007e4:	8829      	ldrh	r1, [r5, #0]
 10007e6:	4111      	asrs	r1, r2
 10007e8:	4201      	tst	r1, r0
 10007ea:	d001      	beq.n	10007f0 <GPIO_Init+0x78>
 10007ec:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x40;
 10007ee:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 10007f0:	3201      	adds	r2, #1
 10007f2:	2a10      	cmp	r2, #16
 10007f4:	d1f6      	bne.n	10007e4 <GPIO_Init+0x6c>
 10007f6:	e7f2      	b.n	10007de <GPIO_Init+0x66>
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007f8:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x80;
 10007fa:	2480      	movs	r4, #128	; 0x80
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007fc:	8829      	ldrh	r1, [r5, #0]
 10007fe:	4111      	asrs	r1, r2
 1000800:	4201      	tst	r1, r0
 1000802:	d001      	beq.n	1000808 <GPIO_Init+0x90>
 1000804:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x80;
 1000806:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 1000808:	3201      	adds	r2, #1
 100080a:	2a10      	cmp	r2, #16
 100080c:	d1f6      	bne.n	10007fc <GPIO_Init+0x84>
 100080e:	e7e6      	b.n	10007de <GPIO_Init+0x66>
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000810:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0xC0;
 1000812:	24c0      	movs	r4, #192	; 0xc0
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000814:	8829      	ldrh	r1, [r5, #0]
 1000816:	4111      	asrs	r1, r2
 1000818:	4201      	tst	r1, r0
 100081a:	d001      	beq.n	1000820 <GPIO_Init+0xa8>
 100081c:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0xC0;
 100081e:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 1000820:	3201      	adds	r2, #1
 1000822:	2a10      	cmp	r2, #16
 1000824:	d1f6      	bne.n	1000814 <GPIO_Init+0x9c>
 1000826:	e7da      	b.n	10007de <GPIO_Init+0x66>
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000828:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x3E;
 100082a:	243e      	movs	r4, #62	; 0x3e
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 100082c:	8829      	ldrh	r1, [r5, #0]
 100082e:	4111      	asrs	r1, r2
 1000830:	4201      	tst	r1, r0
 1000832:	d001      	beq.n	1000838 <GPIO_Init+0xc0>
 1000834:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x3E;
 1000836:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 1000838:	3201      	adds	r2, #1
 100083a:	2a10      	cmp	r2, #16
 100083c:	d1f6      	bne.n	100082c <GPIO_Init+0xb4>
 100083e:	e7ce      	b.n	10007de <GPIO_Init+0x66>
 1000840:	01005428 	.word	0x01005428
 1000844:	010053f5 	.word	0x010053f5
 1000848:	0000f870 	.word	0x0000f870

0100084c <GPIO_PullUpCmd>:

void GPIO_PullUpCmd(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, FunctionalState NewState)
{
 100084c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100084e:	0005      	movs	r5, r0
 1000850:	000c      	movs	r4, r1
 1000852:	0016      	movs	r6, r2
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000854:	2802      	cmp	r0, #2
 1000856:	d904      	bls.n	1000862 <GPIO_PullUpCmd+0x16>
 1000858:	4a27      	ldr	r2, [pc, #156]	; (10008f8 <GPIO_PullUpCmd+0xac>)
 100085a:	2153      	movs	r1, #83	; 0x53
 100085c:	4827      	ldr	r0, [pc, #156]	; (10008fc <GPIO_PullUpCmd+0xb0>)
 100085e:	f7ff fecd 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000862:	1e63      	subs	r3, r4, #1
 1000864:	2b01      	cmp	r3, #1
 1000866:	d92c      	bls.n	10008c2 <GPIO_PullUpCmd+0x76>
 1000868:	2204      	movs	r2, #4
 100086a:	1f23      	subs	r3, r4, #4
 100086c:	4393      	bics	r3, r2
 100086e:	b29b      	uxth	r3, r3
 1000870:	2b00      	cmp	r3, #0
 1000872:	d026      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 1000874:	0023      	movs	r3, r4
 1000876:	320c      	adds	r2, #12
 1000878:	3b10      	subs	r3, #16
 100087a:	4393      	bics	r3, r2
 100087c:	b29b      	uxth	r3, r3
 100087e:	2b00      	cmp	r3, #0
 1000880:	d01f      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 1000882:	0023      	movs	r3, r4
 1000884:	3230      	adds	r2, #48	; 0x30
 1000886:	3b40      	subs	r3, #64	; 0x40
 1000888:	4393      	bics	r3, r2
 100088a:	b29b      	uxth	r3, r3
 100088c:	2b00      	cmp	r3, #0
 100088e:	d018      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 1000890:	1e63      	subs	r3, r4, #1
 1000892:	4a1b      	ldr	r2, [pc, #108]	; (1000900 <GPIO_PullUpCmd+0xb4>)
 1000894:	3bff      	subs	r3, #255	; 0xff
 1000896:	4213      	tst	r3, r2
 1000898:	d013      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 100089a:	4b1a      	ldr	r3, [pc, #104]	; (1000904 <GPIO_PullUpCmd+0xb8>)
 100089c:	4a1a      	ldr	r2, [pc, #104]	; (1000908 <GPIO_PullUpCmd+0xbc>)
 100089e:	18e3      	adds	r3, r4, r3
 10008a0:	4213      	tst	r3, r2
 10008a2:	d00e      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 10008a4:	4b19      	ldr	r3, [pc, #100]	; (100090c <GPIO_PullUpCmd+0xc0>)
 10008a6:	4a1a      	ldr	r2, [pc, #104]	; (1000910 <GPIO_PullUpCmd+0xc4>)
 10008a8:	18e3      	adds	r3, r4, r3
 10008aa:	4213      	tst	r3, r2
 10008ac:	d009      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 10008ae:	4b19      	ldr	r3, [pc, #100]	; (1000914 <GPIO_PullUpCmd+0xc8>)
 10008b0:	4a19      	ldr	r2, [pc, #100]	; (1000918 <GPIO_PullUpCmd+0xcc>)
 10008b2:	18e3      	adds	r3, r4, r3
 10008b4:	4213      	tst	r3, r2
 10008b6:	d004      	beq.n	10008c2 <GPIO_PullUpCmd+0x76>
 10008b8:	4a0f      	ldr	r2, [pc, #60]	; (10008f8 <GPIO_PullUpCmd+0xac>)
 10008ba:	2154      	movs	r1, #84	; 0x54
 10008bc:	480f      	ldr	r0, [pc, #60]	; (10008fc <GPIO_PullUpCmd+0xb0>)
 10008be:	f7ff fe9d 	bl	10005fc <_assert_handler>
            {
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 1 << 6;
            }
            else if (NewState == DISABLE)
            {
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008c2:	4b16      	ldr	r3, [pc, #88]	; (100091c <GPIO_PullUpCmd+0xd0>)
        if (GPIO_Pin & 1 << i)
 10008c4:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008c6:	18ed      	adds	r5, r5, r3
 10008c8:	2140      	movs	r1, #64	; 0x40
 10008ca:	2300      	movs	r3, #0
 10008cc:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 10008ce:	0022      	movs	r2, r4
 10008d0:	411a      	asrs	r2, r3
 10008d2:	4202      	tst	r2, r0
 10008d4:	d005      	beq.n	10008e2 <GPIO_PullUpCmd+0x96>
            if (NewState == ENABLE)
 10008d6:	2e01      	cmp	r6, #1
 10008d8:	d107      	bne.n	10008ea <GPIO_PullUpCmd+0x9e>
 10008da:	195f      	adds	r7, r3, r5
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 1 << 6;
 10008dc:	783a      	ldrb	r2, [r7, #0]
 10008de:	430a      	orrs	r2, r1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008e0:	703a      	strb	r2, [r7, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 10008e2:	3301      	adds	r3, #1
 10008e4:	2b10      	cmp	r3, #16
 10008e6:	d1f2      	bne.n	10008ce <GPIO_PullUpCmd+0x82>
            }
        }
    }
}
 10008e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            else if (NewState == DISABLE)
 10008ea:	2e00      	cmp	r6, #0
 10008ec:	d1f9      	bne.n	10008e2 <GPIO_PullUpCmd+0x96>
 10008ee:	195f      	adds	r7, r3, r5
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008f0:	783a      	ldrb	r2, [r7, #0]
 10008f2:	438a      	bics	r2, r1
 10008f4:	e7f4      	b.n	10008e0 <GPIO_PullUpCmd+0x94>
 10008f6:	46c0      	nop			; (mov r8, r8)
 10008f8:	01005432 	.word	0x01005432
 10008fc:	010053f5 	.word	0x010053f5
 1000900:	0000feff 	.word	0x0000feff
 1000904:	fffffc00 	.word	0xfffffc00
 1000908:	0000fbff 	.word	0x0000fbff
 100090c:	fffff000 	.word	0xfffff000
 1000910:	0000efff 	.word	0x0000efff
 1000914:	ffffc000 	.word	0xffffc000
 1000918:	0000bfff 	.word	0x0000bfff
 100091c:	0000f870 	.word	0x0000f870

01000920 <GPIO_ReadInputData>:

uint16_t GPIO_ReadInputData(GPIO_TypeDef GPIOx)
{
 1000920:	b510      	push	{r4, lr}
 1000922:	0004      	movs	r4, r0
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000924:	2802      	cmp	r0, #2
 1000926:	d904      	bls.n	1000932 <GPIO_ReadInputData+0x12>
 1000928:	4a05      	ldr	r2, [pc, #20]	; (1000940 <GPIO_ReadInputData+0x20>)
 100092a:	216a      	movs	r1, #106	; 0x6a
 100092c:	4805      	ldr	r0, [pc, #20]	; (1000944 <GPIO_ReadInputData+0x24>)
 100092e:	f7ff fe65 	bl	10005fc <_assert_handler>

    return GPIO_IN(GPIOx);
 1000932:	4b05      	ldr	r3, [pc, #20]	; (1000948 <GPIO_ReadInputData+0x28>)
 1000934:	0064      	lsls	r4, r4, #1
 1000936:	18e4      	adds	r4, r4, r3
 1000938:	8820      	ldrh	r0, [r4, #0]
 100093a:	b280      	uxth	r0, r0
}
 100093c:	bd10      	pop	{r4, pc}
 100093e:	46c0      	nop			; (mov r8, r8)
 1000940:	01005441 	.word	0x01005441
 1000944:	010053f5 	.word	0x010053f5
 1000948:	000f873c 	.word	0x000f873c

0100094c <GPIO_ReadInputDataBit>:

uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 100094c:	b570      	push	{r4, r5, r6, lr}
 100094e:	0005      	movs	r5, r0
 1000950:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000952:	2802      	cmp	r0, #2
 1000954:	d904      	bls.n	1000960 <GPIO_ReadInputDataBit+0x14>
 1000956:	4a1f      	ldr	r2, [pc, #124]	; (10009d4 <GPIO_ReadInputDataBit+0x88>)
 1000958:	2171      	movs	r1, #113	; 0x71
 100095a:	481f      	ldr	r0, [pc, #124]	; (10009d8 <GPIO_ReadInputDataBit+0x8c>)
 100095c:	f7ff fe4e 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000960:	1e63      	subs	r3, r4, #1
 1000962:	2b01      	cmp	r3, #1
 1000964:	d92c      	bls.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 1000966:	2204      	movs	r2, #4
 1000968:	1f23      	subs	r3, r4, #4
 100096a:	4393      	bics	r3, r2
 100096c:	b29b      	uxth	r3, r3
 100096e:	2b00      	cmp	r3, #0
 1000970:	d026      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 1000972:	0023      	movs	r3, r4
 1000974:	320c      	adds	r2, #12
 1000976:	3b10      	subs	r3, #16
 1000978:	4393      	bics	r3, r2
 100097a:	b29b      	uxth	r3, r3
 100097c:	2b00      	cmp	r3, #0
 100097e:	d01f      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 1000980:	0023      	movs	r3, r4
 1000982:	3230      	adds	r2, #48	; 0x30
 1000984:	3b40      	subs	r3, #64	; 0x40
 1000986:	4393      	bics	r3, r2
 1000988:	b29b      	uxth	r3, r3
 100098a:	2b00      	cmp	r3, #0
 100098c:	d018      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 100098e:	1e63      	subs	r3, r4, #1
 1000990:	4a12      	ldr	r2, [pc, #72]	; (10009dc <GPIO_ReadInputDataBit+0x90>)
 1000992:	3bff      	subs	r3, #255	; 0xff
 1000994:	4213      	tst	r3, r2
 1000996:	d013      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 1000998:	4b11      	ldr	r3, [pc, #68]	; (10009e0 <GPIO_ReadInputDataBit+0x94>)
 100099a:	4a12      	ldr	r2, [pc, #72]	; (10009e4 <GPIO_ReadInputDataBit+0x98>)
 100099c:	18e3      	adds	r3, r4, r3
 100099e:	4213      	tst	r3, r2
 10009a0:	d00e      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 10009a2:	4b11      	ldr	r3, [pc, #68]	; (10009e8 <GPIO_ReadInputDataBit+0x9c>)
 10009a4:	4a11      	ldr	r2, [pc, #68]	; (10009ec <GPIO_ReadInputDataBit+0xa0>)
 10009a6:	18e3      	adds	r3, r4, r3
 10009a8:	4213      	tst	r3, r2
 10009aa:	d009      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 10009ac:	4b10      	ldr	r3, [pc, #64]	; (10009f0 <GPIO_ReadInputDataBit+0xa4>)
 10009ae:	4a11      	ldr	r2, [pc, #68]	; (10009f4 <GPIO_ReadInputDataBit+0xa8>)
 10009b0:	18e3      	adds	r3, r4, r3
 10009b2:	4213      	tst	r3, r2
 10009b4:	d004      	beq.n	10009c0 <GPIO_ReadInputDataBit+0x74>
 10009b6:	4a07      	ldr	r2, [pc, #28]	; (10009d4 <GPIO_ReadInputDataBit+0x88>)
 10009b8:	2172      	movs	r1, #114	; 0x72
 10009ba:	4807      	ldr	r0, [pc, #28]	; (10009d8 <GPIO_ReadInputDataBit+0x8c>)
 10009bc:	f7ff fe1e 	bl	10005fc <_assert_handler>

    if (GPIO_IN(GPIOx) & GPIO_Pin)
 10009c0:	4b0d      	ldr	r3, [pc, #52]	; (10009f8 <GPIO_ReadInputDataBit+0xac>)
 10009c2:	006d      	lsls	r5, r5, #1
 10009c4:	18ed      	adds	r5, r5, r3
 10009c6:	8828      	ldrh	r0, [r5, #0]
 10009c8:	4004      	ands	r4, r0
 10009ca:	1e60      	subs	r0, r4, #1
 10009cc:	4184      	sbcs	r4, r0
 10009ce:	b2e0      	uxtb	r0, r4
    }
    else
    {
        return (uint8_t)0x00;
    }
}
 10009d0:	bd70      	pop	{r4, r5, r6, pc}
 10009d2:	46c0      	nop			; (mov r8, r8)
 10009d4:	01005454 	.word	0x01005454
 10009d8:	010053f5 	.word	0x010053f5
 10009dc:	0000feff 	.word	0x0000feff
 10009e0:	fffffc00 	.word	0xfffffc00
 10009e4:	0000fbff 	.word	0x0000fbff
 10009e8:	fffff000 	.word	0xfffff000
 10009ec:	0000efff 	.word	0x0000efff
 10009f0:	ffffc000 	.word	0xffffc000
 10009f4:	0000bfff 	.word	0x0000bfff
 10009f8:	000f873c 	.word	0x000f873c

010009fc <GPIO_ReadOutputData>:

uint16_t GPIO_ReadOutputData(GPIO_TypeDef GPIOx)
{
 10009fc:	b510      	push	{r4, lr}
 10009fe:	0004      	movs	r4, r0
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000a00:	2802      	cmp	r0, #2
 1000a02:	d904      	bls.n	1000a0e <GPIO_ReadOutputData+0x12>
 1000a04:	4a05      	ldr	r2, [pc, #20]	; (1000a1c <GPIO_ReadOutputData+0x20>)
 1000a06:	2180      	movs	r1, #128	; 0x80
 1000a08:	4805      	ldr	r0, [pc, #20]	; (1000a20 <GPIO_ReadOutputData+0x24>)
 1000a0a:	f7ff fdf7 	bl	10005fc <_assert_handler>

    return GPIO_IN(GPIOx);
 1000a0e:	4b05      	ldr	r3, [pc, #20]	; (1000a24 <GPIO_ReadOutputData+0x28>)
 1000a10:	0064      	lsls	r4, r4, #1
 1000a12:	18e4      	adds	r4, r4, r3
 1000a14:	8820      	ldrh	r0, [r4, #0]
 1000a16:	b280      	uxth	r0, r0
}
 1000a18:	bd10      	pop	{r4, pc}
 1000a1a:	46c0      	nop			; (mov r8, r8)
 1000a1c:	0100546a 	.word	0x0100546a
 1000a20:	010053f5 	.word	0x010053f5
 1000a24:	000f873c 	.word	0x000f873c

01000a28 <GPIO_ReadOutputDataBit>:

uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000a28:	b570      	push	{r4, r5, r6, lr}
 1000a2a:	0005      	movs	r5, r0
 1000a2c:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000a2e:	2802      	cmp	r0, #2
 1000a30:	d904      	bls.n	1000a3c <GPIO_ReadOutputDataBit+0x14>
 1000a32:	4a1f      	ldr	r2, [pc, #124]	; (1000ab0 <GPIO_ReadOutputDataBit+0x88>)
 1000a34:	2187      	movs	r1, #135	; 0x87
 1000a36:	481f      	ldr	r0, [pc, #124]	; (1000ab4 <GPIO_ReadOutputDataBit+0x8c>)
 1000a38:	f7ff fde0 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000a3c:	1e63      	subs	r3, r4, #1
 1000a3e:	2b01      	cmp	r3, #1
 1000a40:	d92c      	bls.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a42:	2204      	movs	r2, #4
 1000a44:	1f23      	subs	r3, r4, #4
 1000a46:	4393      	bics	r3, r2
 1000a48:	b29b      	uxth	r3, r3
 1000a4a:	2b00      	cmp	r3, #0
 1000a4c:	d026      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a4e:	0023      	movs	r3, r4
 1000a50:	320c      	adds	r2, #12
 1000a52:	3b10      	subs	r3, #16
 1000a54:	4393      	bics	r3, r2
 1000a56:	b29b      	uxth	r3, r3
 1000a58:	2b00      	cmp	r3, #0
 1000a5a:	d01f      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a5c:	0023      	movs	r3, r4
 1000a5e:	3230      	adds	r2, #48	; 0x30
 1000a60:	3b40      	subs	r3, #64	; 0x40
 1000a62:	4393      	bics	r3, r2
 1000a64:	b29b      	uxth	r3, r3
 1000a66:	2b00      	cmp	r3, #0
 1000a68:	d018      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a6a:	1e63      	subs	r3, r4, #1
 1000a6c:	4a12      	ldr	r2, [pc, #72]	; (1000ab8 <GPIO_ReadOutputDataBit+0x90>)
 1000a6e:	3bff      	subs	r3, #255	; 0xff
 1000a70:	4213      	tst	r3, r2
 1000a72:	d013      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a74:	4b11      	ldr	r3, [pc, #68]	; (1000abc <GPIO_ReadOutputDataBit+0x94>)
 1000a76:	4a12      	ldr	r2, [pc, #72]	; (1000ac0 <GPIO_ReadOutputDataBit+0x98>)
 1000a78:	18e3      	adds	r3, r4, r3
 1000a7a:	4213      	tst	r3, r2
 1000a7c:	d00e      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a7e:	4b11      	ldr	r3, [pc, #68]	; (1000ac4 <GPIO_ReadOutputDataBit+0x9c>)
 1000a80:	4a11      	ldr	r2, [pc, #68]	; (1000ac8 <GPIO_ReadOutputDataBit+0xa0>)
 1000a82:	18e3      	adds	r3, r4, r3
 1000a84:	4213      	tst	r3, r2
 1000a86:	d009      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a88:	4b10      	ldr	r3, [pc, #64]	; (1000acc <GPIO_ReadOutputDataBit+0xa4>)
 1000a8a:	4a11      	ldr	r2, [pc, #68]	; (1000ad0 <GPIO_ReadOutputDataBit+0xa8>)
 1000a8c:	18e3      	adds	r3, r4, r3
 1000a8e:	4213      	tst	r3, r2
 1000a90:	d004      	beq.n	1000a9c <GPIO_ReadOutputDataBit+0x74>
 1000a92:	4a07      	ldr	r2, [pc, #28]	; (1000ab0 <GPIO_ReadOutputDataBit+0x88>)
 1000a94:	2188      	movs	r1, #136	; 0x88
 1000a96:	4807      	ldr	r0, [pc, #28]	; (1000ab4 <GPIO_ReadOutputDataBit+0x8c>)
 1000a98:	f7ff fdb0 	bl	10005fc <_assert_handler>

    if (GPIO_IN(GPIOx) & GPIO_Pin)
 1000a9c:	4b0d      	ldr	r3, [pc, #52]	; (1000ad4 <GPIO_ReadOutputDataBit+0xac>)
 1000a9e:	006d      	lsls	r5, r5, #1
 1000aa0:	18ed      	adds	r5, r5, r3
 1000aa2:	8828      	ldrh	r0, [r5, #0]
 1000aa4:	4004      	ands	r4, r0
 1000aa6:	1e60      	subs	r0, r4, #1
 1000aa8:	4184      	sbcs	r4, r0
 1000aaa:	b2e0      	uxtb	r0, r4
    }
    else
    {
        return (uint8_t)0x00;
    }
}
 1000aac:	bd70      	pop	{r4, r5, r6, pc}
 1000aae:	46c0      	nop			; (mov r8, r8)
 1000ab0:	0100547e 	.word	0x0100547e
 1000ab4:	010053f5 	.word	0x010053f5
 1000ab8:	0000feff 	.word	0x0000feff
 1000abc:	fffffc00 	.word	0xfffffc00
 1000ac0:	0000fbff 	.word	0x0000fbff
 1000ac4:	fffff000 	.word	0xfffff000
 1000ac8:	0000efff 	.word	0x0000efff
 1000acc:	ffffc000 	.word	0xffffc000
 1000ad0:	0000bfff 	.word	0x0000bfff
 1000ad4:	000f873c 	.word	0x000f873c

01000ad8 <GPIO_ResetBits>:

void GPIO_ResetBits(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000ad8:	b570      	push	{r4, r5, r6, lr}
 1000ada:	0005      	movs	r5, r0
 1000adc:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000ade:	2802      	cmp	r0, #2
 1000ae0:	d904      	bls.n	1000aec <GPIO_ResetBits+0x14>
 1000ae2:	4a24      	ldr	r2, [pc, #144]	; (1000b74 <GPIO_ResetBits+0x9c>)
 1000ae4:	2196      	movs	r1, #150	; 0x96
 1000ae6:	4824      	ldr	r0, [pc, #144]	; (1000b78 <GPIO_ResetBits+0xa0>)
 1000ae8:	f7ff fd88 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000aec:	1e63      	subs	r3, r4, #1
 1000aee:	2b01      	cmp	r3, #1
 1000af0:	d92c      	bls.n	1000b4c <GPIO_ResetBits+0x74>
 1000af2:	2204      	movs	r2, #4
 1000af4:	1f23      	subs	r3, r4, #4
 1000af6:	4393      	bics	r3, r2
 1000af8:	b29b      	uxth	r3, r3
 1000afa:	2b00      	cmp	r3, #0
 1000afc:	d026      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000afe:	0023      	movs	r3, r4
 1000b00:	320c      	adds	r2, #12
 1000b02:	3b10      	subs	r3, #16
 1000b04:	4393      	bics	r3, r2
 1000b06:	b29b      	uxth	r3, r3
 1000b08:	2b00      	cmp	r3, #0
 1000b0a:	d01f      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000b0c:	0023      	movs	r3, r4
 1000b0e:	3230      	adds	r2, #48	; 0x30
 1000b10:	3b40      	subs	r3, #64	; 0x40
 1000b12:	4393      	bics	r3, r2
 1000b14:	b29b      	uxth	r3, r3
 1000b16:	2b00      	cmp	r3, #0
 1000b18:	d018      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000b1a:	1e63      	subs	r3, r4, #1
 1000b1c:	4a17      	ldr	r2, [pc, #92]	; (1000b7c <GPIO_ResetBits+0xa4>)
 1000b1e:	3bff      	subs	r3, #255	; 0xff
 1000b20:	4213      	tst	r3, r2
 1000b22:	d013      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000b24:	4b16      	ldr	r3, [pc, #88]	; (1000b80 <GPIO_ResetBits+0xa8>)
 1000b26:	4a17      	ldr	r2, [pc, #92]	; (1000b84 <GPIO_ResetBits+0xac>)
 1000b28:	18e3      	adds	r3, r4, r3
 1000b2a:	4213      	tst	r3, r2
 1000b2c:	d00e      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000b2e:	4b16      	ldr	r3, [pc, #88]	; (1000b88 <GPIO_ResetBits+0xb0>)
 1000b30:	4a16      	ldr	r2, [pc, #88]	; (1000b8c <GPIO_ResetBits+0xb4>)
 1000b32:	18e3      	adds	r3, r4, r3
 1000b34:	4213      	tst	r3, r2
 1000b36:	d009      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000b38:	4b15      	ldr	r3, [pc, #84]	; (1000b90 <GPIO_ResetBits+0xb8>)
 1000b3a:	4a16      	ldr	r2, [pc, #88]	; (1000b94 <GPIO_ResetBits+0xbc>)
 1000b3c:	18e3      	adds	r3, r4, r3
 1000b3e:	4213      	tst	r3, r2
 1000b40:	d004      	beq.n	1000b4c <GPIO_ResetBits+0x74>
 1000b42:	4a0c      	ldr	r2, [pc, #48]	; (1000b74 <GPIO_ResetBits+0x9c>)
 1000b44:	2197      	movs	r1, #151	; 0x97
 1000b46:	480c      	ldr	r0, [pc, #48]	; (1000b78 <GPIO_ResetBits+0xa0>)
 1000b48:	f7ff fd58 	bl	10005fc <_assert_handler>

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (GPIO_Pin & 1 << i)
        {
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b4c:	4b12      	ldr	r3, [pc, #72]	; (1000b98 <GPIO_ResetBits+0xc0>)
        if (GPIO_Pin & 1 << i)
 1000b4e:	2101      	movs	r1, #1
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b50:	18ed      	adds	r5, r5, r3
            Temp |= 0x3F; //00111111
            Temp &= 0xFE; //11111110
 1000b52:	263e      	movs	r6, #62	; 0x3e
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b54:	2300      	movs	r3, #0
 1000b56:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 1000b58:	0022      	movs	r2, r4
 1000b5a:	411a      	asrs	r2, r3
 1000b5c:	420a      	tst	r2, r1
 1000b5e:	d004      	beq.n	1000b6a <GPIO_ResetBits+0x92>
 1000b60:	1958      	adds	r0, r3, r5
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b62:	7802      	ldrb	r2, [r0, #0]
 1000b64:	438a      	bics	r2, r1
            Temp &= 0xFE; //11111110
 1000b66:	4332      	orrs	r2, r6
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = Temp;
 1000b68:	7002      	strb	r2, [r0, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000b6a:	3301      	adds	r3, #1
 1000b6c:	2b10      	cmp	r3, #16
 1000b6e:	d1f3      	bne.n	1000b58 <GPIO_ResetBits+0x80>
        }
    }
}
 1000b70:	bd70      	pop	{r4, r5, r6, pc}
 1000b72:	46c0      	nop			; (mov r8, r8)
 1000b74:	01005495 	.word	0x01005495
 1000b78:	010053f5 	.word	0x010053f5
 1000b7c:	0000feff 	.word	0x0000feff
 1000b80:	fffffc00 	.word	0xfffffc00
 1000b84:	0000fbff 	.word	0x0000fbff
 1000b88:	fffff000 	.word	0xfffff000
 1000b8c:	0000efff 	.word	0x0000efff
 1000b90:	ffffc000 	.word	0xffffc000
 1000b94:	0000bfff 	.word	0x0000bfff
 1000b98:	0000f870 	.word	0x0000f870

01000b9c <GPIO_SetBits>:

void GPIO_SetBits(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000b9c:	b570      	push	{r4, r5, r6, lr}
 1000b9e:	0005      	movs	r5, r0
 1000ba0:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000ba2:	2802      	cmp	r0, #2
 1000ba4:	d904      	bls.n	1000bb0 <GPIO_SetBits+0x14>
 1000ba6:	4a23      	ldr	r2, [pc, #140]	; (1000c34 <GPIO_SetBits+0x98>)
 1000ba8:	21aa      	movs	r1, #170	; 0xaa
 1000baa:	4823      	ldr	r0, [pc, #140]	; (1000c38 <GPIO_SetBits+0x9c>)
 1000bac:	f7ff fd26 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000bb0:	1e63      	subs	r3, r4, #1
 1000bb2:	2b01      	cmp	r3, #1
 1000bb4:	d92c      	bls.n	1000c10 <GPIO_SetBits+0x74>
 1000bb6:	2204      	movs	r2, #4
 1000bb8:	1f23      	subs	r3, r4, #4
 1000bba:	4393      	bics	r3, r2
 1000bbc:	b29b      	uxth	r3, r3
 1000bbe:	2b00      	cmp	r3, #0
 1000bc0:	d026      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000bc2:	0023      	movs	r3, r4
 1000bc4:	320c      	adds	r2, #12
 1000bc6:	3b10      	subs	r3, #16
 1000bc8:	4393      	bics	r3, r2
 1000bca:	b29b      	uxth	r3, r3
 1000bcc:	2b00      	cmp	r3, #0
 1000bce:	d01f      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000bd0:	0023      	movs	r3, r4
 1000bd2:	3230      	adds	r2, #48	; 0x30
 1000bd4:	3b40      	subs	r3, #64	; 0x40
 1000bd6:	4393      	bics	r3, r2
 1000bd8:	b29b      	uxth	r3, r3
 1000bda:	2b00      	cmp	r3, #0
 1000bdc:	d018      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000bde:	1e63      	subs	r3, r4, #1
 1000be0:	4a16      	ldr	r2, [pc, #88]	; (1000c3c <GPIO_SetBits+0xa0>)
 1000be2:	3bff      	subs	r3, #255	; 0xff
 1000be4:	4213      	tst	r3, r2
 1000be6:	d013      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000be8:	4b15      	ldr	r3, [pc, #84]	; (1000c40 <GPIO_SetBits+0xa4>)
 1000bea:	4a16      	ldr	r2, [pc, #88]	; (1000c44 <GPIO_SetBits+0xa8>)
 1000bec:	18e3      	adds	r3, r4, r3
 1000bee:	4213      	tst	r3, r2
 1000bf0:	d00e      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000bf2:	4b15      	ldr	r3, [pc, #84]	; (1000c48 <GPIO_SetBits+0xac>)
 1000bf4:	4a15      	ldr	r2, [pc, #84]	; (1000c4c <GPIO_SetBits+0xb0>)
 1000bf6:	18e3      	adds	r3, r4, r3
 1000bf8:	4213      	tst	r3, r2
 1000bfa:	d009      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000bfc:	4b14      	ldr	r3, [pc, #80]	; (1000c50 <GPIO_SetBits+0xb4>)
 1000bfe:	4a15      	ldr	r2, [pc, #84]	; (1000c54 <GPIO_SetBits+0xb8>)
 1000c00:	18e3      	adds	r3, r4, r3
 1000c02:	4213      	tst	r3, r2
 1000c04:	d004      	beq.n	1000c10 <GPIO_SetBits+0x74>
 1000c06:	4a0b      	ldr	r2, [pc, #44]	; (1000c34 <GPIO_SetBits+0x98>)
 1000c08:	21ab      	movs	r1, #171	; 0xab
 1000c0a:	480b      	ldr	r0, [pc, #44]	; (1000c38 <GPIO_SetBits+0x9c>)
 1000c0c:	f7ff fcf6 	bl	10005fc <_assert_handler>
    int i;

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (GPIO_Pin & 1 << i)
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 0x3F; //00111111
 1000c10:	4b11      	ldr	r3, [pc, #68]	; (1000c58 <GPIO_SetBits+0xbc>)
        if (GPIO_Pin & 1 << i)
 1000c12:	2001      	movs	r0, #1
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 0x3F; //00111111
 1000c14:	18ed      	adds	r5, r5, r3
 1000c16:	263f      	movs	r6, #63	; 0x3f
 1000c18:	2300      	movs	r3, #0
 1000c1a:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 1000c1c:	0022      	movs	r2, r4
 1000c1e:	411a      	asrs	r2, r3
 1000c20:	4202      	tst	r2, r0
 1000c22:	d003      	beq.n	1000c2c <GPIO_SetBits+0x90>
 1000c24:	1959      	adds	r1, r3, r5
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 0x3F; //00111111
 1000c26:	780a      	ldrb	r2, [r1, #0]
 1000c28:	4332      	orrs	r2, r6
 1000c2a:	700a      	strb	r2, [r1, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000c2c:	3301      	adds	r3, #1
 1000c2e:	2b10      	cmp	r3, #16
 1000c30:	d1f4      	bne.n	1000c1c <GPIO_SetBits+0x80>
    }
}
 1000c32:	bd70      	pop	{r4, r5, r6, pc}
 1000c34:	010054a4 	.word	0x010054a4
 1000c38:	010053f5 	.word	0x010053f5
 1000c3c:	0000feff 	.word	0x0000feff
 1000c40:	fffffc00 	.word	0xfffffc00
 1000c44:	0000fbff 	.word	0x0000fbff
 1000c48:	fffff000 	.word	0xfffff000
 1000c4c:	0000efff 	.word	0x0000efff
 1000c50:	ffffc000 	.word	0xffffc000
 1000c54:	0000bfff 	.word	0x0000bfff
 1000c58:	0000f870 	.word	0x0000f870

01000c5c <GPIO_StructInit>:

void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
{
    GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 1000c5c:	2301      	movs	r3, #1
 1000c5e:	425b      	negs	r3, r3
 1000c60:	8003      	strh	r3, [r0, #0]
    GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 1000c62:	3302      	adds	r3, #2
 1000c64:	7083      	strb	r3, [r0, #2]
}
 1000c66:	4770      	bx	lr

01000c68 <GPIO_Write>:

void GPIO_Write(GPIO_TypeDef GPIOx, uint16_t value)
{
 1000c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1000c6a:	0005      	movs	r5, r0
 1000c6c:	000e      	movs	r6, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000c6e:	2802      	cmp	r0, #2
 1000c70:	d904      	bls.n	1000c7c <GPIO_Write+0x14>
 1000c72:	4a0c      	ldr	r2, [pc, #48]	; (1000ca4 <GPIO_Write+0x3c>)
 1000c74:	21be      	movs	r1, #190	; 0xbe
 1000c76:	480c      	ldr	r0, [pc, #48]	; (1000ca8 <GPIO_Write+0x40>)
 1000c78:	f7ff fcc0 	bl	10005fc <_assert_handler>
{
 1000c7c:	2400      	movs	r4, #0

    int i;

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (BIT_GET(value, i))
 1000c7e:	2701      	movs	r7, #1
 1000c80:	003b      	movs	r3, r7
 1000c82:	40a3      	lsls	r3, r4
 1000c84:	b299      	uxth	r1, r3
 1000c86:	4033      	ands	r3, r6
 1000c88:	4123      	asrs	r3, r4
            GPIO_SetBits(GPIOx, 1 << i);
 1000c8a:	0028      	movs	r0, r5
        if (BIT_GET(value, i))
 1000c8c:	2b00      	cmp	r3, #0
 1000c8e:	d005      	beq.n	1000c9c <GPIO_Write+0x34>
            GPIO_SetBits(GPIOx, 1 << i);
 1000c90:	f7ff ff84 	bl	1000b9c <GPIO_SetBits>
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000c94:	3401      	adds	r4, #1
 1000c96:	2c10      	cmp	r4, #16
 1000c98:	d1f2      	bne.n	1000c80 <GPIO_Write+0x18>
        else
            GPIO_ResetBits(GPIOx, 1 << i);
    }
}
 1000c9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            GPIO_ResetBits(GPIOx, 1 << i);
 1000c9c:	f7ff ff1c 	bl	1000ad8 <GPIO_ResetBits>
 1000ca0:	e7f8      	b.n	1000c94 <GPIO_Write+0x2c>
 1000ca2:	46c0      	nop			; (mov r8, r8)
 1000ca4:	010054b1 	.word	0x010054b1
 1000ca8:	010053f5 	.word	0x010053f5

01000cac <GPIO_WriteBit>:

void GPIO_WriteBit(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 1000cac:	b570      	push	{r4, r5, r6, lr}
 1000cae:	0005      	movs	r5, r0
 1000cb0:	000c      	movs	r4, r1
 1000cb2:	0016      	movs	r6, r2
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000cb4:	2802      	cmp	r0, #2
 1000cb6:	d904      	bls.n	1000cc2 <GPIO_WriteBit+0x16>
 1000cb8:	4a21      	ldr	r2, [pc, #132]	; (1000d40 <GPIO_WriteBit+0x94>)
 1000cba:	21cd      	movs	r1, #205	; 0xcd
 1000cbc:	4821      	ldr	r0, [pc, #132]	; (1000d44 <GPIO_WriteBit+0x98>)
 1000cbe:	f7ff fc9d 	bl	10005fc <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000cc2:	1e63      	subs	r3, r4, #1
 1000cc4:	2b01      	cmp	r3, #1
 1000cc6:	d92c      	bls.n	1000d22 <GPIO_WriteBit+0x76>
 1000cc8:	2204      	movs	r2, #4
 1000cca:	1f23      	subs	r3, r4, #4
 1000ccc:	4393      	bics	r3, r2
 1000cce:	b29b      	uxth	r3, r3
 1000cd0:	2b00      	cmp	r3, #0
 1000cd2:	d026      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000cd4:	0023      	movs	r3, r4
 1000cd6:	320c      	adds	r2, #12
 1000cd8:	3b10      	subs	r3, #16
 1000cda:	4393      	bics	r3, r2
 1000cdc:	b29b      	uxth	r3, r3
 1000cde:	2b00      	cmp	r3, #0
 1000ce0:	d01f      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000ce2:	0023      	movs	r3, r4
 1000ce4:	3230      	adds	r2, #48	; 0x30
 1000ce6:	3b40      	subs	r3, #64	; 0x40
 1000ce8:	4393      	bics	r3, r2
 1000cea:	b29b      	uxth	r3, r3
 1000cec:	2b00      	cmp	r3, #0
 1000cee:	d018      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000cf0:	1e63      	subs	r3, r4, #1
 1000cf2:	4a15      	ldr	r2, [pc, #84]	; (1000d48 <GPIO_WriteBit+0x9c>)
 1000cf4:	3bff      	subs	r3, #255	; 0xff
 1000cf6:	4213      	tst	r3, r2
 1000cf8:	d013      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000cfa:	4b14      	ldr	r3, [pc, #80]	; (1000d4c <GPIO_WriteBit+0xa0>)
 1000cfc:	4a14      	ldr	r2, [pc, #80]	; (1000d50 <GPIO_WriteBit+0xa4>)
 1000cfe:	18e3      	adds	r3, r4, r3
 1000d00:	4213      	tst	r3, r2
 1000d02:	d00e      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000d04:	4b13      	ldr	r3, [pc, #76]	; (1000d54 <GPIO_WriteBit+0xa8>)
 1000d06:	4a14      	ldr	r2, [pc, #80]	; (1000d58 <GPIO_WriteBit+0xac>)
 1000d08:	18e3      	adds	r3, r4, r3
 1000d0a:	4213      	tst	r3, r2
 1000d0c:	d009      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000d0e:	4b13      	ldr	r3, [pc, #76]	; (1000d5c <GPIO_WriteBit+0xb0>)
 1000d10:	4a13      	ldr	r2, [pc, #76]	; (1000d60 <GPIO_WriteBit+0xb4>)
 1000d12:	18e3      	adds	r3, r4, r3
 1000d14:	4213      	tst	r3, r2
 1000d16:	d004      	beq.n	1000d22 <GPIO_WriteBit+0x76>
 1000d18:	4a09      	ldr	r2, [pc, #36]	; (1000d40 <GPIO_WriteBit+0x94>)
 1000d1a:	21ce      	movs	r1, #206	; 0xce
 1000d1c:	4809      	ldr	r0, [pc, #36]	; (1000d44 <GPIO_WriteBit+0x98>)
 1000d1e:	f7ff fc6d 	bl	10005fc <_assert_handler>

    if (BitVal == Bit_SET)
 1000d22:	2e01      	cmp	r6, #1
 1000d24:	d104      	bne.n	1000d30 <GPIO_WriteBit+0x84>
        GPIO_SetBits(GPIOx, GPIO_Pin);
 1000d26:	0021      	movs	r1, r4
 1000d28:	0028      	movs	r0, r5
 1000d2a:	f7ff ff37 	bl	1000b9c <GPIO_SetBits>
    else if (BitVal == Bit_RESET)
        GPIO_ResetBits(GPIOx, GPIO_Pin);
}
 1000d2e:	bd70      	pop	{r4, r5, r6, pc}
    else if (BitVal == Bit_RESET)
 1000d30:	2e00      	cmp	r6, #0
 1000d32:	d1fc      	bne.n	1000d2e <GPIO_WriteBit+0x82>
        GPIO_ResetBits(GPIOx, GPIO_Pin);
 1000d34:	0021      	movs	r1, r4
 1000d36:	0028      	movs	r0, r5
 1000d38:	f7ff fece 	bl	1000ad8 <GPIO_ResetBits>
}
 1000d3c:	e7f7      	b.n	1000d2e <GPIO_WriteBit+0x82>
 1000d3e:	46c0      	nop			; (mov r8, r8)
 1000d40:	010054bc 	.word	0x010054bc
 1000d44:	010053f5 	.word	0x010053f5
 1000d48:	0000feff 	.word	0x0000feff
 1000d4c:	fffffc00 	.word	0xfffffc00
 1000d50:	0000fbff 	.word	0x0000fbff
 1000d54:	fffff000 	.word	0xfffff000
 1000d58:	0000efff 	.word	0x0000efff
 1000d5c:	ffffc000 	.word	0xffffc000
 1000d60:	0000bfff 	.word	0x0000bfff

01000d64 <delay_us>:
#include "yc_timer.h"
#include "rom_api.h"

void delay_us(int us)
{
 1000d64:	b510      	push	{r4, lr}
    ((void(*)(int))(FUNC_DELAY_US_ADDR))(us);
 1000d66:	4b01      	ldr	r3, [pc, #4]	; (1000d6c <delay_us+0x8>)
 1000d68:	4798      	blx	r3
}
 1000d6a:	bd10      	pop	{r4, pc}
 1000d6c:	00004239 	.word	0x00004239

01000d70 <delay_ms>:

void delay_ms(int ms)
{
 1000d70:	b510      	push	{r4, lr}
    ((void(*)(int))(FUNC_DELAY_MS_ADDR))(ms);
 1000d72:	4b01      	ldr	r3, [pc, #4]	; (1000d78 <delay_ms+0x8>)
 1000d74:	4798      	blx	r3
}
 1000d76:	bd10      	pop	{r4, pc}
 1000d78:	0000425d 	.word	0x0000425d

01000d7c <TIM_Init>:

void TIM_Init(TIM_InitTypeDef *TIM_init_struct)
{
    _ASSERT(ISTIMERNUM(TIM_init_struct->TIMx));
 1000d7c:	7803      	ldrb	r3, [r0, #0]
{
 1000d7e:	b510      	push	{r4, lr}
 1000d80:	0004      	movs	r4, r0
    _ASSERT(ISTIMERNUM(TIM_init_struct->TIMx));
 1000d82:	2b08      	cmp	r3, #8
 1000d84:	d904      	bls.n	1000d90 <TIM_Init+0x14>
 1000d86:	4a0f      	ldr	r2, [pc, #60]	; (1000dc4 <TIM_Init+0x48>)
 1000d88:	2110      	movs	r1, #16
 1000d8a:	480f      	ldr	r0, [pc, #60]	; (1000dc8 <TIM_Init+0x4c>)
 1000d8c:	f7ff fc36 	bl	10005fc <_assert_handler>

    TIM_Cmd(TIM_init_struct->TIMx, DISABLE);
 1000d90:	2100      	movs	r1, #0
 1000d92:	7820      	ldrb	r0, [r4, #0]
 1000d94:	f000 f828 	bl	1000de8 <TIM_Cmd>
    TIM_PCNT(TIM_init_struct->TIMx) = TIM_init_struct->period;
 1000d98:	7822      	ldrb	r2, [r4, #0]
 1000d9a:	4b0c      	ldr	r3, [pc, #48]	; (1000dcc <TIM_Init+0x50>)
 1000d9c:	6861      	ldr	r1, [r4, #4]
 1000d9e:	18d3      	adds	r3, r2, r3
 1000da0:	00db      	lsls	r3, r3, #3
 1000da2:	6019      	str	r1, [r3, #0]
 1000da4:	230c      	movs	r3, #12
    if (TIM_init_struct->TIMx < TIM8)
 1000da6:	2a07      	cmp	r2, #7
 1000da8:	d806      	bhi.n	1000db8 <TIM_Init+0x3c>
        TIM_CTRL |= (((((uint32_t)1) << TIM_CTRL_MODE) | (((uint32_t)1) << TIM_CTRL_AUTO_RELOAD)) << TIM_init_struct->TIMx * 4);
 1000daa:	0092      	lsls	r2, r2, #2
 1000dac:	4093      	lsls	r3, r2
 1000dae:	4908      	ldr	r1, [pc, #32]	; (1000dd0 <TIM_Init+0x54>)
 1000db0:	6808      	ldr	r0, [r1, #0]
 1000db2:	4303      	orrs	r3, r0
 1000db4:	600b      	str	r3, [r1, #0]
    else
        TIM_CTRL1 |= (((((uint32_t)1) << TIM_CTRL_MODE) | (((uint32_t)1) << TIM_CTRL_AUTO_RELOAD)) << 0);
}
 1000db6:	bd10      	pop	{r4, pc}
        TIM_CTRL1 |= (((((uint32_t)1) << TIM_CTRL_MODE) | (((uint32_t)1) << TIM_CTRL_AUTO_RELOAD)) << 0);
 1000db8:	4a06      	ldr	r2, [pc, #24]	; (1000dd4 <TIM_Init+0x58>)
 1000dba:	6811      	ldr	r1, [r2, #0]
 1000dbc:	430b      	orrs	r3, r1
 1000dbe:	6013      	str	r3, [r2, #0]
}
 1000dc0:	e7f9      	b.n	1000db6 <TIM_Init+0x3a>
 1000dc2:	46c0      	nop			; (mov r8, r8)
 1000dc4:	010054f2 	.word	0x010054f2
 1000dc8:	010054ca 	.word	0x010054ca
 1000dcc:	0001e180 	.word	0x0001e180
 1000dd0:	000f0c48 	.word	0x000f0c48
 1000dd4:	000f0c4c 	.word	0x000f0c4c

01000dd8 <TIM_DeInit>:
    SYSCTRL_CLK_CLS |= 1 << id;
 1000dd8:	2310      	movs	r3, #16
 1000dda:	4a02      	ldr	r2, [pc, #8]	; (1000de4 <TIM_DeInit+0xc>)
 1000ddc:	6811      	ldr	r1, [r2, #0]
 1000dde:	430b      	orrs	r3, r1
 1000de0:	6013      	str	r3, [r2, #0]

void TIM_DeInit()
{
    disable_clock(CLKCLS_TIM);
}
 1000de2:	4770      	bx	lr
 1000de4:	000f856c 	.word	0x000f856c

01000de8 <TIM_Cmd>:

void TIM_Cmd(TIM_NumTypeDef TIMx, FunctionalState NewState)
{
 1000de8:	b570      	push	{r4, r5, r6, lr}
 1000dea:	0004      	movs	r4, r0
 1000dec:	000d      	movs	r5, r1
    _ASSERT(ISTIMERNUM(TIMx));
 1000dee:	2808      	cmp	r0, #8
 1000df0:	d904      	bls.n	1000dfc <TIM_Cmd+0x14>
 1000df2:	4a10      	ldr	r2, [pc, #64]	; (1000e34 <TIM_Cmd+0x4c>)
 1000df4:	2121      	movs	r1, #33	; 0x21
 1000df6:	4810      	ldr	r0, [pc, #64]	; (1000e38 <TIM_Cmd+0x50>)
 1000df8:	f7ff fc00 	bl	10005fc <_assert_handler>

    if (NewState == ENABLE)
 1000dfc:	2d01      	cmp	r5, #1
 1000dfe:	d10b      	bne.n	1000e18 <TIM_Cmd+0x30>
    {
        if (TIMx < TIM8)
 1000e00:	2c07      	cmp	r4, #7
 1000e02:	d806      	bhi.n	1000e12 <TIM_Cmd+0x2a>
            TIM_CTRL |= ((((uint32_t)1) << TIM_CTRL_ENABLE) << TIMx * 4);
 1000e04:	00a4      	lsls	r4, r4, #2
 1000e06:	40a5      	lsls	r5, r4
 1000e08:	4b0c      	ldr	r3, [pc, #48]	; (1000e3c <TIM_Cmd+0x54>)
 1000e0a:	681a      	ldr	r2, [r3, #0]
        else
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 1000e0c:	4315      	orrs	r5, r2
 1000e0e:	601d      	str	r5, [r3, #0]
        if (TIMx < TIM8)
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << TIMx * 4);
        else
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
    }
}
 1000e10:	bd70      	pop	{r4, r5, r6, pc}
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 1000e12:	4b0b      	ldr	r3, [pc, #44]	; (1000e40 <TIM_Cmd+0x58>)
 1000e14:	681a      	ldr	r2, [r3, #0]
 1000e16:	e7f9      	b.n	1000e0c <TIM_Cmd+0x24>
 1000e18:	2301      	movs	r3, #1
        if (TIMx < TIM8)
 1000e1a:	2c07      	cmp	r4, #7
 1000e1c:	d806      	bhi.n	1000e2c <TIM_Cmd+0x44>
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << TIMx * 4);
 1000e1e:	00a4      	lsls	r4, r4, #2
 1000e20:	40a3      	lsls	r3, r4
 1000e22:	4906      	ldr	r1, [pc, #24]	; (1000e3c <TIM_Cmd+0x54>)
 1000e24:	680a      	ldr	r2, [r1, #0]
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 1000e26:	439a      	bics	r2, r3
 1000e28:	600a      	str	r2, [r1, #0]
}
 1000e2a:	e7f1      	b.n	1000e10 <TIM_Cmd+0x28>
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 1000e2c:	4904      	ldr	r1, [pc, #16]	; (1000e40 <TIM_Cmd+0x58>)
 1000e2e:	680a      	ldr	r2, [r1, #0]
 1000e30:	e7f9      	b.n	1000e26 <TIM_Cmd+0x3e>
 1000e32:	46c0      	nop			; (mov r8, r8)
 1000e34:	010054fb 	.word	0x010054fb
 1000e38:	010054ca 	.word	0x010054ca
 1000e3c:	000f0c48 	.word	0x000f0c48
 1000e40:	000f0c4c 	.word	0x000f0c4c

01000e44 <TIM_ModeConfig>:

void TIM_ModeConfig(TIM_NumTypeDef TIMx, TIM_ModeTypeDef TIM_Mode)
{
 1000e44:	b570      	push	{r4, r5, r6, lr}
 1000e46:	0004      	movs	r4, r0
 1000e48:	000d      	movs	r5, r1
    _ASSERT(ISTIMERNUM(TIMx));
 1000e4a:	2808      	cmp	r0, #8
 1000e4c:	d904      	bls.n	1000e58 <TIM_ModeConfig+0x14>
 1000e4e:	4a14      	ldr	r2, [pc, #80]	; (1000ea0 <TIM_ModeConfig+0x5c>)
 1000e50:	2135      	movs	r1, #53	; 0x35
 1000e52:	4814      	ldr	r0, [pc, #80]	; (1000ea4 <TIM_ModeConfig+0x60>)
 1000e54:	f7ff fbd2 	bl	10005fc <_assert_handler>
    _ASSERT(IS_TIM_MODE(TIM_Mode));
 1000e58:	2d01      	cmp	r5, #1
 1000e5a:	d90e      	bls.n	1000e7a <TIM_ModeConfig+0x36>
 1000e5c:	4a10      	ldr	r2, [pc, #64]	; (1000ea0 <TIM_ModeConfig+0x5c>)
 1000e5e:	2136      	movs	r1, #54	; 0x36
 1000e60:	4810      	ldr	r0, [pc, #64]	; (1000ea4 <TIM_ModeConfig+0x60>)
 1000e62:	f7ff fbcb 	bl	10005fc <_assert_handler>
 1000e66:	2304      	movs	r3, #4
        else
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_MODE) << 0);
    }
    else
    {
        if (TIMx < TIM8)
 1000e68:	2c07      	cmp	r4, #7
 1000e6a:	d815      	bhi.n	1000e98 <TIM_ModeConfig+0x54>
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_MODE) << TIMx * 4);
 1000e6c:	00a4      	lsls	r4, r4, #2
 1000e6e:	40a3      	lsls	r3, r4
 1000e70:	490d      	ldr	r1, [pc, #52]	; (1000ea8 <TIM_ModeConfig+0x64>)
 1000e72:	680a      	ldr	r2, [r1, #0]
        else
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1000e74:	439a      	bics	r2, r3
 1000e76:	600a      	str	r2, [r1, #0]
    }
}
 1000e78:	e00a      	b.n	1000e90 <TIM_ModeConfig+0x4c>
    if (TIM_Mode == TIM_Mode_TIMER)
 1000e7a:	2d01      	cmp	r5, #1
 1000e7c:	d1f3      	bne.n	1000e66 <TIM_ModeConfig+0x22>
 1000e7e:	2304      	movs	r3, #4
        if (TIMx < TIM8)
 1000e80:	2c07      	cmp	r4, #7
 1000e82:	d806      	bhi.n	1000e92 <TIM_ModeConfig+0x4e>
            TIM_CTRL |= ((((uint32_t)1) << TIM_CTRL_MODE) << TIMx * 4);
 1000e84:	00a4      	lsls	r4, r4, #2
 1000e86:	40a3      	lsls	r3, r4
 1000e88:	4a07      	ldr	r2, [pc, #28]	; (1000ea8 <TIM_ModeConfig+0x64>)
 1000e8a:	6811      	ldr	r1, [r2, #0]
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1000e8c:	430b      	orrs	r3, r1
 1000e8e:	6013      	str	r3, [r2, #0]
}
 1000e90:	bd70      	pop	{r4, r5, r6, pc}
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1000e92:	4a06      	ldr	r2, [pc, #24]	; (1000eac <TIM_ModeConfig+0x68>)
 1000e94:	6811      	ldr	r1, [r2, #0]
 1000e96:	e7f9      	b.n	1000e8c <TIM_ModeConfig+0x48>
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1000e98:	4904      	ldr	r1, [pc, #16]	; (1000eac <TIM_ModeConfig+0x68>)
 1000e9a:	680a      	ldr	r2, [r1, #0]
 1000e9c:	e7ea      	b.n	1000e74 <TIM_ModeConfig+0x30>
 1000e9e:	46c0      	nop			; (mov r8, r8)
 1000ea0:	01005503 	.word	0x01005503
 1000ea4:	010054ca 	.word	0x010054ca
 1000ea8:	000f0c48 	.word	0x000f0c48
 1000eac:	000f0c4c 	.word	0x000f0c4c

01000eb0 <TIM_SetPeriod>:

void TIM_SetPeriod(TIM_NumTypeDef TIMx, uint32_t Period)
{
 1000eb0:	b570      	push	{r4, r5, r6, lr}
 1000eb2:	0004      	movs	r4, r0
 1000eb4:	000d      	movs	r5, r1
    _ASSERT(ISTIMERNUM(TIMx));
 1000eb6:	2808      	cmp	r0, #8
 1000eb8:	d904      	bls.n	1000ec4 <TIM_SetPeriod+0x14>
 1000eba:	4a05      	ldr	r2, [pc, #20]	; (1000ed0 <TIM_SetPeriod+0x20>)
 1000ebc:	214a      	movs	r1, #74	; 0x4a
 1000ebe:	4805      	ldr	r0, [pc, #20]	; (1000ed4 <TIM_SetPeriod+0x24>)
 1000ec0:	f7ff fb9c 	bl	10005fc <_assert_handler>

    TIM_PCNT(TIMx) = Period;
 1000ec4:	4b04      	ldr	r3, [pc, #16]	; (1000ed8 <TIM_SetPeriod+0x28>)
 1000ec6:	18e4      	adds	r4, r4, r3
 1000ec8:	00e4      	lsls	r4, r4, #3
 1000eca:	6025      	str	r5, [r4, #0]
}
 1000ecc:	bd70      	pop	{r4, r5, r6, pc}
 1000ece:	46c0      	nop			; (mov r8, r8)
 1000ed0:	01005512 	.word	0x01005512
 1000ed4:	010054ca 	.word	0x010054ca
 1000ed8:	0001e180 	.word	0x0001e180

01000edc <TIM_PWMInit>:

void TIM_PWMInit(PWM_InitTypeDef *PWM_init_struct)
{
    _ASSERT(ISTIMERNUM(PWM_init_struct->TIMx));
 1000edc:	7803      	ldrb	r3, [r0, #0]
{
 1000ede:	b510      	push	{r4, lr}
 1000ee0:	0004      	movs	r4, r0
    _ASSERT(ISTIMERNUM(PWM_init_struct->TIMx));
 1000ee2:	2b08      	cmp	r3, #8
 1000ee4:	d904      	bls.n	1000ef0 <TIM_PWMInit+0x14>
 1000ee6:	4a1e      	ldr	r2, [pc, #120]	; (1000f60 <TIM_PWMInit+0x84>)
 1000ee8:	2151      	movs	r1, #81	; 0x51
 1000eea:	481e      	ldr	r0, [pc, #120]	; (1000f64 <TIM_PWMInit+0x88>)
 1000eec:	f7ff fb86 	bl	10005fc <_assert_handler>

    TIM_Cmd(PWM_init_struct->TIMx, DISABLE);
 1000ef0:	2100      	movs	r1, #0
 1000ef2:	7820      	ldrb	r0, [r4, #0]
 1000ef4:	f7ff ff78 	bl	1000de8 <TIM_Cmd>
    TIM_PCNT(PWM_init_struct->TIMx) = PWM_init_struct->HighLevelPeriod;
 1000ef8:	7821      	ldrb	r1, [r4, #0]
 1000efa:	4b1b      	ldr	r3, [pc, #108]	; (1000f68 <TIM_PWMInit+0x8c>)
 1000efc:	18ca      	adds	r2, r1, r3
 1000efe:	68a3      	ldr	r3, [r4, #8]
 1000f00:	00d2      	lsls	r2, r2, #3
 1000f02:	6013      	str	r3, [r2, #0]
    TIM_NCNT(PWM_init_struct->TIMx) = PWM_init_struct->LowLevelPeriod;
 1000f04:	6863      	ldr	r3, [r4, #4]
 1000f06:	6053      	str	r3, [r2, #4]
    if (PWM_init_struct->SatrtLevel == OutputHigh)
 1000f08:	7b22      	ldrb	r2, [r4, #12]
 1000f0a:	2302      	movs	r3, #2
 1000f0c:	2a01      	cmp	r2, #1
 1000f0e:	d119      	bne.n	1000f44 <TIM_PWMInit+0x68>
    {
        if (PWM_init_struct->TIMx < TIM8)
 1000f10:	2907      	cmp	r1, #7
 1000f12:	d80d      	bhi.n	1000f30 <TIM_PWMInit+0x54>
            TIM_CTRL |= ((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
 1000f14:	008c      	lsls	r4, r1, #2
 1000f16:	40a3      	lsls	r3, r4
 1000f18:	4814      	ldr	r0, [pc, #80]	; (1000f6c <TIM_PWMInit+0x90>)
 1000f1a:	6802      	ldr	r2, [r0, #0]
 1000f1c:	431a      	orrs	r2, r3
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
        else
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << 0);
    }
    if (PWM_init_struct->TIMx < TIM8)
        TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_MODE) << PWM_init_struct->TIMx * 4);
 1000f1e:	008b      	lsls	r3, r1, #2
 1000f20:	2104      	movs	r1, #4
 1000f22:	4099      	lsls	r1, r3
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
 1000f24:	6002      	str	r2, [r0, #0]
        TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_MODE) << PWM_init_struct->TIMx * 4);
 1000f26:	4811      	ldr	r0, [pc, #68]	; (1000f6c <TIM_PWMInit+0x90>)
 1000f28:	6802      	ldr	r2, [r0, #0]
 1000f2a:	438a      	bics	r2, r1
 1000f2c:	6002      	str	r2, [r0, #0]
    else
        TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
}
 1000f2e:	bd10      	pop	{r4, pc}
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_START_LEVEL) << 0);
 1000f30:	490f      	ldr	r1, [pc, #60]	; (1000f70 <TIM_PWMInit+0x94>)
 1000f32:	680a      	ldr	r2, [r1, #0]
 1000f34:	4313      	orrs	r3, r2
 1000f36:	600b      	str	r3, [r1, #0]
        TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1000f38:	2104      	movs	r1, #4
 1000f3a:	4a0d      	ldr	r2, [pc, #52]	; (1000f70 <TIM_PWMInit+0x94>)
 1000f3c:	6813      	ldr	r3, [r2, #0]
 1000f3e:	438b      	bics	r3, r1
 1000f40:	6013      	str	r3, [r2, #0]
 1000f42:	e7f4      	b.n	1000f2e <TIM_PWMInit+0x52>
        if (PWM_init_struct->TIMx < TIM8)
 1000f44:	2907      	cmp	r1, #7
 1000f46:	d805      	bhi.n	1000f54 <TIM_PWMInit+0x78>
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
 1000f48:	008c      	lsls	r4, r1, #2
 1000f4a:	40a3      	lsls	r3, r4
 1000f4c:	4807      	ldr	r0, [pc, #28]	; (1000f6c <TIM_PWMInit+0x90>)
 1000f4e:	6802      	ldr	r2, [r0, #0]
 1000f50:	439a      	bics	r2, r3
 1000f52:	e7e4      	b.n	1000f1e <TIM_PWMInit+0x42>
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << 0);
 1000f54:	4906      	ldr	r1, [pc, #24]	; (1000f70 <TIM_PWMInit+0x94>)
 1000f56:	680a      	ldr	r2, [r1, #0]
 1000f58:	439a      	bics	r2, r3
 1000f5a:	600a      	str	r2, [r1, #0]
 1000f5c:	e7ec      	b.n	1000f38 <TIM_PWMInit+0x5c>
 1000f5e:	46c0      	nop			; (mov r8, r8)
 1000f60:	01005520 	.word	0x01005520
 1000f64:	010054ca 	.word	0x010054ca
 1000f68:	0001e180 	.word	0x0001e180
 1000f6c:	000f0c48 	.word	0x000f0c48
 1000f70:	000f0c4c 	.word	0x000f0c4c

01000f74 <TIM_SetPWMPeriod>:

void TIM_SetPWMPeriod(TIM_NumTypeDef TIMx, uint32_t LowLevelPeriod, uint32_t HighLevelPeriod)
{
 1000f74:	b570      	push	{r4, r5, r6, lr}
 1000f76:	0004      	movs	r4, r0
 1000f78:	000d      	movs	r5, r1
 1000f7a:	0016      	movs	r6, r2
    _ASSERT(ISTIMERNUM(TIMx));
 1000f7c:	2808      	cmp	r0, #8
 1000f7e:	d904      	bls.n	1000f8a <TIM_SetPWMPeriod+0x16>
 1000f80:	4a05      	ldr	r2, [pc, #20]	; (1000f98 <TIM_SetPWMPeriod+0x24>)
 1000f82:	216c      	movs	r1, #108	; 0x6c
 1000f84:	4805      	ldr	r0, [pc, #20]	; (1000f9c <TIM_SetPWMPeriod+0x28>)
 1000f86:	f7ff fb39 	bl	10005fc <_assert_handler>

    TIM_PCNT(TIMx) = HighLevelPeriod;
 1000f8a:	4b05      	ldr	r3, [pc, #20]	; (1000fa0 <TIM_SetPWMPeriod+0x2c>)
 1000f8c:	18e4      	adds	r4, r4, r3
 1000f8e:	00e4      	lsls	r4, r4, #3
 1000f90:	6026      	str	r6, [r4, #0]
    TIM_NCNT(TIMx) = LowLevelPeriod;
 1000f92:	6065      	str	r5, [r4, #4]
}
 1000f94:	bd70      	pop	{r4, r5, r6, pc}
 1000f96:	46c0      	nop			; (mov r8, r8)
 1000f98:	0100552c 	.word	0x0100552c
 1000f9c:	010054ca 	.word	0x010054ca
 1000fa0:	0001e180 	.word	0x0001e180

01000fa4 <TIM_PWMDifferential>:

void TIM_PWMDifferential(TIM_NumTypeDef TIMx, TIM_NumTypeDef TIMy, uint32_t LowLevelPeriod, uint32_t HighLevelPeriod)
{
 1000fa4:	b5f0      	push	{r4, r5, r6, r7, lr}
 1000fa6:	b085      	sub	sp, #20
 1000fa8:	0006      	movs	r6, r0
 1000faa:	000d      	movs	r5, r1
 1000fac:	0017      	movs	r7, r2
 1000fae:	9301      	str	r3, [sp, #4]
    _ASSERT(ISTIMERNUM(TIMx));
 1000fb0:	2808      	cmp	r0, #8
 1000fb2:	d904      	bls.n	1000fbe <TIM_PWMDifferential+0x1a>
 1000fb4:	4a20      	ldr	r2, [pc, #128]	; (1001038 <TIM_PWMDifferential+0x94>)
 1000fb6:	2174      	movs	r1, #116	; 0x74
 1000fb8:	4820      	ldr	r0, [pc, #128]	; (100103c <TIM_PWMDifferential+0x98>)
 1000fba:	f7ff fb1f 	bl	10005fc <_assert_handler>
    _ASSERT(ISTIMERNUM(TIMy));
 1000fbe:	2d08      	cmp	r5, #8
 1000fc0:	d904      	bls.n	1000fcc <TIM_PWMDifferential+0x28>
 1000fc2:	4a1d      	ldr	r2, [pc, #116]	; (1001038 <TIM_PWMDifferential+0x94>)
 1000fc4:	2175      	movs	r1, #117	; 0x75
 1000fc6:	481d      	ldr	r0, [pc, #116]	; (100103c <TIM_PWMDifferential+0x98>)
 1000fc8:	f7ff fb18 	bl	10005fc <_assert_handler>

    uint32_t TDifferentialConfig;

    TIM_CTRL &= ~((1 << (TIMy * 4)) | (1 << (TIMx * 4)));
 1000fcc:	4c1c      	ldr	r4, [pc, #112]	; (1001040 <TIM_PWMDifferential+0x9c>)
 1000fce:	00b1      	lsls	r1, r6, #2
 1000fd0:	6823      	ldr	r3, [r4, #0]
 1000fd2:	00aa      	lsls	r2, r5, #2
 1000fd4:	9302      	str	r3, [sp, #8]
 1000fd6:	00b3      	lsls	r3, r6, #2
 1000fd8:	9303      	str	r3, [sp, #12]
 1000fda:	2301      	movs	r3, #1
 1000fdc:	0018      	movs	r0, r3
 1000fde:	4088      	lsls	r0, r1
 1000fe0:	4684      	mov	ip, r0
 1000fe2:	0018      	movs	r0, r3
 1000fe4:	4661      	mov	r1, ip
 1000fe6:	4090      	lsls	r0, r2
 1000fe8:	4308      	orrs	r0, r1
 1000fea:	9902      	ldr	r1, [sp, #8]
 1000fec:	4381      	bics	r1, r0
 1000fee:	6021      	str	r1, [r4, #0]
    TIM_PCNT(TIMx) = HighLevelPeriod;
 1000ff0:	4914      	ldr	r1, [pc, #80]	; (1001044 <TIM_PWMDifferential+0xa0>)
 1000ff2:	9801      	ldr	r0, [sp, #4]
 1000ff4:	1876      	adds	r6, r6, r1
    TIM_NCNT(TIMx) = LowLevelPeriod;
    TIM_PCNT(TIMy) = LowLevelPeriod;
 1000ff6:	186d      	adds	r5, r5, r1
    TIM_PCNT(TIMx) = HighLevelPeriod;
 1000ff8:	00f6      	lsls	r6, r6, #3
    TIM_PCNT(TIMy) = LowLevelPeriod;
 1000ffa:	00ed      	lsls	r5, r5, #3
    TIM_PCNT(TIMx) = HighLevelPeriod;
 1000ffc:	6030      	str	r0, [r6, #0]
    TIM_NCNT(TIMx) = LowLevelPeriod;
 1000ffe:	6077      	str	r7, [r6, #4]
    TIM_PCNT(TIMy) = LowLevelPeriod;
 1001000:	602f      	str	r7, [r5, #0]
    TIM_NCNT(TIMy) = HighLevelPeriod;
 1001002:	6068      	str	r0, [r5, #4]
    TIM_CTRL &= ~(1 << (TIMx * 4 + 1));
 1001004:	001d      	movs	r5, r3
 1001006:	9903      	ldr	r1, [sp, #12]
 1001008:	6820      	ldr	r0, [r4, #0]
 100100a:	18c9      	adds	r1, r1, r3
 100100c:	408d      	lsls	r5, r1
 100100e:	43a8      	bics	r0, r5
    TDifferentialConfig = TIM_CTRL;
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 1001010:	2503      	movs	r5, #3
    TIM_CTRL &= ~(1 << (TIMx * 4 + 1));
 1001012:	6020      	str	r0, [r4, #0]
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 1001014:	4095      	lsls	r5, r2
 1001016:	4660      	mov	r0, ip
    TIM_CTRL |= 1 << (TIMy * 4 + 1);
 1001018:	18d2      	adds	r2, r2, r3
 100101a:	4093      	lsls	r3, r2
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 100101c:	4305      	orrs	r5, r0
    delay((LowLevelPeriod - 8) / 4);
 100101e:	0038      	movs	r0, r7
    TDifferentialConfig = TIM_CTRL;
 1001020:	6821      	ldr	r1, [r4, #0]
    delay((LowLevelPeriod - 8) / 4);
 1001022:	3808      	subs	r0, #8
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 1001024:	430d      	orrs	r5, r1
    TIM_CTRL |= 1 << (TIMy * 4 + 1);
 1001026:	6821      	ldr	r1, [r4, #0]
    delay((LowLevelPeriod - 8) / 4);
 1001028:	0880      	lsrs	r0, r0, #2
    TIM_CTRL |= 1 << (TIMy * 4 + 1);
 100102a:	430b      	orrs	r3, r1
 100102c:	6023      	str	r3, [r4, #0]
    delay((LowLevelPeriod - 8) / 4);
 100102e:	f7ff f98a 	bl	1000346 <delay>
    TIM_CTRL = TDifferentialConfig;
 1001032:	6025      	str	r5, [r4, #0]
}
 1001034:	b005      	add	sp, #20
 1001036:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1001038:	0100553d 	.word	0x0100553d
 100103c:	010054ca 	.word	0x010054ca
 1001040:	000f0c48 	.word	0x000f0c48
 1001044:	0001e180 	.word	0x0001e180

01001048 <IPC_have_data>:

uint8_t ipcrecbuf[IPCREVSIZE] = {0};
uint8_t bt_lpm_mode=0;

Boolean IPC_have_data()
{
 1001048:	b510      	push	{r4, lr}
    return HR_REG_16BIT(&IpcRx->ReadPtr) != HR_REG_16BIT(&IpcRx->WrtiePtr) ? TRUE : FALSE;
 100104a:	4b08      	ldr	r3, [pc, #32]	; (100106c <IPC_have_data+0x24>)
 100104c:	681a      	ldr	r2, [r3, #0]
 100104e:	7914      	ldrb	r4, [r2, #4]
 1001050:	7950      	ldrb	r0, [r2, #5]
 1001052:	7991      	ldrb	r1, [r2, #6]
 1001054:	79d3      	ldrb	r3, [r2, #7]
 1001056:	0200      	lsls	r0, r0, #8
 1001058:	021b      	lsls	r3, r3, #8
 100105a:	4320      	orrs	r0, r4
 100105c:	430b      	orrs	r3, r1
 100105e:	b21b      	sxth	r3, r3
 1001060:	b200      	sxth	r0, r0
 1001062:	1ac0      	subs	r0, r0, r3
 1001064:	1e43      	subs	r3, r0, #1
 1001066:	4198      	sbcs	r0, r3
 1001068:	b2c0      	uxtb	r0, r0
}
 100106a:	bd10      	pop	{r4, pc}
 100106c:	00020000 	.word	0x00020000

01001070 <IPC_get_available_size>:

uint16_t IPC_get_available_size()
{
 1001070:	b570      	push	{r4, r5, r6, lr}
	uint16_t retLen=0;
    if(bt_lpm_mode==1)
 1001072:	4c1c      	ldr	r4, [pc, #112]	; (10010e4 <IPC_get_available_size+0x74>)
 1001074:	7822      	ldrb	r2, [r4, #0]
 1001076:	2a01      	cmp	r2, #1
 1001078:	d109      	bne.n	100108e <IPC_get_available_size+0x1e>
    {
        WAKEUP_BT |= (1 << WAKEUP_BT_FLAG);
 100107a:	2304      	movs	r3, #4
 100107c:	491a      	ldr	r1, [pc, #104]	; (10010e8 <IPC_get_available_size+0x78>)
 100107e:	7808      	ldrb	r0, [r1, #0]
 1001080:	4303      	orrs	r3, r0
 1001082:	700b      	strb	r3, [r1, #0]
        IPC_HOLD_BT  = 1;
 1001084:	4b19      	ldr	r3, [pc, #100]	; (10010ec <IPC_get_available_size+0x7c>)
        delay_ms(10);
 1001086:	200a      	movs	r0, #10
        IPC_HOLD_BT  = 1;
 1001088:	701a      	strb	r2, [r3, #0]
        delay_ms(10);
 100108a:	f7ff fe71 	bl	1000d70 <delay_ms>
    }
    uint16_t readtx = HR_REG_16BIT(&IpcTx->ReadPtr);
 100108e:	4b18      	ldr	r3, [pc, #96]	; (10010f0 <IPC_get_available_size+0x80>)
 1001090:	681a      	ldr	r2, [r3, #0]
 1001092:	7911      	ldrb	r1, [r2, #4]
 1001094:	7950      	ldrb	r0, [r2, #5]
    uint16_t wrtptr = HR_REG_16BIT(&IpcTx->WrtiePtr);
 1001096:	7993      	ldrb	r3, [r2, #6]
    uint16_t readtx = HR_REG_16BIT(&IpcTx->ReadPtr);
 1001098:	0200      	lsls	r0, r0, #8
 100109a:	4301      	orrs	r1, r0
    uint16_t wrtptr = HR_REG_16BIT(&IpcTx->WrtiePtr);
 100109c:	79d0      	ldrb	r0, [r2, #7]
    uint16_t ipcendaddr = HR_REG_16BIT(&IpcTx->IpcEndAddr);
 100109e:	7896      	ldrb	r6, [r2, #2]
    uint16_t wrtptr = HR_REG_16BIT(&IpcTx->WrtiePtr);
 10010a0:	0200      	lsls	r0, r0, #8
 10010a2:	4318      	orrs	r0, r3
    uint16_t ipcendaddr = HR_REG_16BIT(&IpcTx->IpcEndAddr);
 10010a4:	78d3      	ldrb	r3, [r2, #3]
    uint16_t ipcstartaddr = HR_REG_16BIT(&IpcTx->IpcStartAddr);
 10010a6:	7815      	ldrb	r5, [r2, #0]
 10010a8:	7852      	ldrb	r2, [r2, #1]
    uint16_t ipcendaddr = HR_REG_16BIT(&IpcTx->IpcEndAddr);
 10010aa:	b2f6      	uxtb	r6, r6
 10010ac:	b2db      	uxtb	r3, r3
    uint16_t ipcstartaddr = HR_REG_16BIT(&IpcTx->IpcStartAddr);
 10010ae:	b2ed      	uxtb	r5, r5
 10010b0:	b2d2      	uxtb	r2, r2

    if (readtx > wrtptr)
 10010b2:	4281      	cmp	r1, r0
 10010b4:	d90d      	bls.n	10010d2 <IPC_get_available_size+0x62>
    {
        retLen = readtx - wrtptr;
 10010b6:	1a08      	subs	r0, r1, r0
    }
    else
    {
        retLen = ((ipcendaddr - ipcstartaddr + 1) - (readtx - wrtptr));
    }
    if(bt_lpm_mode==1)
 10010b8:	7823      	ldrb	r3, [r4, #0]
        retLen = ((ipcendaddr - ipcstartaddr + 1) - (readtx - wrtptr));
 10010ba:	b280      	uxth	r0, r0
    if(bt_lpm_mode==1)
 10010bc:	2b01      	cmp	r3, #1
 10010be:	d107      	bne.n	10010d0 <IPC_get_available_size+0x60>
    {
        IPC_HOLD_BT = 0;
 10010c0:	2200      	movs	r2, #0
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
 10010c2:	2104      	movs	r1, #4
        IPC_HOLD_BT = 0;
 10010c4:	4b09      	ldr	r3, [pc, #36]	; (10010ec <IPC_get_available_size+0x7c>)
 10010c6:	701a      	strb	r2, [r3, #0]
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
 10010c8:	4a07      	ldr	r2, [pc, #28]	; (10010e8 <IPC_get_available_size+0x78>)
 10010ca:	7813      	ldrb	r3, [r2, #0]
 10010cc:	438b      	bics	r3, r1
 10010ce:	7013      	strb	r3, [r2, #0]
    }
    return retLen;
}
 10010d0:	bd70      	pop	{r4, r5, r6, pc}
    uint16_t ipcendaddr = HR_REG_16BIT(&IpcTx->IpcEndAddr);
 10010d2:	021b      	lsls	r3, r3, #8
 10010d4:	4333      	orrs	r3, r6
        retLen = ((ipcendaddr - ipcstartaddr + 1) - (readtx - wrtptr));
 10010d6:	18c3      	adds	r3, r0, r3
    uint16_t ipcstartaddr = HR_REG_16BIT(&IpcTx->IpcStartAddr);
 10010d8:	0210      	lsls	r0, r2, #8
        retLen = ((ipcendaddr - ipcstartaddr + 1) - (readtx - wrtptr));
 10010da:	3301      	adds	r3, #1
    uint16_t ipcstartaddr = HR_REG_16BIT(&IpcTx->IpcStartAddr);
 10010dc:	4328      	orrs	r0, r5
        retLen = ((ipcendaddr - ipcstartaddr + 1) - (readtx - wrtptr));
 10010de:	1a18      	subs	r0, r3, r0
 10010e0:	1a40      	subs	r0, r0, r1
 10010e2:	e7e9      	b.n	10010b8 <IPC_get_available_size+0x48>
 10010e4:	00020244 	.word	0x00020244
 10010e8:	000f853c 	.word	0x000f853c
 10010ec:	000c4fef 	.word	0x000c4fef
 10010f0:	00020004 	.word	0x00020004

010010f4 <IPC_TxData>:

void IPC_TxData(HCI_TypeDef *IpcData)
{
 10010f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	#ifdef IPC_DEBUG
	PrintHCIPack(IpcData,"tx");
	#endif
    if(bt_lpm_mode==1)
 10010f6:	4b29      	ldr	r3, [pc, #164]	; (100119c <IPC_TxData+0xa8>)
{
 10010f8:	0004      	movs	r4, r0
    if(bt_lpm_mode==1)
 10010fa:	781a      	ldrb	r2, [r3, #0]
 10010fc:	2a01      	cmp	r2, #1
 10010fe:	d109      	bne.n	1001114 <IPC_TxData+0x20>
    {
        WAKEUP_BT |= (1 << WAKEUP_BT_FLAG);
 1001100:	2304      	movs	r3, #4
 1001102:	4927      	ldr	r1, [pc, #156]	; (10011a0 <IPC_TxData+0xac>)
 1001104:	7808      	ldrb	r0, [r1, #0]
 1001106:	4303      	orrs	r3, r0
 1001108:	700b      	strb	r3, [r1, #0]
        IPC_HOLD_BT  = 1;
 100110a:	4b26      	ldr	r3, [pc, #152]	; (10011a4 <IPC_TxData+0xb0>)
        delay_ms(10);
 100110c:	200a      	movs	r0, #10
        IPC_HOLD_BT  = 1;
 100110e:	701a      	strb	r2, [r3, #0]
        delay_ms(10);
 1001110:	f7ff fe2e 	bl	1000d70 <delay_ms>
    }
    uint16_t Wptr  = HR_REG_16BIT(&IpcTx->WrtiePtr);
 1001114:	4f24      	ldr	r7, [pc, #144]	; (10011a8 <IPC_TxData+0xb4>)
 1001116:	683a      	ldr	r2, [r7, #0]
 1001118:	7991      	ldrb	r1, [r2, #6]
 100111a:	79d3      	ldrb	r3, [r2, #7]
    uint16_t Len   = IpcData->DataLen + 3;
 100111c:	78a2      	ldrb	r2, [r4, #2]
    uint16_t Wptr  = HR_REG_16BIT(&IpcTx->WrtiePtr);
 100111e:	021b      	lsls	r3, r3, #8
 1001120:	430b      	orrs	r3, r1
    uint8_t *Rptr = (uint8_t *)IpcData;
    while (Len--)
 1001122:	0021      	movs	r1, r4
    uint16_t Len   = IpcData->DataLen + 3;
 1001124:	3203      	adds	r2, #3
    while (Len--)
 1001126:	3a01      	subs	r2, #1
 1001128:	4820      	ldr	r0, [pc, #128]	; (10011ac <IPC_TxData+0xb8>)
 100112a:	b292      	uxth	r2, r2
 100112c:	4282      	cmp	r2, r0
 100112e:	d111      	bne.n	1001154 <IPC_TxData+0x60>
        RB_UPDATE_PTR(Wptr, HR_REG_16BIT(&IpcTx->IpcStartAddr),  HR_REG_16BIT(&IpcTx->IpcEndAddr));
        if (Len == IpcData->DataLen)
        Rptr = IpcData->p_data;
    }

    HW_REG_16BIT(&IpcTx->WrtiePtr, (uint32_t)Wptr);
 1001130:	683a      	ldr	r2, [r7, #0]
 1001132:	b2d9      	uxtb	r1, r3
 1001134:	0a1b      	lsrs	r3, r3, #8
 1001136:	7191      	strb	r1, [r2, #6]
 1001138:	71d3      	strb	r3, [r2, #7]
    if(bt_lpm_mode==1)
 100113a:	4b18      	ldr	r3, [pc, #96]	; (100119c <IPC_TxData+0xa8>)
 100113c:	781b      	ldrb	r3, [r3, #0]
 100113e:	2b01      	cmp	r3, #1
 1001140:	d107      	bne.n	1001152 <IPC_TxData+0x5e>
    {
        IPC_HOLD_BT = 0;
 1001142:	2200      	movs	r2, #0
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
 1001144:	2104      	movs	r1, #4
        IPC_HOLD_BT = 0;
 1001146:	4b17      	ldr	r3, [pc, #92]	; (10011a4 <IPC_TxData+0xb0>)
 1001148:	701a      	strb	r2, [r3, #0]
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
 100114a:	4a15      	ldr	r2, [pc, #84]	; (10011a0 <IPC_TxData+0xac>)
 100114c:	7813      	ldrb	r3, [r2, #0]
 100114e:	438b      	bics	r3, r1
 1001150:	7013      	strb	r3, [r2, #0]
    }
}
 1001152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        HW_IPC_REG_8BIT(Wptr, *Rptr++);
 1001154:	20c0      	movs	r0, #192	; 0xc0
 1001156:	780e      	ldrb	r6, [r1, #0]
 1001158:	0300      	lsls	r0, r0, #12
 100115a:	4318      	orrs	r0, r3
 100115c:	7006      	strb	r6, [r0, #0]
        RB_UPDATE_PTR(Wptr, HR_REG_16BIT(&IpcTx->IpcStartAddr),  HR_REG_16BIT(&IpcTx->IpcEndAddr));
 100115e:	683e      	ldr	r6, [r7, #0]
 1001160:	78b0      	ldrb	r0, [r6, #2]
 1001162:	4684      	mov	ip, r0
 1001164:	4665      	mov	r5, ip
 1001166:	78f0      	ldrb	r0, [r6, #3]
 1001168:	0200      	lsls	r0, r0, #8
 100116a:	4328      	orrs	r0, r5
 100116c:	4298      	cmp	r0, r3
 100116e:	d112      	bne.n	1001196 <IPC_TxData+0xa2>
 1001170:	7830      	ldrb	r0, [r6, #0]
 1001172:	7873      	ldrb	r3, [r6, #1]
 1001174:	021b      	lsls	r3, r3, #8
 1001176:	4303      	orrs	r3, r0
        if (Len == IpcData->DataLen)
 1001178:	78a0      	ldrb	r0, [r4, #2]
        HW_IPC_REG_8BIT(Wptr, *Rptr++);
 100117a:	3101      	adds	r1, #1
        if (Len == IpcData->DataLen)
 100117c:	4290      	cmp	r0, r2
 100117e:	d1d2      	bne.n	1001126 <IPC_TxData+0x32>
        Rptr = IpcData->p_data;
 1001180:	7920      	ldrb	r0, [r4, #4]
 1001182:	78e6      	ldrb	r6, [r4, #3]
 1001184:	7961      	ldrb	r1, [r4, #5]
 1001186:	0200      	lsls	r0, r0, #8
 1001188:	0409      	lsls	r1, r1, #16
 100118a:	4306      	orrs	r6, r0
 100118c:	430e      	orrs	r6, r1
 100118e:	79a1      	ldrb	r1, [r4, #6]
 1001190:	0609      	lsls	r1, r1, #24
 1001192:	4331      	orrs	r1, r6
 1001194:	e7c7      	b.n	1001126 <IPC_TxData+0x32>
        RB_UPDATE_PTR(Wptr, HR_REG_16BIT(&IpcTx->IpcStartAddr),  HR_REG_16BIT(&IpcTx->IpcEndAddr));
 1001196:	3301      	adds	r3, #1
 1001198:	b29b      	uxth	r3, r3
 100119a:	e7ed      	b.n	1001178 <IPC_TxData+0x84>
 100119c:	00020244 	.word	0x00020244
 10011a0:	000f853c 	.word	0x000f853c
 10011a4:	000c4fef 	.word	0x000c4fef
 10011a8:	00020004 	.word	0x00020004
 10011ac:	0000ffff 	.word	0x0000ffff

010011b0 <IPC_PutBtData>:

Boolean IPC_PutBtData(const void *buf, uint32_t size)
{
 10011b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (size == 0 || size > 258)
 10011b2:	2302      	movs	r3, #2
 10011b4:	1e4a      	subs	r2, r1, #1
 10011b6:	33ff      	adds	r3, #255	; 0xff
{
 10011b8:	0006      	movs	r6, r0
 10011ba:	000d      	movs	r5, r1
    {
        return FALSE;
 10011bc:	2000      	movs	r0, #0
    if (size == 0 || size > 258)
 10011be:	429a      	cmp	r2, r3
 10011c0:	d828      	bhi.n	1001214 <IPC_PutBtData+0x64>
    }
    if(bt_lpm_mode==1)
 10011c2:	4c20      	ldr	r4, [pc, #128]	; (1001244 <IPC_PutBtData+0x94>)
 10011c4:	7822      	ldrb	r2, [r4, #0]
 10011c6:	2a01      	cmp	r2, #1
 10011c8:	d109      	bne.n	10011de <IPC_PutBtData+0x2e>
    {
        WAKEUP_BT |= (1 << WAKEUP_BT_FLAG);
 10011ca:	491f      	ldr	r1, [pc, #124]	; (1001248 <IPC_PutBtData+0x98>)
 10011cc:	3bfd      	subs	r3, #253	; 0xfd
 10011ce:	7808      	ldrb	r0, [r1, #0]
 10011d0:	4303      	orrs	r3, r0
 10011d2:	700b      	strb	r3, [r1, #0]
        IPC_HOLD_BT  = 1;
 10011d4:	4b1d      	ldr	r3, [pc, #116]	; (100124c <IPC_PutBtData+0x9c>)
        delay_ms(10);
 10011d6:	200a      	movs	r0, #10
        IPC_HOLD_BT  = 1;
 10011d8:	701a      	strb	r2, [r3, #0]
        delay_ms(10);
 10011da:	f7ff fdc9 	bl	1000d70 <delay_ms>
 10011de:	0030      	movs	r0, r6
    }
    uint16_t Wptr  = HR_REG_16BIT(&IpcTx->WrtiePtr);
 10011e0:	4f1b      	ldr	r7, [pc, #108]	; (1001250 <IPC_PutBtData+0xa0>)
 10011e2:	1975      	adds	r5, r6, r5
 10011e4:	683a      	ldr	r2, [r7, #0]
 10011e6:	7991      	ldrb	r1, [r2, #6]
 10011e8:	79d3      	ldrb	r3, [r2, #7]
 10011ea:	021b      	lsls	r3, r3, #8
 10011ec:	430b      	orrs	r3, r1
    uint8_t *Rptr = (uint8_t *)buf;
    while (size--)
 10011ee:	4285      	cmp	r5, r0
 10011f0:	d111      	bne.n	1001216 <IPC_PutBtData+0x66>
    if(bt_lpm_mode==1)
    {
        IPC_HOLD_BT = 0;
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
    }
    return TRUE;
 10011f2:	2001      	movs	r0, #1
    HW_REG_16BIT(&IpcTx->WrtiePtr, (uint32_t)Wptr);
 10011f4:	683a      	ldr	r2, [r7, #0]
 10011f6:	b2d9      	uxtb	r1, r3
 10011f8:	0a1b      	lsrs	r3, r3, #8
 10011fa:	7191      	strb	r1, [r2, #6]
 10011fc:	71d3      	strb	r3, [r2, #7]
    if(bt_lpm_mode==1)
 10011fe:	7823      	ldrb	r3, [r4, #0]
 1001200:	4283      	cmp	r3, r0
 1001202:	d107      	bne.n	1001214 <IPC_PutBtData+0x64>
        IPC_HOLD_BT = 0;
 1001204:	2200      	movs	r2, #0
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
 1001206:	2104      	movs	r1, #4
        IPC_HOLD_BT = 0;
 1001208:	4b10      	ldr	r3, [pc, #64]	; (100124c <IPC_PutBtData+0x9c>)
 100120a:	701a      	strb	r2, [r3, #0]
        WAKEUP_BT &= ~(1 << WAKEUP_BT_FLAG);
 100120c:	4a0e      	ldr	r2, [pc, #56]	; (1001248 <IPC_PutBtData+0x98>)
 100120e:	7813      	ldrb	r3, [r2, #0]
 1001210:	438b      	bics	r3, r1
 1001212:	7013      	strb	r3, [r2, #0]
}
 1001214:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        HW_IPC_REG_8BIT(Wptr, *Rptr++);
 1001216:	22c0      	movs	r2, #192	; 0xc0
 1001218:	7801      	ldrb	r1, [r0, #0]
 100121a:	0312      	lsls	r2, r2, #12
 100121c:	431a      	orrs	r2, r3
 100121e:	7011      	strb	r1, [r2, #0]
        RB_UPDATE_PTR(Wptr, HR_REG_16BIT(&IpcTx->IpcStartAddr),  HR_REG_16BIT(&IpcTx->IpcEndAddr));
 1001220:	6839      	ldr	r1, [r7, #0]
 1001222:	788a      	ldrb	r2, [r1, #2]
 1001224:	4694      	mov	ip, r2
 1001226:	4666      	mov	r6, ip
 1001228:	78ca      	ldrb	r2, [r1, #3]
 100122a:	0212      	lsls	r2, r2, #8
 100122c:	4332      	orrs	r2, r6
 100122e:	429a      	cmp	r2, r3
 1001230:	d105      	bne.n	100123e <IPC_PutBtData+0x8e>
 1001232:	780a      	ldrb	r2, [r1, #0]
 1001234:	784b      	ldrb	r3, [r1, #1]
 1001236:	021b      	lsls	r3, r3, #8
 1001238:	4313      	orrs	r3, r2
 100123a:	3001      	adds	r0, #1
 100123c:	e7d7      	b.n	10011ee <IPC_PutBtData+0x3e>
 100123e:	3301      	adds	r3, #1
 1001240:	b29b      	uxth	r3, r3
 1001242:	e7fa      	b.n	100123a <IPC_PutBtData+0x8a>
 1001244:	00020244 	.word	0x00020244
 1001248:	000f853c 	.word	0x000f853c
 100124c:	000c4fef 	.word	0x000c4fef
 1001250:	00020004 	.word	0x00020004

01001254 <IPC_ReadBtData>:

Boolean IPC_ReadBtData(HCI_TypeDef *IpcData)
{
 1001254:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (HR_REG_16BIT(&IpcRx->ReadPtr) != HR_REG_16BIT(&IpcRx->WrtiePtr))
 1001256:	4d3b      	ldr	r5, [pc, #236]	; (1001344 <IPC_ReadBtData+0xf0>)
{
 1001258:	0001      	movs	r1, r0
    if (HR_REG_16BIT(&IpcRx->ReadPtr) != HR_REG_16BIT(&IpcRx->WrtiePtr))
 100125a:	682a      	ldr	r2, [r5, #0]
 100125c:	7916      	ldrb	r6, [r2, #4]
 100125e:	7953      	ldrb	r3, [r2, #5]
 1001260:	7990      	ldrb	r0, [r2, #6]
 1001262:	79d4      	ldrb	r4, [r2, #7]
 1001264:	021b      	lsls	r3, r3, #8
 1001266:	0224      	lsls	r4, r4, #8
 1001268:	4304      	orrs	r4, r0
 100126a:	4333      	orrs	r3, r6
		#endif
        return TRUE;
    }
    else
    {
        return FALSE;
 100126c:	2000      	movs	r0, #0
    if (HR_REG_16BIT(&IpcRx->ReadPtr) != HR_REG_16BIT(&IpcRx->WrtiePtr))
 100126e:	429c      	cmp	r4, r3
 1001270:	d03e      	beq.n	10012f0 <IPC_ReadBtData+0x9c>
        IpcData->type = HR_IPC_REG_8BIT(Rptr);
 1001272:	26c0      	movs	r6, #192	; 0xc0
 1001274:	0336      	lsls	r6, r6, #12
 1001276:	0034      	movs	r4, r6
        uint16_t Rptr = HR_REG_16BIT(&IpcRx->ReadPtr);
 1001278:	7913      	ldrb	r3, [r2, #4]
 100127a:	7950      	ldrb	r0, [r2, #5]
 100127c:	0200      	lsls	r0, r0, #8
 100127e:	4318      	orrs	r0, r3
 1001280:	b200      	sxth	r0, r0
 1001282:	b283      	uxth	r3, r0
        IpcData->type = HR_IPC_REG_8BIT(Rptr);
 1001284:	431c      	orrs	r4, r3
 1001286:	7824      	ldrb	r4, [r4, #0]
 1001288:	700c      	strb	r4, [r1, #0]
        RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 100128a:	7897      	ldrb	r7, [r2, #2]
 100128c:	78d4      	ldrb	r4, [r2, #3]
 100128e:	0224      	lsls	r4, r4, #8
 1001290:	433c      	orrs	r4, r7
 1001292:	b224      	sxth	r4, r4
 1001294:	42a0      	cmp	r0, r4
 1001296:	d12c      	bne.n	10012f2 <IPC_ReadBtData+0x9e>
 1001298:	7810      	ldrb	r0, [r2, #0]
 100129a:	7853      	ldrb	r3, [r2, #1]
 100129c:	021b      	lsls	r3, r3, #8
 100129e:	4303      	orrs	r3, r0
        IpcData->opcode = HR_IPC_REG_8BIT(Rptr);
 10012a0:	431e      	orrs	r6, r3
 10012a2:	7830      	ldrb	r0, [r6, #0]
 10012a4:	7048      	strb	r0, [r1, #1]
        RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 10012a6:	7894      	ldrb	r4, [r2, #2]
 10012a8:	78d0      	ldrb	r0, [r2, #3]
 10012aa:	0200      	lsls	r0, r0, #8
 10012ac:	4320      	orrs	r0, r4
 10012ae:	4298      	cmp	r0, r3
 10012b0:	d122      	bne.n	10012f8 <IPC_ReadBtData+0xa4>
 10012b2:	7810      	ldrb	r0, [r2, #0]
 10012b4:	7853      	ldrb	r3, [r2, #1]
 10012b6:	021b      	lsls	r3, r3, #8
 10012b8:	4303      	orrs	r3, r0
        IpcData->DataLen = HR_IPC_REG_8BIT(Rptr);
 10012ba:	20c0      	movs	r0, #192	; 0xc0
 10012bc:	0300      	lsls	r0, r0, #12
 10012be:	4318      	orrs	r0, r3
 10012c0:	7800      	ldrb	r0, [r0, #0]
 10012c2:	7088      	strb	r0, [r1, #2]
        RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 10012c4:	7894      	ldrb	r4, [r2, #2]
 10012c6:	78d0      	ldrb	r0, [r2, #3]
 10012c8:	0200      	lsls	r0, r0, #8
 10012ca:	4320      	orrs	r0, r4
 10012cc:	4298      	cmp	r0, r3
 10012ce:	d116      	bne.n	10012fe <IPC_ReadBtData+0xaa>
 10012d0:	7810      	ldrb	r0, [r2, #0]
 10012d2:	7853      	ldrb	r3, [r2, #1]
 10012d4:	021b      	lsls	r3, r3, #8
 10012d6:	4303      	orrs	r3, r0
            IpcData->p_data[i] = HR_IPC_REG_8BIT(Rptr);
 10012d8:	24c0      	movs	r4, #192	; 0xc0
{
 10012da:	2200      	movs	r2, #0
            IpcData->p_data[i] = HR_IPC_REG_8BIT(Rptr);
 10012dc:	0324      	lsls	r4, r4, #12
        for (uint8_t i = 0; i < IpcData->DataLen; i++)
 10012de:	7888      	ldrb	r0, [r1, #2]
 10012e0:	4290      	cmp	r0, r2
 10012e2:	d80f      	bhi.n	1001304 <IPC_ReadBtData+0xb0>
        return TRUE;
 10012e4:	2001      	movs	r0, #1
        HW_REG_16BIT(&IpcRx->ReadPtr, (uint32_t)Rptr);
 10012e6:	682a      	ldr	r2, [r5, #0]
 10012e8:	b2d9      	uxtb	r1, r3
 10012ea:	0a1b      	lsrs	r3, r3, #8
 10012ec:	7111      	strb	r1, [r2, #4]
 10012ee:	7153      	strb	r3, [r2, #5]
    }
}
 10012f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 10012f2:	3301      	adds	r3, #1
 10012f4:	b29b      	uxth	r3, r3
 10012f6:	e7d3      	b.n	10012a0 <IPC_ReadBtData+0x4c>
        RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 10012f8:	3301      	adds	r3, #1
 10012fa:	b29b      	uxth	r3, r3
 10012fc:	e7dd      	b.n	10012ba <IPC_ReadBtData+0x66>
        RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 10012fe:	3301      	adds	r3, #1
 1001300:	b29b      	uxth	r3, r3
 1001302:	e7e9      	b.n	10012d8 <IPC_ReadBtData+0x84>
            IpcData->p_data[i] = HR_IPC_REG_8BIT(Rptr);
 1001304:	0020      	movs	r0, r4
 1001306:	790f      	ldrb	r7, [r1, #4]
 1001308:	4318      	orrs	r0, r3
 100130a:	7806      	ldrb	r6, [r0, #0]
 100130c:	78c8      	ldrb	r0, [r1, #3]
 100130e:	023f      	lsls	r7, r7, #8
 1001310:	4307      	orrs	r7, r0
 1001312:	7948      	ldrb	r0, [r1, #5]
 1001314:	0400      	lsls	r0, r0, #16
 1001316:	4307      	orrs	r7, r0
 1001318:	7988      	ldrb	r0, [r1, #6]
 100131a:	0600      	lsls	r0, r0, #24
 100131c:	4338      	orrs	r0, r7
 100131e:	5486      	strb	r6, [r0, r2]
            RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 1001320:	682e      	ldr	r6, [r5, #0]
 1001322:	78b7      	ldrb	r7, [r6, #2]
 1001324:	78f0      	ldrb	r0, [r6, #3]
 1001326:	0200      	lsls	r0, r0, #8
 1001328:	4338      	orrs	r0, r7
 100132a:	4298      	cmp	r0, r3
 100132c:	d106      	bne.n	100133c <IPC_ReadBtData+0xe8>
 100132e:	7830      	ldrb	r0, [r6, #0]
 1001330:	7873      	ldrb	r3, [r6, #1]
 1001332:	021b      	lsls	r3, r3, #8
 1001334:	4303      	orrs	r3, r0
        for (uint8_t i = 0; i < IpcData->DataLen; i++)
 1001336:	3201      	adds	r2, #1
 1001338:	b2d2      	uxtb	r2, r2
 100133a:	e7d0      	b.n	10012de <IPC_ReadBtData+0x8a>
            RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 100133c:	3301      	adds	r3, #1
 100133e:	b29b      	uxth	r3, r3
 1001340:	e7f9      	b.n	1001336 <IPC_ReadBtData+0xe2>
 1001342:	46c0      	nop			; (mov r8, r8)
 1001344:	00020000 	.word	0x00020000

01001348 <IPC_GetBtData>:

Boolean IPC_GetBtData(void *buf, uint32_t *size)
{
 1001348:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 100134a:	9000      	str	r0, [sp, #0]
    uint32_t i = 0;
    uint16_t Rptr = HR_REG_16BIT(&IpcRx->ReadPtr);
    if (*size == 0)
    {
        *size = 0;
        return FALSE;
 100134c:	2000      	movs	r0, #0
    uint16_t Rptr = HR_REG_16BIT(&IpcRx->ReadPtr);
 100134e:	4d21      	ldr	r5, [pc, #132]	; (10013d4 <IPC_GetBtData+0x8c>)
{
 1001350:	000e      	movs	r6, r1
    uint16_t Rptr = HR_REG_16BIT(&IpcRx->ReadPtr);
 1001352:	682b      	ldr	r3, [r5, #0]
 1001354:	791f      	ldrb	r7, [r3, #4]
 1001356:	795c      	ldrb	r4, [r3, #5]
    if (*size == 0)
 1001358:	680b      	ldr	r3, [r1, #0]
    uint16_t Rptr = HR_REG_16BIT(&IpcRx->ReadPtr);
 100135a:	b2ff      	uxtb	r7, r7
 100135c:	b2e4      	uxtb	r4, r4
    if (*size == 0)
 100135e:	4283      	cmp	r3, r0
 1001360:	d019      	beq.n	1001396 <IPC_GetBtData+0x4e>
    }
    if (TRUE == IPC_have_data())
 1001362:	f7ff fe71 	bl	1001048 <IPC_have_data>
 1001366:	2801      	cmp	r0, #1
 1001368:	d131      	bne.n	10013ce <IPC_GetBtData+0x86>
    uint16_t Rptr = HR_REG_16BIT(&IpcRx->ReadPtr);
 100136a:	0224      	lsls	r4, r4, #8
 100136c:	9900      	ldr	r1, [sp, #0]
 100136e:	4327      	orrs	r7, r4
    {
        while (Rptr != HR_REG_16BIT(&IpcRx->WrtiePtr) && i < (*size))
 1001370:	9501      	str	r5, [sp, #4]
 1001372:	9b00      	ldr	r3, [sp, #0]
 1001374:	1acc      	subs	r4, r1, r3
 1001376:	9b01      	ldr	r3, [sp, #4]
 1001378:	681a      	ldr	r2, [r3, #0]
 100137a:	7993      	ldrb	r3, [r2, #6]
 100137c:	469c      	mov	ip, r3
 100137e:	4665      	mov	r5, ip
 1001380:	79d3      	ldrb	r3, [r2, #7]
 1001382:	021b      	lsls	r3, r3, #8
 1001384:	432b      	orrs	r3, r5
 1001386:	42bb      	cmp	r3, r7
 1001388:	d11c      	bne.n	10013c4 <IPC_GetBtData+0x7c>
        {
            ((uint8_t *)buf)[i++] = HR_IPC_REG_8BIT(Rptr);
            RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
        }
        HW_REG_16BIT(&IpcRx->ReadPtr, (uint32_t)Rptr);
 100138a:	b2d9      	uxtb	r1, r3
 100138c:	0a1b      	lsrs	r3, r3, #8
 100138e:	b2db      	uxtb	r3, r3
 1001390:	7111      	strb	r1, [r2, #4]
 1001392:	7153      	strb	r3, [r2, #5]
        *size = i;
 1001394:	6034      	str	r4, [r6, #0]
    else
    {
        *size = 0;
        return FALSE;
    }
}
 1001396:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
            ((uint8_t *)buf)[i++] = HR_IPC_REG_8BIT(Rptr);
 1001398:	23c0      	movs	r3, #192	; 0xc0
 100139a:	031b      	lsls	r3, r3, #12
 100139c:	433b      	orrs	r3, r7
 100139e:	781b      	ldrb	r3, [r3, #0]
 10013a0:	700b      	strb	r3, [r1, #0]
            RB_UPDATE_PTR(Rptr, HR_REG_16BIT(&IpcRx->IpcStartAddr),  HR_REG_16BIT(&IpcRx->IpcEndAddr));
 10013a2:	9b01      	ldr	r3, [sp, #4]
 10013a4:	681a      	ldr	r2, [r3, #0]
 10013a6:	7894      	ldrb	r4, [r2, #2]
 10013a8:	78d3      	ldrb	r3, [r2, #3]
 10013aa:	021b      	lsls	r3, r3, #8
 10013ac:	4323      	orrs	r3, r4
 10013ae:	42bb      	cmp	r3, r7
 10013b0:	d105      	bne.n	10013be <IPC_GetBtData+0x76>
 10013b2:	7814      	ldrb	r4, [r2, #0]
 10013b4:	7857      	ldrb	r7, [r2, #1]
 10013b6:	023f      	lsls	r7, r7, #8
 10013b8:	4327      	orrs	r7, r4
 10013ba:	3101      	adds	r1, #1
 10013bc:	e7d9      	b.n	1001372 <IPC_GetBtData+0x2a>
 10013be:	3701      	adds	r7, #1
 10013c0:	b2bf      	uxth	r7, r7
 10013c2:	e7fa      	b.n	10013ba <IPC_GetBtData+0x72>
        while (Rptr != HR_REG_16BIT(&IpcRx->WrtiePtr) && i < (*size))
 10013c4:	6833      	ldr	r3, [r6, #0]
 10013c6:	429c      	cmp	r4, r3
 10013c8:	d3e6      	bcc.n	1001398 <IPC_GetBtData+0x50>
 10013ca:	003b      	movs	r3, r7
 10013cc:	e7dd      	b.n	100138a <IPC_GetBtData+0x42>
        *size = 0;
 10013ce:	2000      	movs	r0, #0
 10013d0:	6030      	str	r0, [r6, #0]
        return FALSE;
 10013d2:	e7e0      	b.n	1001396 <IPC_GetBtData+0x4e>
 10013d4:	00020000 	.word	0x00020000

010013d8 <_dma_wait>:
    DMA_START(ch)     = 0x80;
}

void __NOINLINE _dma_wait(int ch)
{
    while (!(DMA_STATUS(ch) & 1));
 10013d8:	4b03      	ldr	r3, [pc, #12]	; (10013e8 <_dma_wait+0x10>)
 10013da:	0200      	lsls	r0, r0, #8
 10013dc:	18c0      	adds	r0, r0, r3
 10013de:	2301      	movs	r3, #1
 10013e0:	6802      	ldr	r2, [r0, #0]
 10013e2:	421a      	tst	r2, r3
 10013e4:	d0fc      	beq.n	10013e0 <_dma_wait+0x8>
}
 10013e6:	4770      	bx	lr
 10013e8:	000f8810 	.word	0x000f8810

010013ec <_dmacopy>:

void _dmacopy(void *dest, void *src, int len)
{
 10013ec:	b510      	push	{r4, lr}
 10013ee:	0004      	movs	r4, r0
    _dma_start(DMACH_MEMCP, src, len, dest, len);
 10013f0:	0013      	movs	r3, r2
{
 10013f2:	0008      	movs	r0, r1
 10013f4:	0011      	movs	r1, r2
    _dma_start(DMACH_MEMCP, src, len, dest, len);
 10013f6:	0022      	movs	r2, r4
 10013f8:	f000 f916 	bl	1001628 <_dma_start.constprop.1>
    _dma_wait(DMACH_MEMCP);
 10013fc:	2006      	movs	r0, #6
 10013fe:	f7ff ffeb 	bl	10013d8 <_dma_wait>
}
 1001402:	bd10      	pop	{r4, pc}

01001404 <_download_btcode>:

void _download_btcode(const byte *btcode)
{
 1001404:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    int addr, len;
    btcode += 2;
    if (GETWORD(btcode) != 0x55aa)
 1001406:	7882      	ldrb	r2, [r0, #2]
 1001408:	78c3      	ldrb	r3, [r0, #3]
 100140a:	021b      	lsls	r3, r3, #8
 100140c:	4313      	orrs	r3, r2
 100140e:	4a2c      	ldr	r2, [pc, #176]	; (10014c0 <_download_btcode+0xbc>)
 1001410:	b21b      	sxth	r3, r3
 1001412:	4293      	cmp	r3, r2
 1001414:	d125      	bne.n	1001462 <_download_btcode+0x5e>
        return;
    btcode += 2;
    enable_clock(CLKCLS_BT);
    len = GETWORD(btcode);
    btcode += 2;
    BT_UCODE_LO   = 0;
 1001416:	2600      	movs	r6, #0
    SYSCTRL_CLK_CLS &= ~(1 << id);
 1001418:	4a2a      	ldr	r2, [pc, #168]	; (10014c4 <_download_btcode+0xc0>)
 100141a:	492b      	ldr	r1, [pc, #172]	; (10014c8 <_download_btcode+0xc4>)
 100141c:	6813      	ldr	r3, [r2, #0]
    BT_UCODE_HI   = 0;
    BT_UCODE_CTRL = 0x80;
 100141e:	4f2b      	ldr	r7, [pc, #172]	; (10014cc <_download_btcode+0xc8>)
 1001420:	400b      	ands	r3, r1
 1001422:	6013      	str	r3, [r2, #0]
    BT_UCODE_LO   = 0;
 1001424:	4b2a      	ldr	r3, [pc, #168]	; (10014d0 <_download_btcode+0xcc>)
    len = GETWORD(btcode);
 1001426:	7904      	ldrb	r4, [r0, #4]
 1001428:	7945      	ldrb	r5, [r0, #5]
    BT_UCODE_LO   = 0;
 100142a:	701e      	strb	r6, [r3, #0]
    BT_UCODE_HI   = 0;
 100142c:	4b29      	ldr	r3, [pc, #164]	; (10014d4 <_download_btcode+0xd0>)
    DMA_CONFIG(DMACH_MEMCP) = 8;
 100142e:	4a2a      	ldr	r2, [pc, #168]	; (10014d8 <_download_btcode+0xd4>)
    BT_UCODE_HI   = 0;
 1001430:	701e      	strb	r6, [r3, #0]
    BT_UCODE_CTRL = 0x80;
 1001432:	2380      	movs	r3, #128	; 0x80
    len = GETWORD(btcode);
 1001434:	022d      	lsls	r5, r5, #8
 1001436:	4325      	orrs	r5, r4
    BT_UCODE_CTRL = 0x80;
 1001438:	703b      	strb	r3, [r7, #0]
    btcode += 2;
 100143a:	1d84      	adds	r4, r0, #6
    DMA_CONFIG(DMACH_MEMCP) = 8;
 100143c:	3b78      	subs	r3, #120	; 0x78
 100143e:	7013      	strb	r3, [r2, #0]
    _dmacopy((byte *)&BT_UCODE_DATA, (byte *)btcode, len);
 1001440:	0021      	movs	r1, r4
 1001442:	002a      	movs	r2, r5
 1001444:	4825      	ldr	r0, [pc, #148]	; (10014dc <_download_btcode+0xd8>)
 1001446:	f7ff ffd1 	bl	10013ec <_dmacopy>
    BT_UCODE_CTRL = 0;
    btcode       += len;
    DMA_CONFIG(DMACH_MEMCP) = 0;
 100144a:	4a23      	ldr	r2, [pc, #140]	; (10014d8 <_download_btcode+0xd4>)
    BT_UCODE_CTRL = 0;
 100144c:	703e      	strb	r6, [r7, #0]
    btcode       += len;
 100144e:	1961      	adds	r1, r4, r5
    DMA_CONFIG(DMACH_MEMCP) = 0;
 1001450:	7016      	strb	r6, [r2, #0]

    while (GETWORD(btcode) == 0x55aa)
 1001452:	780a      	ldrb	r2, [r1, #0]
 1001454:	784b      	ldrb	r3, [r1, #1]
 1001456:	021b      	lsls	r3, r3, #8
 1001458:	4313      	orrs	r3, r2
 100145a:	4a19      	ldr	r2, [pc, #100]	; (10014c0 <_download_btcode+0xbc>)
 100145c:	b21b      	sxth	r3, r3
 100145e:	4293      	cmp	r3, r2
 1001460:	d000      	beq.n	1001464 <_download_btcode+0x60>
        {
          _dmacopy((byte *)addr, (byte *)btcode, len);
        }
        btcode += len;
    }
}
 1001462:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        len  = GETWORD(btcode);
 1001464:	788b      	ldrb	r3, [r1, #2]
 1001466:	78cf      	ldrb	r7, [r1, #3]
        btcode += 2;
 1001468:	1d8d      	adds	r5, r1, #6
        len  = GETWORD(btcode);
 100146a:	023f      	lsls	r7, r7, #8
 100146c:	431f      	orrs	r7, r3
        addr = GETWORD(btcode) | 0xc0000;
 100146e:	790b      	ldrb	r3, [r1, #4]
 1001470:	794e      	ldrb	r6, [r1, #5]
 1001472:	0236      	lsls	r6, r6, #8
 1001474:	431e      	orrs	r6, r3
 1001476:	23c0      	movs	r3, #192	; 0xc0
 1001478:	031b      	lsls	r3, r3, #12
 100147a:	431e      	orrs	r6, r3
        if(addr==MEM_SPP_FLOWCTRL_FLAG_ADDR && len==0x0004)
 100147c:	4b18      	ldr	r3, [pc, #96]	; (10014e0 <_download_btcode+0xdc>)
 100147e:	429e      	cmp	r6, r3
 1001480:	d111      	bne.n	10014a6 <_download_btcode+0xa2>
 1001482:	2f04      	cmp	r7, #4
 1001484:	d119      	bne.n	10014ba <_download_btcode+0xb6>
            mem_spp_flowctrl_buf[0]=MEM_SPP_FLOWCTRL_FLAG_VALUE;
 1001486:	2301      	movs	r3, #1
 1001488:	ac01      	add	r4, sp, #4
 100148a:	7023      	strb	r3, [r4, #0]
            memcpy((byte*)&mem_spp_flowctrl_buf[1],btcode+1,3);
 100148c:	466b      	mov	r3, sp
 100148e:	3107      	adds	r1, #7
 1001490:	2203      	movs	r2, #3
 1001492:	1d58      	adds	r0, r3, #5
 1001494:	f002 fca4 	bl	1003de0 <memcpy>
            _dmacopy((byte *)addr, mem_spp_flowctrl_buf, len);
 1001498:	003a      	movs	r2, r7
 100149a:	0021      	movs	r1, r4
          _dmacopy((byte *)addr, (byte *)btcode, len);
 100149c:	0030      	movs	r0, r6
 100149e:	f7ff ffa5 	bl	10013ec <_dmacopy>
        btcode += len;
 10014a2:	19e9      	adds	r1, r5, r7
 10014a4:	e7d5      	b.n	1001452 <_download_btcode+0x4e>
        else if(addr==MEM_RFCOMM_LMP_DIS_FLAG_ADDR && len==0x0001)
 10014a6:	4b0f      	ldr	r3, [pc, #60]	; (10014e4 <_download_btcode+0xe0>)
 10014a8:	429e      	cmp	r6, r3
 10014aa:	d106      	bne.n	10014ba <_download_btcode+0xb6>
 10014ac:	2f01      	cmp	r7, #1
 10014ae:	d104      	bne.n	10014ba <_download_btcode+0xb6>
            mem_rfcomm_lmp_dis_flag=MEM_RFCOMM_LMP_DIS_FLAG_VALUE;
 10014b0:	2300      	movs	r3, #0
 10014b2:	a901      	add	r1, sp, #4
 10014b4:	700b      	strb	r3, [r1, #0]
            _dmacopy((byte *)addr, (byte *)&mem_rfcomm_lmp_dis_flag, len);
 10014b6:	003a      	movs	r2, r7
 10014b8:	e7f0      	b.n	100149c <_download_btcode+0x98>
          _dmacopy((byte *)addr, (byte *)btcode, len);
 10014ba:	003a      	movs	r2, r7
 10014bc:	0029      	movs	r1, r5
 10014be:	e7ed      	b.n	100149c <_download_btcode+0x98>
 10014c0:	000055aa 	.word	0x000055aa
 10014c4:	000f856c 	.word	0x000f856c
 10014c8:	ffffdfff 	.word	0xffffdfff
 10014cc:	000c8023 	.word	0x000c8023
 10014d0:	000c8024 	.word	0x000c8024
 10014d4:	000c8022 	.word	0x000c8022
 10014d8:	000f8e0c 	.word	0x000f8e0c
 10014dc:	000c8025 	.word	0x000c8025
 10014e0:	000c453d 	.word	0x000c453d
 10014e4:	000c4acf 	.word	0x000c4acf

010014e8 <erase_memory>:

//extern uint8_t BT_Wake;
extern const unsigned char bt_code[];

void erase_memory(void)
{
 10014e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10014ea:	24c0      	movs	r4, #192	; 0xc0
    for (uint32_t i = 0; i < 0x1000; i++)
 10014ec:	27c1      	movs	r7, #193	; 0xc1
    {
        *(volatile uint8_t *)(0xc0000 + i) = 0;
        delay_us(1);
 10014ee:	2501      	movs	r5, #1
{
 10014f0:	0324      	lsls	r4, r4, #12
    for (uint32_t i = 0; i < 0x1000; i++)
 10014f2:	033f      	lsls	r7, r7, #12
        *(volatile uint8_t *)(0xc0000 + i) = 0;
 10014f4:	2600      	movs	r6, #0
        delay_us(1);
 10014f6:	0028      	movs	r0, r5
        *(volatile uint8_t *)(0xc0000 + i) = 0;
 10014f8:	7026      	strb	r6, [r4, #0]
        delay_us(1);
 10014fa:	f7ff fc33 	bl	1000d64 <delay_us>
 10014fe:	2380      	movs	r3, #128	; 0x80
 1001500:	01db      	lsls	r3, r3, #7
 1001502:	18e3      	adds	r3, r4, r3
        *(volatile uint8_t *)(0xc4000 + i) = 0;
 1001504:	701e      	strb	r6, [r3, #0]
        delay_us(1);
 1001506:	0028      	movs	r0, r5
 1001508:	3401      	adds	r4, #1
 100150a:	f7ff fc2b 	bl	1000d64 <delay_us>
    for (uint32_t i = 0; i < 0x1000; i++)
 100150e:	42bc      	cmp	r4, r7
 1001510:	d1f0      	bne.n	10014f4 <erase_memory+0xc>
    }
}
 1001512:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01001514 <IpcInit>:

Boolean ipc_inited = FALSE;
void IpcInit(void)
{
#if (VERSIONS == EXIST_BT)
    if (ipc_inited == FALSE)
 1001514:	4b18      	ldr	r3, [pc, #96]	; (1001578 <IpcInit+0x64>)
{
 1001516:	b570      	push	{r4, r5, r6, lr}
    if (ipc_inited == FALSE)
 1001518:	781a      	ldrb	r2, [r3, #0]
 100151a:	2a00      	cmp	r2, #0
 100151c:	d12b      	bne.n	1001576 <IpcInit+0x62>
    NVIC_ICER = 1 << intid;
 100151e:	2180      	movs	r1, #128	; 0x80
    {
        disable_intr(INTR_BT);
        ipc_inited = TRUE;
 1001520:	2501      	movs	r5, #1
 1001522:	4a16      	ldr	r2, [pc, #88]	; (100157c <IpcInit+0x68>)
 1001524:	0109      	lsls	r1, r1, #4
 1001526:	6011      	str	r1, [r2, #0]
 1001528:	701d      	strb	r5, [r3, #0]
        SYSCTRL_ROM_SWITCH = 0x94;
 100152a:	2394      	movs	r3, #148	; 0x94
 100152c:	4c14      	ldr	r4, [pc, #80]	; (1001580 <IpcInit+0x6c>)
        //delay(10000);   //wait rom switch ok
        delay_ms(10);
 100152e:	200a      	movs	r0, #10
        SYSCTRL_ROM_SWITCH = 0x94;
 1001530:	7023      	strb	r3, [r4, #0]
        delay_ms(10);
 1001532:	f7ff fc1d 	bl	1000d70 <delay_ms>
        BT_RESET = 1;
 1001536:	4b13      	ldr	r3, [pc, #76]	; (1001584 <IpcInit+0x70>)
        //delay(10000);   //wait for reset ok
        delay_ms(1);
 1001538:	0028      	movs	r0, r5
        BT_RESET = 1;
 100153a:	701d      	strb	r5, [r3, #0]
        delay_ms(1);
 100153c:	f7ff fc18 	bl	1000d70 <delay_ms>
        while (!(BT_CONFIG & (1 << BT_INIT_FLAG)));
 1001540:	4b11      	ldr	r3, [pc, #68]	; (1001588 <IpcInit+0x74>)
 1001542:	781a      	ldrb	r2, [r3, #0]
 1001544:	b252      	sxtb	r2, r2
 1001546:	2a00      	cmp	r2, #0
 1001548:	dafb      	bge.n	1001542 <IpcInit+0x2e>
        BT_CONFIG &= (~(1 << BT_INIT_FLAG));
 100154a:	217f      	movs	r1, #127	; 0x7f
 100154c:	781a      	ldrb	r2, [r3, #0]
        lpm_bt_write(1, 0x00f20b0a);
 100154e:	2001      	movs	r0, #1
        BT_CONFIG &= (~(1 << BT_INIT_FLAG));
 1001550:	400a      	ands	r2, r1
 1001552:	701a      	strb	r2, [r3, #0]
        lpm_bt_write(1, 0x00f20b0a);
 1001554:	490d      	ldr	r1, [pc, #52]	; (100158c <IpcInit+0x78>)
 1001556:	f000 fb9b 	bl	1001c90 <lpm_bt_write>
        lpm_bt_write(0, 0x3084cf0f);
 100155a:	490d      	ldr	r1, [pc, #52]	; (1001590 <IpcInit+0x7c>)
 100155c:	2000      	movs	r0, #0
 100155e:	f000 fb97 	bl	1001c90 <lpm_bt_write>
        erase_memory();
 1001562:	f7ff ffc1 	bl	10014e8 <erase_memory>
        _download_btcode(bt_code);
 1001566:	480b      	ldr	r0, [pc, #44]	; (1001594 <IpcInit+0x80>)
 1001568:	f7ff ff4c 	bl	1001404 <_download_btcode>
        WAKEUP_BT = 0x9c;
 100156c:	239c      	movs	r3, #156	; 0x9c
        delay_ms(100);
 100156e:	2064      	movs	r0, #100	; 0x64
        WAKEUP_BT = 0x9c;
 1001570:	7023      	strb	r3, [r4, #0]
        delay_ms(100);
 1001572:	f7ff fbfd 	bl	1000d70 <delay_ms>
        BT_CONFIG &= (~(1 << BT_INIT_FLAG));
		lpm_bt_write(1, 0x00f20b0a);
        lpm_bt_write(0, 0x3084cf0f);
    }
#endif
}
 1001576:	bd70      	pop	{r4, r5, r6, pc}
 1001578:	00020245 	.word	0x00020245
 100157c:	e000e180 	.word	0xe000e180
 1001580:	000f853c 	.word	0x000f853c
 1001584:	000c8010 	.word	0x000c8010
 1001588:	000c8043 	.word	0x000c8043
 100158c:	00f20b0a 	.word	0x00f20b0a
 1001590:	3084cf0f 	.word	0x3084cf0f
 1001594:	0100425f 	.word	0x0100425f

01001598 <PrintHCIPack>:

//HCI
void PrintHCIPack(HCI_TypeDef *msg, const char *str)
{
 1001598:	b570      	push	{r4, r5, r6, lr}
 100159a:	000c      	movs	r4, r1
 100159c:	0005      	movs	r5, r0
    MyPrintf("M0 %s:\n", str);
 100159e:	481b      	ldr	r0, [pc, #108]	; (100160c <PrintHCIPack+0x74>)
 10015a0:	f7fe ff10 	bl	10003c4 <MyPrintf>
    MyPrintf("%s Type:%02x\n", str, msg->type);
 10015a4:	0021      	movs	r1, r4
 10015a6:	782a      	ldrb	r2, [r5, #0]
 10015a8:	4819      	ldr	r0, [pc, #100]	; (1001610 <PrintHCIPack+0x78>)
 10015aa:	f7fe ff0b 	bl	10003c4 <MyPrintf>
    MyPrintf("%s OPCode: %02x\n", str, msg->opcode);
 10015ae:	0021      	movs	r1, r4
 10015b0:	786a      	ldrb	r2, [r5, #1]
 10015b2:	4818      	ldr	r0, [pc, #96]	; (1001614 <PrintHCIPack+0x7c>)
 10015b4:	f7fe ff06 	bl	10003c4 <MyPrintf>
    MyPrintf("%s Length: %02x\n", str, msg->DataLen);
 10015b8:	0021      	movs	r1, r4
 10015ba:	78aa      	ldrb	r2, [r5, #2]
 10015bc:	4816      	ldr	r0, [pc, #88]	; (1001618 <PrintHCIPack+0x80>)
 10015be:	f7fe ff01 	bl	10003c4 <MyPrintf>
    MyPrintf("%s Data:\n", str);
 10015c2:	0021      	movs	r1, r4
 10015c4:	4815      	ldr	r0, [pc, #84]	; (100161c <PrintHCIPack+0x84>)
 10015c6:	f7fe fefd 	bl	10003c4 <MyPrintf>
    for (uint8_t cnt = 0; cnt < msg->DataLen; cnt++)
 10015ca:	2400      	movs	r4, #0
    {
        MyPrintf("%02x ", msg->p_data[cnt]);
        if ((cnt % 16) == 0&&cnt!=0)
 10015cc:	260f      	movs	r6, #15
    for (uint8_t cnt = 0; cnt < msg->DataLen; cnt++)
 10015ce:	78ab      	ldrb	r3, [r5, #2]
 10015d0:	42a3      	cmp	r3, r4
 10015d2:	d803      	bhi.n	10015dc <PrintHCIPack+0x44>
            MyPrintf("\n");
    }
    MyPrintf("\n");
 10015d4:	4812      	ldr	r0, [pc, #72]	; (1001620 <PrintHCIPack+0x88>)
 10015d6:	f7fe fef5 	bl	10003c4 <MyPrintf>
}
 10015da:	bd70      	pop	{r4, r5, r6, pc}
        MyPrintf("%02x ", msg->p_data[cnt]);
 10015dc:	792a      	ldrb	r2, [r5, #4]
 10015de:	78eb      	ldrb	r3, [r5, #3]
 10015e0:	0212      	lsls	r2, r2, #8
 10015e2:	431a      	orrs	r2, r3
 10015e4:	796b      	ldrb	r3, [r5, #5]
 10015e6:	480f      	ldr	r0, [pc, #60]	; (1001624 <PrintHCIPack+0x8c>)
 10015e8:	041b      	lsls	r3, r3, #16
 10015ea:	431a      	orrs	r2, r3
 10015ec:	79ab      	ldrb	r3, [r5, #6]
 10015ee:	061b      	lsls	r3, r3, #24
 10015f0:	4313      	orrs	r3, r2
 10015f2:	5d19      	ldrb	r1, [r3, r4]
 10015f4:	f7fe fee6 	bl	10003c4 <MyPrintf>
        if ((cnt % 16) == 0&&cnt!=0)
 10015f8:	4234      	tst	r4, r6
 10015fa:	d104      	bne.n	1001606 <PrintHCIPack+0x6e>
 10015fc:	2c00      	cmp	r4, #0
 10015fe:	d002      	beq.n	1001606 <PrintHCIPack+0x6e>
            MyPrintf("\n");
 1001600:	4807      	ldr	r0, [pc, #28]	; (1001620 <PrintHCIPack+0x88>)
 1001602:	f7fe fedf 	bl	10003c4 <MyPrintf>
    for (uint8_t cnt = 0; cnt < msg->DataLen; cnt++)
 1001606:	3401      	adds	r4, #1
 1001608:	b2e4      	uxtb	r4, r4
 100160a:	e7e0      	b.n	10015ce <PrintHCIPack+0x36>
 100160c:	01005551 	.word	0x01005551
 1001610:	01005559 	.word	0x01005559
 1001614:	01005567 	.word	0x01005567
 1001618:	01005578 	.word	0x01005578
 100161c:	01005589 	.word	0x01005589
 1001620:	01005858 	.word	0x01005858
 1001624:	01004259 	.word	0x01004259

01001628 <_dma_start.constprop.1>:
static void __NOINLINE _dma_start(int ch, const void *src, int srclen, void *dest, int dstlen)
 1001628:	b510      	push	{r4, lr}
    DMA_SRC_ADDR(ch)  = (int)src;
 100162a:	4c06      	ldr	r4, [pc, #24]	; (1001644 <_dma_start.constprop.1+0x1c>)
    DMA_LEN(ch)       = srclen << 16 | dstlen;
 100162c:	0409      	lsls	r1, r1, #16
    DMA_SRC_ADDR(ch)  = (int)src;
 100162e:	6020      	str	r0, [r4, #0]
    DMA_DEST_ADDR(ch) = (int)dest;
 1001630:	4805      	ldr	r0, [pc, #20]	; (1001648 <_dma_start.constprop.1+0x20>)
    DMA_LEN(ch)       = srclen << 16 | dstlen;
 1001632:	430b      	orrs	r3, r1
    DMA_DEST_ADDR(ch) = (int)dest;
 1001634:	6002      	str	r2, [r0, #0]
    DMA_LEN(ch)       = srclen << 16 | dstlen;
 1001636:	4a05      	ldr	r2, [pc, #20]	; (100164c <_dma_start.constprop.1+0x24>)
 1001638:	6013      	str	r3, [r2, #0]
    DMA_START(ch)     = 0x80;
 100163a:	2280      	movs	r2, #128	; 0x80
 100163c:	4b04      	ldr	r3, [pc, #16]	; (1001650 <_dma_start.constprop.1+0x28>)
 100163e:	701a      	strb	r2, [r3, #0]
}
 1001640:	bd10      	pop	{r4, pc}
 1001642:	46c0      	nop			; (mov r8, r8)
 1001644:	000f8e00 	.word	0x000f8e00
 1001648:	000f8e04 	.word	0x000f8e04
 100164c:	000f8e08 	.word	0x000f8e08
 1001650:	000f8e0f 	.word	0x000f8e0f

01001654 <UART_AutoFlowCtrlCmd>:

#define Set_RxITNum_Mask    0xff00
#define Statu_RxNum_Mask    (uint32_t)0xffff0000

void UART_AutoFlowCtrlCmd(UART_TypeDef UARTx, FunctionalState NewState)
{
 1001654:	b570      	push	{r4, r5, r6, lr}
 1001656:	0004      	movs	r4, r0
 1001658:	000d      	movs	r5, r1
    _ASSERT(IS_UART(UARTx));
 100165a:	2801      	cmp	r0, #1
 100165c:	d904      	bls.n	1001668 <UART_AutoFlowCtrlCmd+0x14>
 100165e:	4a0f      	ldr	r2, [pc, #60]	; (100169c <UART_AutoFlowCtrlCmd+0x48>)
 1001660:	211c      	movs	r1, #28
 1001662:	480f      	ldr	r0, [pc, #60]	; (10016a0 <UART_AutoFlowCtrlCmd+0x4c>)
 1001664:	f7fe ffca 	bl	10005fc <_assert_handler>

    if (NewState == ENABLE)
 1001668:	2d01      	cmp	r5, #1
 100166a:	d10c      	bne.n	1001686 <UART_AutoFlowCtrlCmd+0x32>
    {
        switch (UARTx)
 100166c:	2c00      	cmp	r4, #0
 100166e:	d002      	beq.n	1001676 <UART_AutoFlowCtrlCmd+0x22>
 1001670:	2c01      	cmp	r4, #1
 1001672:	d006      	beq.n	1001682 <UART_AutoFlowCtrlCmd+0x2e>
            UART1_CTRL &= (~FlowCtrl_Enable);
            break;
        }
    }
    return;
}
 1001674:	bd70      	pop	{r4, r5, r6, pc}
            UART0_CTRL |= FlowCtrl_Enable;
 1001676:	4a0b      	ldr	r2, [pc, #44]	; (10016a4 <UART_AutoFlowCtrlCmd+0x50>)
            UART1_CTRL |= FlowCtrl_Enable;
 1001678:	2310      	movs	r3, #16
 100167a:	6811      	ldr	r1, [r2, #0]
 100167c:	430b      	orrs	r3, r1
            UART1_CTRL &= (~FlowCtrl_Enable);
 100167e:	6013      	str	r3, [r2, #0]
    return;
 1001680:	e7f8      	b.n	1001674 <UART_AutoFlowCtrlCmd+0x20>
            UART1_CTRL |= FlowCtrl_Enable;
 1001682:	4a09      	ldr	r2, [pc, #36]	; (10016a8 <UART_AutoFlowCtrlCmd+0x54>)
 1001684:	e7f8      	b.n	1001678 <UART_AutoFlowCtrlCmd+0x24>
        switch (UARTx)
 1001686:	2c00      	cmp	r4, #0
 1001688:	d003      	beq.n	1001692 <UART_AutoFlowCtrlCmd+0x3e>
 100168a:	2c01      	cmp	r4, #1
 100168c:	d1f2      	bne.n	1001674 <UART_AutoFlowCtrlCmd+0x20>
            UART1_CTRL &= (~FlowCtrl_Enable);
 100168e:	4a06      	ldr	r2, [pc, #24]	; (10016a8 <UART_AutoFlowCtrlCmd+0x54>)
 1001690:	e000      	b.n	1001694 <UART_AutoFlowCtrlCmd+0x40>
            UART0_CTRL &= (~FlowCtrl_Enable);
 1001692:	4a04      	ldr	r2, [pc, #16]	; (10016a4 <UART_AutoFlowCtrlCmd+0x50>)
            UART1_CTRL &= (~FlowCtrl_Enable);
 1001694:	2110      	movs	r1, #16
 1001696:	6813      	ldr	r3, [r2, #0]
 1001698:	438b      	bics	r3, r1
 100169a:	e7f0      	b.n	100167e <UART_AutoFlowCtrlCmd+0x2a>
 100169c:	010055ba 	.word	0x010055ba
 10016a0:	01005593 	.word	0x01005593
 10016a4:	000f8b1c 	.word	0x000f8b1c
 10016a8:	000f8c1c 	.word	0x000f8c1c

010016ac <UART_ClearIT>:

void UART_ClearIT(UART_TypeDef UARTx)
{
 10016ac:	b510      	push	{r4, lr}
 10016ae:	0004      	movs	r4, r0
    uint8_t ITType = UART_GetITIdentity(UARTx);
 10016b0:	f000 f860 	bl	1001774 <UART_GetITIdentity>
    UART_ITConfig(UARTx, ITType, DISABLE);
 10016b4:	2200      	movs	r2, #0
    uint8_t ITType = UART_GetITIdentity(UARTx);
 10016b6:	0001      	movs	r1, r0
    UART_ITConfig(UARTx, ITType, DISABLE);
 10016b8:	0020      	movs	r0, r4
 10016ba:	f000 f96d 	bl	1001998 <UART_ITConfig>
}
 10016be:	bd10      	pop	{r4, pc}

010016c0 <UART_DeInit>:

void UART_DeInit(UART_TypeDef  UARTx)
{
 10016c0:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 10016c2:	2801      	cmp	r0, #1
 10016c4:	d905      	bls.n	10016d2 <UART_DeInit+0x12>
 10016c6:	4a07      	ldr	r2, [pc, #28]	; (10016e4 <UART_DeInit+0x24>)
 10016c8:	2141      	movs	r1, #65	; 0x41
 10016ca:	4807      	ldr	r0, [pc, #28]	; (10016e8 <UART_DeInit+0x28>)
 10016cc:	f7fe ff96 	bl	10005fc <_assert_handler>
        break;
    case UART1:
        UART1_CTRL = 0;
        break;
    }
}
 10016d0:	bd10      	pop	{r4, pc}
 10016d2:	2300      	movs	r3, #0
    switch (UARTx)
 10016d4:	2801      	cmp	r0, #1
 10016d6:	d002      	beq.n	10016de <UART_DeInit+0x1e>
        UART0_CTRL = 0;
 10016d8:	4a04      	ldr	r2, [pc, #16]	; (10016ec <UART_DeInit+0x2c>)
        UART1_CTRL = 0;
 10016da:	6013      	str	r3, [r2, #0]
}
 10016dc:	e7f8      	b.n	10016d0 <UART_DeInit+0x10>
        UART1_CTRL = 0;
 10016de:	4a04      	ldr	r2, [pc, #16]	; (10016f0 <UART_DeInit+0x30>)
 10016e0:	e7fb      	b.n	10016da <UART_DeInit+0x1a>
 10016e2:	46c0      	nop			; (mov r8, r8)
 10016e4:	010055cf 	.word	0x010055cf
 10016e8:	01005593 	.word	0x01005593
 10016ec:	000f8b1c 	.word	0x000f8b1c
 10016f0:	000f8c1c 	.word	0x000f8c1c

010016f4 <UART_DMASendBuf>:

void UART_DMASendBuf(UART_TypeDef UARTx, uint8_t *buf, int len)
{
 10016f4:	b570      	push	{r4, r5, r6, lr}
 10016f6:	0005      	movs	r5, r0
 10016f8:	000c      	movs	r4, r1
 10016fa:	0016      	movs	r6, r2
    _ASSERT(IS_UART(UARTx));
 10016fc:	2801      	cmp	r0, #1
 10016fe:	d904      	bls.n	100170a <UART_DMASendBuf+0x16>
 1001700:	4a14      	ldr	r2, [pc, #80]	; (1001754 <UART_DMASendBuf+0x60>)
 1001702:	2150      	movs	r1, #80	; 0x50
 1001704:	4814      	ldr	r0, [pc, #80]	; (1001758 <UART_DMASendBuf+0x64>)
 1001706:	f7fe ff79 	bl	10005fc <_assert_handler>
    _ASSERT(NULL != buf);
 100170a:	2c00      	cmp	r4, #0
 100170c:	d104      	bne.n	1001718 <UART_DMASendBuf+0x24>
 100170e:	4a11      	ldr	r2, [pc, #68]	; (1001754 <UART_DMASendBuf+0x60>)
 1001710:	2151      	movs	r1, #81	; 0x51
 1001712:	4811      	ldr	r0, [pc, #68]	; (1001758 <UART_DMASendBuf+0x64>)
 1001714:	f7fe ff72 	bl	10005fc <_assert_handler>
    _ASSERT((len < 0xffff));
 1001718:	4b10      	ldr	r3, [pc, #64]	; (100175c <UART_DMASendBuf+0x68>)
 100171a:	429e      	cmp	r6, r3
 100171c:	dd04      	ble.n	1001728 <UART_DMASendBuf+0x34>
 100171e:	4a0d      	ldr	r2, [pc, #52]	; (1001754 <UART_DMASendBuf+0x60>)
 1001720:	2152      	movs	r1, #82	; 0x52
 1001722:	480d      	ldr	r0, [pc, #52]	; (1001758 <UART_DMASendBuf+0x64>)
 1001724:	f7fe ff6a 	bl	10005fc <_assert_handler>
 1001728:	0436      	lsls	r6, r6, #16
 100172a:	480d      	ldr	r0, [pc, #52]	; (1001760 <UART_DMASendBuf+0x6c>)

    if (UARTx == UART0)
 100172c:	2d00      	cmp	r5, #0
 100172e:	d109      	bne.n	1001744 <UART_DMASendBuf+0x50>
    {
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001730:	4b0c      	ldr	r3, [pc, #48]	; (1001764 <UART_DMASendBuf+0x70>)
 1001732:	601c      	str	r4, [r3, #0]
        DMA_LEN(DMACH_UART0) = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1001734:	4b0c      	ldr	r3, [pc, #48]	; (1001768 <UART_DMASendBuf+0x74>)
 1001736:	681a      	ldr	r2, [r3, #0]
 1001738:	b292      	uxth	r2, r2
 100173a:	4332      	orrs	r2, r6
 100173c:	601a      	str	r2, [r3, #0]
    }
    else
    {
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
        DMA_LEN(DMACH_UART1) = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
        DMA_START(DMACH_UART0) = (1 << DMA_START_BIT);
 100173e:	2380      	movs	r3, #128	; 0x80
 1001740:	7003      	strb	r3, [r0, #0]
    }
}
 1001742:	bd70      	pop	{r4, r5, r6, pc}
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1001744:	4b09      	ldr	r3, [pc, #36]	; (100176c <UART_DMASendBuf+0x78>)
 1001746:	601c      	str	r4, [r3, #0]
        DMA_LEN(DMACH_UART1) = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1001748:	4c09      	ldr	r4, [pc, #36]	; (1001770 <UART_DMASendBuf+0x7c>)
 100174a:	6822      	ldr	r2, [r4, #0]
 100174c:	b292      	uxth	r2, r2
 100174e:	4332      	orrs	r2, r6
 1001750:	6022      	str	r2, [r4, #0]
 1001752:	e7f4      	b.n	100173e <UART_DMASendBuf+0x4a>
 1001754:	010055db 	.word	0x010055db
 1001758:	01005593 	.word	0x01005593
 100175c:	0000fffe 	.word	0x0000fffe
 1001760:	000f8b0f 	.word	0x000f8b0f
 1001764:	000f8b00 	.word	0x000f8b00
 1001768:	000f8b08 	.word	0x000f8b08
 100176c:	000f8c00 	.word	0x000f8c00
 1001770:	000f8c08 	.word	0x000f8c08

01001774 <UART_GetITIdentity>:

uint8_t UART_GetITIdentity(UART_TypeDef UARTx)
{
    uint8_t IT_Mode = 0;
    switch (UARTx)
 1001774:	2800      	cmp	r0, #0
 1001776:	d003      	beq.n	1001780 <UART_GetITIdentity+0xc>
 1001778:	2801      	cmp	r0, #1
 100177a:	d010      	beq.n	100179e <UART_GetITIdentity+0x2a>
    uint8_t IT_Mode = 0;
 100177c:	2000      	movs	r0, #0
 100177e:	e00d      	b.n	100179c <UART_GetITIdentity+0x28>
    {
    case UART0:
    {
        if (((UART0_CTRL & Set_RxITNum_Mask) > 0) && ((UART0_STATUS >> 16) > 0))
 1001780:	22ff      	movs	r2, #255	; 0xff
 1001782:	4b0b      	ldr	r3, [pc, #44]	; (10017b0 <UART_GetITIdentity+0x3c>)
 1001784:	0212      	lsls	r2, r2, #8
 1001786:	6819      	ldr	r1, [r3, #0]
 1001788:	4211      	tst	r1, r2
 100178a:	d005      	beq.n	1001798 <UART_GetITIdentity+0x24>
 100178c:	4a09      	ldr	r2, [pc, #36]	; (10017b4 <UART_GetITIdentity+0x40>)
    }
    break;

    case UART1:
    {
        if (((UART1_CTRL & Set_RxITNum_Mask) > 0) && ((UART1_STATUS >> 16) > 0))
 100178e:	6812      	ldr	r2, [r2, #0]
            IT_Mode =  UART_IT_RX;
 1001790:	2002      	movs	r0, #2
        if (((UART1_CTRL & Set_RxITNum_Mask) > 0) && ((UART1_STATUS >> 16) > 0))
 1001792:	1412      	asrs	r2, r2, #16
 1001794:	2a00      	cmp	r2, #0
 1001796:	dc01      	bgt.n	100179c <UART_GetITIdentity+0x28>
        {
            IT_Mode =  UART_IT_RX;
        }
        else
        {
            if (UART1_CTRL & TX_INTR_ENABLE)
 1001798:	6818      	ldr	r0, [r3, #0]
    uint8_t IT_Mode = 0;
 100179a:	0fc0      	lsrs	r0, r0, #31
        }
    }
    break;
    }
    return IT_Mode;
}
 100179c:	4770      	bx	lr
        if (((UART1_CTRL & Set_RxITNum_Mask) > 0) && ((UART1_STATUS >> 16) > 0))
 100179e:	22ff      	movs	r2, #255	; 0xff
 10017a0:	4b05      	ldr	r3, [pc, #20]	; (10017b8 <UART_GetITIdentity+0x44>)
 10017a2:	0212      	lsls	r2, r2, #8
 10017a4:	6819      	ldr	r1, [r3, #0]
 10017a6:	4211      	tst	r1, r2
 10017a8:	d0f6      	beq.n	1001798 <UART_GetITIdentity+0x24>
 10017aa:	4a04      	ldr	r2, [pc, #16]	; (10017bc <UART_GetITIdentity+0x48>)
 10017ac:	e7ef      	b.n	100178e <UART_GetITIdentity+0x1a>
 10017ae:	46c0      	nop			; (mov r8, r8)
 10017b0:	000f8b1c 	.word	0x000f8b1c
 10017b4:	000f8b28 	.word	0x000f8b28
 10017b8:	000f8c1c 	.word	0x000f8c1c
 10017bc:	000f8c28 	.word	0x000f8c28

010017c0 <UART_Init>:

void UART_Init(UART_TypeDef UARTx, UART_InitTypeDef *UART_InitStruct)
{
 10017c0:	b570      	push	{r4, r5, r6, lr}
 10017c2:	0005      	movs	r5, r0
 10017c4:	000e      	movs	r6, r1
#define RESET_BAUD (1<<7)
#define AUTO_BAUD  (0<<7)
    uint32_t reg_value = 0;
    uint32_t temp_baudrate = 0;

    _ASSERT(IS_UART(UARTx));
 10017c6:	2801      	cmp	r0, #1
 10017c8:	d904      	bls.n	10017d4 <UART_Init+0x14>
 10017ca:	4a3a      	ldr	r2, [pc, #232]	; (10018b4 <UART_Init+0xf4>)
 10017cc:	219a      	movs	r1, #154	; 0x9a
 10017ce:	483a      	ldr	r0, [pc, #232]	; (10018b8 <UART_Init+0xf8>)
 10017d0:	f7fe ff14 	bl	10005fc <_assert_handler>
    _ASSERT(IS_MODE(UART_InitStruct->Mode));
 10017d4:	2240      	movs	r2, #64	; 0x40
 10017d6:	7833      	ldrb	r3, [r6, #0]
 10017d8:	4393      	bics	r3, r2
 10017da:	d004      	beq.n	10017e6 <UART_Init+0x26>
 10017dc:	4a35      	ldr	r2, [pc, #212]	; (10018b4 <UART_Init+0xf4>)
 10017de:	219b      	movs	r1, #155	; 0x9b
 10017e0:	4835      	ldr	r0, [pc, #212]	; (10018b8 <UART_Init+0xf8>)
 10017e2:	f7fe ff0b 	bl	10005fc <_assert_handler>
    _ASSERT(IS_BAUDRATE(UART_InitStruct->BaudRate));
 10017e6:	4a35      	ldr	r2, [pc, #212]	; (10018bc <UART_Init+0xfc>)
 10017e8:	6873      	ldr	r3, [r6, #4]
 10017ea:	189b      	adds	r3, r3, r2
 10017ec:	4a34      	ldr	r2, [pc, #208]	; (10018c0 <UART_Init+0x100>)
 10017ee:	4293      	cmp	r3, r2
 10017f0:	d904      	bls.n	10017fc <UART_Init+0x3c>
 10017f2:	4a30      	ldr	r2, [pc, #192]	; (10018b4 <UART_Init+0xf4>)
 10017f4:	219c      	movs	r1, #156	; 0x9c
 10017f6:	4830      	ldr	r0, [pc, #192]	; (10018b8 <UART_Init+0xf8>)
 10017f8:	f7fe ff00 	bl	10005fc <_assert_handler>
    _ASSERT(IS_PARITY(UART_InitStruct->Parity));
 10017fc:	2202      	movs	r2, #2
 10017fe:	7ab3      	ldrb	r3, [r6, #10]
 1001800:	4393      	bics	r3, r2
 1001802:	d004      	beq.n	100180e <UART_Init+0x4e>
 1001804:	4a2b      	ldr	r2, [pc, #172]	; (10018b4 <UART_Init+0xf4>)
 1001806:	219d      	movs	r1, #157	; 0x9d
 1001808:	482b      	ldr	r0, [pc, #172]	; (10018b8 <UART_Init+0xf8>)
 100180a:	f7fe fef7 	bl	10005fc <_assert_handler>
    _ASSERT(IS_FlowCtrl(UART_InitStruct->FlowCtrl));
 100180e:	2210      	movs	r2, #16
 1001810:	7af3      	ldrb	r3, [r6, #11]
 1001812:	4393      	bics	r3, r2
 1001814:	d004      	beq.n	1001820 <UART_Init+0x60>
 1001816:	4a27      	ldr	r2, [pc, #156]	; (10018b4 <UART_Init+0xf4>)
 1001818:	219e      	movs	r1, #158	; 0x9e
 100181a:	4827      	ldr	r0, [pc, #156]	; (10018b8 <UART_Init+0xf8>)
 100181c:	f7fe feee 	bl	10005fc <_assert_handler>
    _ASSERT(IS_USART_STOPBITS(UART_InitStruct->StopBits));
 1001820:	2208      	movs	r2, #8
 1001822:	7a73      	ldrb	r3, [r6, #9]
 1001824:	4393      	bics	r3, r2
 1001826:	d004      	beq.n	1001832 <UART_Init+0x72>
 1001828:	4a22      	ldr	r2, [pc, #136]	; (10018b4 <UART_Init+0xf4>)
 100182a:	219f      	movs	r1, #159	; 0x9f
 100182c:	4822      	ldr	r0, [pc, #136]	; (10018b8 <UART_Init+0xf8>)
 100182e:	f7fe fee5 	bl	10005fc <_assert_handler>
    reg_value = RX_ENABLE                |
                UART_InitStruct->Parity  | \
                UART_InitStruct->DataBits | \
                UART_InitStruct->StopBits | \
                UART_InitStruct->FlowCtrl | \
                UART_InitStruct->Mode    | \
 1001832:	7ab0      	ldrb	r0, [r6, #10]
 1001834:	7a34      	ldrb	r4, [r6, #8]
    temp_baudrate = ((48000000 / UART_InitStruct->BaudRate) << 16);
 1001836:	6871      	ldr	r1, [r6, #4]
                UART_InitStruct->Mode    | \
 1001838:	4304      	orrs	r4, r0
 100183a:	207f      	movs	r0, #127	; 0x7f
 100183c:	4240      	negs	r0, r0
 100183e:	4320      	orrs	r0, r4
 1001840:	7a74      	ldrb	r4, [r6, #9]
 1001842:	4320      	orrs	r0, r4
 1001844:	7af4      	ldrb	r4, [r6, #11]
 1001846:	4320      	orrs	r0, r4
 1001848:	7834      	ldrb	r4, [r6, #0]
 100184a:	4304      	orrs	r4, r0
    temp_baudrate = ((48000000 / UART_InitStruct->BaudRate) << 16);
 100184c:	481d      	ldr	r0, [pc, #116]	; (10018c4 <UART_Init+0x104>)
 100184e:	f002 fb6d 	bl	1003f2c <__udivsi3>
 1001852:	2380      	movs	r3, #128	; 0x80
                UART_InitStruct->Mode    | \
 1001854:	b2e4      	uxtb	r4, r4
    temp_baudrate = ((48000000 / UART_InitStruct->BaudRate) << 16);
 1001856:	0400      	lsls	r0, r0, #16
    reg_value = RX_ENABLE                |
 1001858:	4320      	orrs	r0, r4
 100185a:	00db      	lsls	r3, r3, #3
                RESET_BAUD               | \
                temp_baudrate;

    if (UARTx == UART0)
 100185c:	2d00      	cmp	r5, #0
 100185e:	d114      	bne.n	100188a <UART_Init+0xca>
    {
        UART0_CTRL                 = 0;
 1001860:	4a19      	ldr	r2, [pc, #100]	; (10018c8 <UART_Init+0x108>)
        DMA_DEST_ADDR(DMACH_UART0) = (int)uart0_DMA_buf;
 1001862:	4c1a      	ldr	r4, [pc, #104]	; (10018cc <UART_Init+0x10c>)
 1001864:	491a      	ldr	r1, [pc, #104]	; (10018d0 <UART_Init+0x110>)
        UART0_CTRL                 = 0;
 1001866:	6015      	str	r5, [r2, #0]
        DMA_DEST_ADDR(DMACH_UART0) = (int)uart0_DMA_buf;
 1001868:	600c      	str	r4, [r1, #0]
        DMA_LEN(DMACH_UART0)       = uart_DMA_buf_len;
 100186a:	491a      	ldr	r1, [pc, #104]	; (10018d4 <UART_Init+0x114>)
        DMA_CONFIG(DMACH_UART0)    = 1;
        DMA_START(DMACH_UART0)    |= (1 << (DMA_RESET_BIT));
 100186c:	2420      	movs	r4, #32
        DMA_LEN(DMACH_UART0)       = uart_DMA_buf_len;
 100186e:	600b      	str	r3, [r1, #0]
        DMA_CONFIG(DMACH_UART0)    = 1;
 1001870:	2101      	movs	r1, #1
 1001872:	4b19      	ldr	r3, [pc, #100]	; (10018d8 <UART_Init+0x118>)
 1001874:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART0)    |= (1 << (DMA_RESET_BIT));
 1001876:	4b19      	ldr	r3, [pc, #100]	; (10018dc <UART_Init+0x11c>)
 1001878:	7819      	ldrb	r1, [r3, #0]
 100187a:	4321      	orrs	r1, r4
 100187c:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART0)    &= ~(1 << (DMA_RESET_BIT));
 100187e:	7819      	ldrb	r1, [r3, #0]
 1001880:	43a1      	bics	r1, r4
 1001882:	7019      	strb	r1, [r3, #0]
        UART0_CTRL                 = 0;
 1001884:	6015      	str	r5, [r2, #0]
        DMA_LEN(DMACH_UART1)       = uart_DMA_buf_len;
        DMA_CONFIG(DMACH_UART1)    = 1;
        DMA_START(DMACH_UART1)    |= (1 << (DMA_RESET_BIT));
        DMA_START(DMACH_UART1)    &= ~(1 << (DMA_RESET_BIT));
        UART1_CTRL                 = 0;
        UART1_CTRL                 = reg_value;
 1001886:	6010      	str	r0, [r2, #0]
    }
    return;
}
 1001888:	bd70      	pop	{r4, r5, r6, pc}
        UART1_CTRL                 = 0;
 100188a:	2400      	movs	r4, #0
 100188c:	4a14      	ldr	r2, [pc, #80]	; (10018e0 <UART_Init+0x120>)
        DMA_DEST_ADDR(DMACH_UART1) = (int)uart1_DMA_buf;
 100188e:	4d15      	ldr	r5, [pc, #84]	; (10018e4 <UART_Init+0x124>)
 1001890:	4915      	ldr	r1, [pc, #84]	; (10018e8 <UART_Init+0x128>)
        UART1_CTRL                 = 0;
 1001892:	6014      	str	r4, [r2, #0]
        DMA_DEST_ADDR(DMACH_UART1) = (int)uart1_DMA_buf;
 1001894:	600d      	str	r5, [r1, #0]
        DMA_LEN(DMACH_UART1)       = uart_DMA_buf_len;
 1001896:	4915      	ldr	r1, [pc, #84]	; (10018ec <UART_Init+0x12c>)
        DMA_START(DMACH_UART1)    |= (1 << (DMA_RESET_BIT));
 1001898:	2520      	movs	r5, #32
        DMA_LEN(DMACH_UART1)       = uart_DMA_buf_len;
 100189a:	600b      	str	r3, [r1, #0]
        DMA_CONFIG(DMACH_UART1)    = 1;
 100189c:	2101      	movs	r1, #1
 100189e:	4b14      	ldr	r3, [pc, #80]	; (10018f0 <UART_Init+0x130>)
 10018a0:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART1)    |= (1 << (DMA_RESET_BIT));
 10018a2:	4b14      	ldr	r3, [pc, #80]	; (10018f4 <UART_Init+0x134>)
 10018a4:	7819      	ldrb	r1, [r3, #0]
 10018a6:	4329      	orrs	r1, r5
 10018a8:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART1)    &= ~(1 << (DMA_RESET_BIT));
 10018aa:	7819      	ldrb	r1, [r3, #0]
 10018ac:	43a9      	bics	r1, r5
 10018ae:	7019      	strb	r1, [r3, #0]
        UART1_CTRL                 = 0;
 10018b0:	6014      	str	r4, [r2, #0]
 10018b2:	e7e8      	b.n	1001886 <UART_Init+0xc6>
 10018b4:	010055eb 	.word	0x010055eb
 10018b8:	01005593 	.word	0x01005593
 10018bc:	fffffa47 	.word	0xfffffa47
 10018c0:	0044a467 	.word	0x0044a467
 10018c4:	02dc6c00 	.word	0x02dc6c00
 10018c8:	000f8b1c 	.word	0x000f8b1c
 10018cc:	00020246 	.word	0x00020246
 10018d0:	000f8b04 	.word	0x000f8b04
 10018d4:	000f8b08 	.word	0x000f8b08
 10018d8:	000f8b0c 	.word	0x000f8b0c
 10018dc:	000f8b0f 	.word	0x000f8b0f
 10018e0:	000f8c1c 	.word	0x000f8c1c
 10018e4:	00020646 	.word	0x00020646
 10018e8:	000f8c04 	.word	0x000f8c04
 10018ec:	000f8c08 	.word	0x000f8c08
 10018f0:	000f8c0c 	.word	0x000f8c0c
 10018f4:	000f8c0f 	.word	0x000f8c0f

010018f8 <UART_IsRXFIFOFull>:

Boolean UART_IsRXFIFOFull(UART_TypeDef UARTx)
{
 10018f8:	b510      	push	{r4, lr}
#define BITRXFULL 1
    _ASSERT(IS_UART(UARTx));
 10018fa:	2801      	cmp	r0, #1
 10018fc:	d906      	bls.n	100190c <UART_IsRXFIFOFull+0x14>
 10018fe:	4a07      	ldr	r2, [pc, #28]	; (100191c <UART_IsRXFIFOFull+0x24>)
 1001900:	21c8      	movs	r1, #200	; 0xc8
 1001902:	4807      	ldr	r0, [pc, #28]	; (1001920 <UART_IsRXFIFOFull+0x28>)
 1001904:	f7fe fe7a 	bl	10005fc <_assert_handler>
    {
        return (Boolean)(UART0_STATUS & (1 << BITRXFULL));
    }
    else
    {
        return (Boolean)(UART1_STATUS & (1 << BITRXFULL));
 1001908:	4b06      	ldr	r3, [pc, #24]	; (1001924 <UART_IsRXFIFOFull+0x2c>)
 100190a:	e002      	b.n	1001912 <UART_IsRXFIFOFull+0x1a>
    if (UART0 == UARTx)
 100190c:	2800      	cmp	r0, #0
 100190e:	d1fb      	bne.n	1001908 <UART_IsRXFIFOFull+0x10>
        return (Boolean)(UART0_STATUS & (1 << BITRXFULL));
 1001910:	4b05      	ldr	r3, [pc, #20]	; (1001928 <UART_IsRXFIFOFull+0x30>)
        return (Boolean)(UART1_STATUS & (1 << BITRXFULL));
 1001912:	6818      	ldr	r0, [r3, #0]
 1001914:	2302      	movs	r3, #2
 1001916:	4018      	ands	r0, r3
    }
}
 1001918:	bd10      	pop	{r4, pc}
 100191a:	46c0      	nop			; (mov r8, r8)
 100191c:	010055f5 	.word	0x010055f5
 1001920:	01005593 	.word	0x01005593
 1001924:	000f8c28 	.word	0x000f8c28
 1001928:	000f8b28 	.word	0x000f8b28

0100192c <UART_IsRXFIFONotEmpty>:

Boolean UART_IsRXFIFONotEmpty(UART_TypeDef  UARTx)
{
 100192c:	b510      	push	{r4, lr}
#define BITRXEMPTY 0
    _ASSERT(IS_UART(UARTx));
 100192e:	2801      	cmp	r0, #1
 1001930:	d906      	bls.n	1001940 <UART_IsRXFIFONotEmpty+0x14>
 1001932:	4a08      	ldr	r2, [pc, #32]	; (1001954 <UART_IsRXFIFONotEmpty+0x28>)
 1001934:	21d7      	movs	r1, #215	; 0xd7
 1001936:	4808      	ldr	r0, [pc, #32]	; (1001958 <UART_IsRXFIFONotEmpty+0x2c>)
 1001938:	f7fe fe60 	bl	10005fc <_assert_handler>
    {
        return (Boolean)((UART0_STATUS >> 16) ? 1 : 0);
    }
    else
    {
        return (Boolean)((UART1_STATUS >> 16) ? 1 : 0);
 100193c:	4b07      	ldr	r3, [pc, #28]	; (100195c <UART_IsRXFIFONotEmpty+0x30>)
 100193e:	e002      	b.n	1001946 <UART_IsRXFIFONotEmpty+0x1a>
    if (UART0 == UARTx)
 1001940:	2800      	cmp	r0, #0
 1001942:	d1fb      	bne.n	100193c <UART_IsRXFIFONotEmpty+0x10>
        return (Boolean)((UART0_STATUS >> 16) ? 1 : 0);
 1001944:	4b06      	ldr	r3, [pc, #24]	; (1001960 <UART_IsRXFIFONotEmpty+0x34>)
        return (Boolean)((UART1_STATUS >> 16) ? 1 : 0);
 1001946:	6818      	ldr	r0, [r3, #0]
 1001948:	1400      	asrs	r0, r0, #16
 100194a:	1e43      	subs	r3, r0, #1
 100194c:	4198      	sbcs	r0, r3
        return (Boolean)((UART0_STATUS >> 16) ? 1 : 0);
 100194e:	b2c0      	uxtb	r0, r0
    }
}
 1001950:	bd10      	pop	{r4, pc}
 1001952:	46c0      	nop			; (mov r8, r8)
 1001954:	01005607 	.word	0x01005607
 1001958:	01005593 	.word	0x01005593
 100195c:	000f8c28 	.word	0x000f8c28
 1001960:	000f8b28 	.word	0x000f8b28

01001964 <UART_IsUARTBusy>:

Boolean UART_IsUARTBusy(UART_TypeDef  UARTx)
{
 1001964:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1001966:	2801      	cmp	r0, #1
 1001968:	d906      	bls.n	1001978 <UART_IsUARTBusy+0x14>
 100196a:	4a07      	ldr	r2, [pc, #28]	; (1001988 <UART_IsUARTBusy+0x24>)
 100196c:	21e5      	movs	r1, #229	; 0xe5
 100196e:	4807      	ldr	r0, [pc, #28]	; (100198c <UART_IsUARTBusy+0x28>)
 1001970:	f7fe fe44 	bl	10005fc <_assert_handler>
    {
        return (Boolean)(!(DMA_STATUS(DMACH_UART0) & 1));
    }
    else
    {
        return (Boolean)(!(DMA_STATUS(DMACH_UART1) & 1));
 1001974:	4b06      	ldr	r3, [pc, #24]	; (1001990 <UART_IsUARTBusy+0x2c>)
 1001976:	e002      	b.n	100197e <UART_IsUARTBusy+0x1a>
    if (UART0 == UARTx)
 1001978:	2800      	cmp	r0, #0
 100197a:	d1fb      	bne.n	1001974 <UART_IsUARTBusy+0x10>
        return (Boolean)(!(DMA_STATUS(DMACH_UART0) & 1));
 100197c:	4b05      	ldr	r3, [pc, #20]	; (1001994 <UART_IsUARTBusy+0x30>)
        return (Boolean)(!(DMA_STATUS(DMACH_UART1) & 1));
 100197e:	2001      	movs	r0, #1
 1001980:	681b      	ldr	r3, [r3, #0]
 1001982:	4398      	bics	r0, r3
    }
}
 1001984:	bd10      	pop	{r4, pc}
 1001986:	46c0      	nop			; (mov r8, r8)
 1001988:	0100561d 	.word	0x0100561d
 100198c:	01005593 	.word	0x01005593
 1001990:	000f8c10 	.word	0x000f8c10
 1001994:	000f8b10 	.word	0x000f8b10

01001998 <UART_ITConfig>:

void UART_ITConfig(UART_TypeDef UARTx, uint32_t UART_IT, FunctionalState NewState)
{
 1001998:	b570      	push	{r4, r5, r6, lr}
 100199a:	0006      	movs	r6, r0
 100199c:	000d      	movs	r5, r1
 100199e:	0014      	movs	r4, r2
    _ASSERT(IS_UART(UARTx));
 10019a0:	2801      	cmp	r0, #1
 10019a2:	d904      	bls.n	10019ae <UART_ITConfig+0x16>
 10019a4:	4a1a      	ldr	r2, [pc, #104]	; (1001a10 <UART_ITConfig+0x78>)
 10019a6:	21f3      	movs	r1, #243	; 0xf3
 10019a8:	481a      	ldr	r0, [pc, #104]	; (1001a14 <UART_ITConfig+0x7c>)
 10019aa:	f7fe fe27 	bl	10005fc <_assert_handler>
    _ASSERT(IS_UART_IT(UART_IT));
 10019ae:	1e6b      	subs	r3, r5, #1
 10019b0:	2b01      	cmp	r3, #1
 10019b2:	d904      	bls.n	10019be <UART_ITConfig+0x26>
 10019b4:	4a16      	ldr	r2, [pc, #88]	; (1001a10 <UART_ITConfig+0x78>)
 10019b6:	21f4      	movs	r1, #244	; 0xf4
 10019b8:	4816      	ldr	r0, [pc, #88]	; (1001a14 <UART_ITConfig+0x7c>)
 10019ba:	f7fe fe1f 	bl	10005fc <_assert_handler>

    switch (UARTx)
 10019be:	2e00      	cmp	r6, #0
 10019c0:	d002      	beq.n	10019c8 <UART_ITConfig+0x30>
 10019c2:	2e01      	cmp	r6, #1
 10019c4:	d01b      	beq.n	10019fe <UART_ITConfig+0x66>
            UART1_CTRL |= (NewState << TX_INTR_ENABLE_BIT);
        }
    }
    break;
    }
}
 10019c6:	bd70      	pop	{r4, r5, r6, pc}
        if (UART_IT == UART_IT_RX)
 10019c8:	2d02      	cmp	r5, #2
 10019ca:	d10c      	bne.n	10019e6 <UART_ITConfig+0x4e>
 10019cc:	4b12      	ldr	r3, [pc, #72]	; (1001a18 <UART_ITConfig+0x80>)
            if (NewState)
 10019ce:	2c00      	cmp	r4, #0
 10019d0:	d004      	beq.n	10019dc <UART_ITConfig+0x44>
                UART1_CTRL |= ((ENABLE << 8));
 10019d2:	2280      	movs	r2, #128	; 0x80
 10019d4:	6819      	ldr	r1, [r3, #0]
 10019d6:	0052      	lsls	r2, r2, #1
 10019d8:	430a      	orrs	r2, r1
 10019da:	e002      	b.n	10019e2 <UART_ITConfig+0x4a>
                UART0_CTRL &= ~Set_RxITNum_Mask;
 10019dc:	681a      	ldr	r2, [r3, #0]
 10019de:	490f      	ldr	r1, [pc, #60]	; (1001a1c <UART_ITConfig+0x84>)
 10019e0:	400a      	ands	r2, r1
 10019e2:	601a      	str	r2, [r3, #0]
 10019e4:	e7ef      	b.n	10019c6 <UART_ITConfig+0x2e>
        else if (UART_IT == UART_IT_TX)
 10019e6:	2d01      	cmp	r5, #1
 10019e8:	d1ed      	bne.n	10019c6 <UART_ITConfig+0x2e>
            UART0_CTRL &= (~TX_INTR_ENABLE);
 10019ea:	4a0b      	ldr	r2, [pc, #44]	; (1001a18 <UART_ITConfig+0x80>)
            UART1_CTRL &= (uint32_t)~TX_INTR_ENABLE;
 10019ec:	6813      	ldr	r3, [r2, #0]
            UART1_CTRL |= (NewState << TX_INTR_ENABLE_BIT);
 10019ee:	07e4      	lsls	r4, r4, #31
            UART1_CTRL &= (uint32_t)~TX_INTR_ENABLE;
 10019f0:	005b      	lsls	r3, r3, #1
 10019f2:	085b      	lsrs	r3, r3, #1
 10019f4:	6013      	str	r3, [r2, #0]
            UART1_CTRL |= (NewState << TX_INTR_ENABLE_BIT);
 10019f6:	6813      	ldr	r3, [r2, #0]
 10019f8:	431c      	orrs	r4, r3
 10019fa:	6014      	str	r4, [r2, #0]
}
 10019fc:	e7e3      	b.n	10019c6 <UART_ITConfig+0x2e>
        if (UART_IT == UART_IT_RX)
 10019fe:	2d02      	cmp	r5, #2
 1001a00:	d101      	bne.n	1001a06 <UART_ITConfig+0x6e>
 1001a02:	4b07      	ldr	r3, [pc, #28]	; (1001a20 <UART_ITConfig+0x88>)
 1001a04:	e7e3      	b.n	10019ce <UART_ITConfig+0x36>
        else if (UART_IT == UART_IT_TX)
 1001a06:	2d01      	cmp	r5, #1
 1001a08:	d1dd      	bne.n	10019c6 <UART_ITConfig+0x2e>
            UART1_CTRL &= (uint32_t)~TX_INTR_ENABLE;
 1001a0a:	4a05      	ldr	r2, [pc, #20]	; (1001a20 <UART_ITConfig+0x88>)
 1001a0c:	e7ee      	b.n	10019ec <UART_ITConfig+0x54>
 1001a0e:	46c0      	nop			; (mov r8, r8)
 1001a10:	0100562d 	.word	0x0100562d
 1001a14:	01005593 	.word	0x01005593
 1001a18:	000f8b1c 	.word	0x000f8b1c
 1001a1c:	ffff00ff 	.word	0xffff00ff
 1001a20:	000f8c1c 	.word	0x000f8c1c

01001a24 <UART_ReceiveData>:

uint8_t UART_ReceiveData(UART_TypeDef UARTx)
{
 1001a24:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1001a26:	2801      	cmp	r0, #1
 1001a28:	d907      	bls.n	1001a3a <UART_ReceiveData+0x16>
 1001a2a:	2128      	movs	r1, #40	; 0x28
 1001a2c:	4a06      	ldr	r2, [pc, #24]	; (1001a48 <UART_ReceiveData+0x24>)
 1001a2e:	31ff      	adds	r1, #255	; 0xff
 1001a30:	4806      	ldr	r0, [pc, #24]	; (1001a4c <UART_ReceiveData+0x28>)
 1001a32:	f7fe fde3 	bl	10005fc <_assert_handler>
    {
        return UART0_RDATA;
    }
    else
    {
        return UART1_RDATA;
 1001a36:	4b06      	ldr	r3, [pc, #24]	; (1001a50 <UART_ReceiveData+0x2c>)
 1001a38:	e002      	b.n	1001a40 <UART_ReceiveData+0x1c>
    if (UART0 == UARTx)
 1001a3a:	2800      	cmp	r0, #0
 1001a3c:	d1fb      	bne.n	1001a36 <UART_ReceiveData+0x12>
        return UART0_RDATA;
 1001a3e:	4b05      	ldr	r3, [pc, #20]	; (1001a54 <UART_ReceiveData+0x30>)
        return UART1_RDATA;
 1001a40:	7818      	ldrb	r0, [r3, #0]
 1001a42:	b2c0      	uxtb	r0, r0
    }
}
 1001a44:	bd10      	pop	{r4, pc}
 1001a46:	46c0      	nop			; (mov r8, r8)
 1001a48:	0100563b 	.word	0x0100563b
 1001a4c:	01005593 	.word	0x01005593
 1001a50:	000f8c24 	.word	0x000f8c24
 1001a54:	000f8b24 	.word	0x000f8b24

01001a58 <UART_RecvBuf>:

int UART_RecvBuf(UART_TypeDef UARTx, uint8_t *buf, int len)
{
 1001a58:	b570      	push	{r4, r5, r6, lr}
 1001a5a:	0006      	movs	r6, r0
 1001a5c:	000c      	movs	r4, r1
 1001a5e:	0015      	movs	r5, r2
    uint32_t length = 0;
    volatile int *pstatus = NULL;
    volatile unsigned char *pdata = NULL;
    _ASSERT(IS_UART(UARTx));
 1001a60:	2801      	cmp	r0, #1
 1001a62:	d905      	bls.n	1001a70 <UART_RecvBuf+0x18>
 1001a64:	219c      	movs	r1, #156	; 0x9c
 1001a66:	4a10      	ldr	r2, [pc, #64]	; (1001aa8 <UART_RecvBuf+0x50>)
 1001a68:	0049      	lsls	r1, r1, #1
 1001a6a:	4810      	ldr	r0, [pc, #64]	; (1001aac <UART_RecvBuf+0x54>)
 1001a6c:	f7fe fdc6 	bl	10005fc <_assert_handler>
    _ASSERT(NULL != buf);
 1001a70:	2c00      	cmp	r4, #0
 1001a72:	d105      	bne.n	1001a80 <UART_RecvBuf+0x28>
 1001a74:	213a      	movs	r1, #58	; 0x3a
 1001a76:	4a0c      	ldr	r2, [pc, #48]	; (1001aa8 <UART_RecvBuf+0x50>)
 1001a78:	31ff      	adds	r1, #255	; 0xff
 1001a7a:	480c      	ldr	r0, [pc, #48]	; (1001aac <UART_RecvBuf+0x54>)
 1001a7c:	f7fe fdbe 	bl	10005fc <_assert_handler>

    if (UART0 == UARTx)
 1001a80:	2e00      	cmp	r6, #0
 1001a82:	d00d      	beq.n	1001aa0 <UART_RecvBuf+0x48>
        pdata = &UART0_RDATA;
    }
    else
    {
        pstatus = &UART1_STATUS;
        pdata = &UART1_RDATA;
 1001a84:	490a      	ldr	r1, [pc, #40]	; (1001ab0 <UART_RecvBuf+0x58>)
        pstatus = &UART1_STATUS;
 1001a86:	4a0b      	ldr	r2, [pc, #44]	; (1001ab4 <UART_RecvBuf+0x5c>)
        pstatus = &UART0_STATUS;
 1001a88:	2000      	movs	r0, #0
 1001a8a:	e004      	b.n	1001a96 <UART_RecvBuf+0x3e>
    }

    while ((*pstatus >> 16) > 0)
    {
        if (length < len)
 1001a8c:	4285      	cmp	r5, r0
 1001a8e:	d006      	beq.n	1001a9e <UART_RecvBuf+0x46>
        {
            buf[length++] = *pdata;
 1001a90:	780b      	ldrb	r3, [r1, #0]
 1001a92:	5423      	strb	r3, [r4, r0]
 1001a94:	3001      	adds	r0, #1
    while ((*pstatus >> 16) > 0)
 1001a96:	6813      	ldr	r3, [r2, #0]
 1001a98:	141b      	asrs	r3, r3, #16
 1001a9a:	2b00      	cmp	r3, #0
 1001a9c:	dcf6      	bgt.n	1001a8c <UART_RecvBuf+0x34>
            break;
        }
    }

    return length;
}
 1001a9e:	bd70      	pop	{r4, r5, r6, pc}
        pdata = &UART0_RDATA;
 1001aa0:	4905      	ldr	r1, [pc, #20]	; (1001ab8 <UART_RecvBuf+0x60>)
        pstatus = &UART0_STATUS;
 1001aa2:	4a06      	ldr	r2, [pc, #24]	; (1001abc <UART_RecvBuf+0x64>)
 1001aa4:	e7f0      	b.n	1001a88 <UART_RecvBuf+0x30>
 1001aa6:	46c0      	nop			; (mov r8, r8)
 1001aa8:	0100564c 	.word	0x0100564c
 1001aac:	01005593 	.word	0x01005593
 1001ab0:	000f8c24 	.word	0x000f8c24
 1001ab4:	000f8c28 	.word	0x000f8c28
 1001ab8:	000f8b24 	.word	0x000f8b24
 1001abc:	000f8b28 	.word	0x000f8b28

01001ac0 <UART_SendBuf>:


void UART_SendBuf(UART_TypeDef UARTx, uint8_t *buf, int len)
{
 1001ac0:	b570      	push	{r4, r5, r6, lr}
 1001ac2:	0004      	movs	r4, r0
 1001ac4:	000e      	movs	r6, r1
 1001ac6:	0015      	movs	r5, r2
    _ASSERT(IS_UART(UARTx));
 1001ac8:	2801      	cmp	r0, #1
 1001aca:	d905      	bls.n	1001ad8 <UART_SendBuf+0x18>
 1001acc:	21ac      	movs	r1, #172	; 0xac
 1001ace:	4a1c      	ldr	r2, [pc, #112]	; (1001b40 <UART_SendBuf+0x80>)
 1001ad0:	0049      	lsls	r1, r1, #1
 1001ad2:	481c      	ldr	r0, [pc, #112]	; (1001b44 <UART_SendBuf+0x84>)
 1001ad4:	f7fe fd92 	bl	10005fc <_assert_handler>
    _ASSERT(NULL != buf);
 1001ad8:	2e00      	cmp	r6, #0
 1001ada:	d105      	bne.n	1001ae8 <UART_SendBuf+0x28>
 1001adc:	215a      	movs	r1, #90	; 0x5a
 1001ade:	4a18      	ldr	r2, [pc, #96]	; (1001b40 <UART_SendBuf+0x80>)
 1001ae0:	31ff      	adds	r1, #255	; 0xff
 1001ae2:	4818      	ldr	r0, [pc, #96]	; (1001b44 <UART_SendBuf+0x84>)
 1001ae4:	f7fe fd8a 	bl	10005fc <_assert_handler>
    _ASSERT((len < 0xffff));
 1001ae8:	4b17      	ldr	r3, [pc, #92]	; (1001b48 <UART_SendBuf+0x88>)
 1001aea:	429d      	cmp	r5, r3
 1001aec:	dd05      	ble.n	1001afa <UART_SendBuf+0x3a>
 1001aee:	21ad      	movs	r1, #173	; 0xad
 1001af0:	4a13      	ldr	r2, [pc, #76]	; (1001b40 <UART_SendBuf+0x80>)
 1001af2:	0049      	lsls	r1, r1, #1
 1001af4:	4813      	ldr	r0, [pc, #76]	; (1001b44 <UART_SendBuf+0x84>)
 1001af6:	f7fe fd81 	bl	10005fc <_assert_handler>
 1001afa:	042d      	lsls	r5, r5, #16

    if (UARTx == UART0)
 1001afc:	2c00      	cmp	r4, #0
 1001afe:	d10f      	bne.n	1001b20 <UART_SendBuf+0x60>
    {
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001b00:	4b12      	ldr	r3, [pc, #72]	; (1001b4c <UART_SendBuf+0x8c>)
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1001b02:	4913      	ldr	r1, [pc, #76]	; (1001b50 <UART_SendBuf+0x90>)
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001b04:	601e      	str	r6, [r3, #0]
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1001b06:	680a      	ldr	r2, [r1, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 1001b08:	4b12      	ldr	r3, [pc, #72]	; (1001b54 <UART_SendBuf+0x94>)
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1001b0a:	b292      	uxth	r2, r2
 1001b0c:	432a      	orrs	r2, r5
 1001b0e:	600a      	str	r2, [r1, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 1001b10:	2280      	movs	r2, #128	; 0x80
 1001b12:	701a      	strb	r2, [r3, #0]
        while ((!(DMA_STATUS(DMACH_UART0) & 1)));
 1001b14:	2301      	movs	r3, #1
 1001b16:	4910      	ldr	r1, [pc, #64]	; (1001b58 <UART_SendBuf+0x98>)
 1001b18:	680a      	ldr	r2, [r1, #0]
 1001b1a:	421a      	tst	r2, r3
 1001b1c:	d0fc      	beq.n	1001b18 <UART_SendBuf+0x58>
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
        while ((!(DMA_STATUS(DMACH_UART1) & 1)));
    }
}
 1001b1e:	bd70      	pop	{r4, r5, r6, pc}
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1001b20:	4b0e      	ldr	r3, [pc, #56]	; (1001b5c <UART_SendBuf+0x9c>)
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1001b22:	490f      	ldr	r1, [pc, #60]	; (1001b60 <UART_SendBuf+0xa0>)
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1001b24:	601e      	str	r6, [r3, #0]
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1001b26:	680a      	ldr	r2, [r1, #0]
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 1001b28:	4b0e      	ldr	r3, [pc, #56]	; (1001b64 <UART_SendBuf+0xa4>)
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1001b2a:	b292      	uxth	r2, r2
 1001b2c:	432a      	orrs	r2, r5
 1001b2e:	600a      	str	r2, [r1, #0]
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 1001b30:	2280      	movs	r2, #128	; 0x80
 1001b32:	701a      	strb	r2, [r3, #0]
        while ((!(DMA_STATUS(DMACH_UART1) & 1)));
 1001b34:	2301      	movs	r3, #1
 1001b36:	490c      	ldr	r1, [pc, #48]	; (1001b68 <UART_SendBuf+0xa8>)
 1001b38:	680a      	ldr	r2, [r1, #0]
 1001b3a:	421a      	tst	r2, r3
 1001b3c:	d0fc      	beq.n	1001b38 <UART_SendBuf+0x78>
 1001b3e:	e7ee      	b.n	1001b1e <UART_SendBuf+0x5e>
 1001b40:	01005659 	.word	0x01005659
 1001b44:	01005593 	.word	0x01005593
 1001b48:	0000fffe 	.word	0x0000fffe
 1001b4c:	000f8b00 	.word	0x000f8b00
 1001b50:	000f8b08 	.word	0x000f8b08
 1001b54:	000f8b0f 	.word	0x000f8b0f
 1001b58:	000f8b10 	.word	0x000f8b10
 1001b5c:	000f8c00 	.word	0x000f8c00
 1001b60:	000f8c08 	.word	0x000f8c08
 1001b64:	000f8c0f 	.word	0x000f8c0f
 1001b68:	000f8c10 	.word	0x000f8c10

01001b6c <UART_SendData>:

void UART_SendData(UART_TypeDef UARTx, uint8_t Data)
{
 1001b6c:	b082      	sub	sp, #8
    uint8_t buf[1] = {Data};
 1001b6e:	ab01      	add	r3, sp, #4
 1001b70:	7019      	strb	r1, [r3, #0]
 1001b72:	2180      	movs	r1, #128	; 0x80
 1001b74:	0249      	lsls	r1, r1, #9

    if (UARTx == UART0)
 1001b76:	2800      	cmp	r0, #0
 1001b78:	d110      	bne.n	1001b9c <UART_SendData+0x30>
    {
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001b7a:	4a10      	ldr	r2, [pc, #64]	; (1001bbc <UART_SendData+0x50>)
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | 1 << 16;
 1001b7c:	4810      	ldr	r0, [pc, #64]	; (1001bc0 <UART_SendData+0x54>)
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001b7e:	6013      	str	r3, [r2, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 1001b80:	2280      	movs	r2, #128	; 0x80
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | 1 << 16;
 1001b82:	6803      	ldr	r3, [r0, #0]
 1001b84:	b29b      	uxth	r3, r3
 1001b86:	430b      	orrs	r3, r1
 1001b88:	6003      	str	r3, [r0, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 1001b8a:	4b0e      	ldr	r3, [pc, #56]	; (1001bc4 <UART_SendData+0x58>)
        while (!(DMA_STATUS(DMACH_UART0) & 1));
 1001b8c:	490e      	ldr	r1, [pc, #56]	; (1001bc8 <UART_SendData+0x5c>)
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 1001b8e:	701a      	strb	r2, [r3, #0]
        while (!(DMA_STATUS(DMACH_UART0) & 1));
 1001b90:	2301      	movs	r3, #1
 1001b92:	680a      	ldr	r2, [r1, #0]
 1001b94:	421a      	tst	r2, r3
 1001b96:	d0fc      	beq.n	1001b92 <UART_SendData+0x26>
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | 1 << 16;
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
        while (!(DMA_STATUS(DMACH_UART1) & 1));
    }
}
 1001b98:	b002      	add	sp, #8
 1001b9a:	4770      	bx	lr
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1001b9c:	4a0b      	ldr	r2, [pc, #44]	; (1001bcc <UART_SendData+0x60>)
 1001b9e:	6013      	str	r3, [r2, #0]
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | 1 << 16;
 1001ba0:	4a0b      	ldr	r2, [pc, #44]	; (1001bd0 <UART_SendData+0x64>)
 1001ba2:	6813      	ldr	r3, [r2, #0]
 1001ba4:	b29b      	uxth	r3, r3
 1001ba6:	430b      	orrs	r3, r1
 1001ba8:	6013      	str	r3, [r2, #0]
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 1001baa:	2280      	movs	r2, #128	; 0x80
 1001bac:	4b09      	ldr	r3, [pc, #36]	; (1001bd4 <UART_SendData+0x68>)
        while (!(DMA_STATUS(DMACH_UART1) & 1));
 1001bae:	490a      	ldr	r1, [pc, #40]	; (1001bd8 <UART_SendData+0x6c>)
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 1001bb0:	701a      	strb	r2, [r3, #0]
        while (!(DMA_STATUS(DMACH_UART1) & 1));
 1001bb2:	2301      	movs	r3, #1
 1001bb4:	680a      	ldr	r2, [r1, #0]
 1001bb6:	421a      	tst	r2, r3
 1001bb8:	d0fc      	beq.n	1001bb4 <UART_SendData+0x48>
 1001bba:	e7ed      	b.n	1001b98 <UART_SendData+0x2c>
 1001bbc:	000f8b00 	.word	0x000f8b00
 1001bc0:	000f8b08 	.word	0x000f8b08
 1001bc4:	000f8b0f 	.word	0x000f8b0f
 1001bc8:	000f8b10 	.word	0x000f8b10
 1001bcc:	000f8c00 	.word	0x000f8c00
 1001bd0:	000f8c08 	.word	0x000f8c08
 1001bd4:	000f8c0f 	.word	0x000f8c0f
 1001bd8:	000f8c10 	.word	0x000f8c10

01001bdc <UART_SetITTimeout>:

void UART_SetITTimeout(UART_TypeDef UARTx, uint16_t timeout)
{
    if (UART0 == UARTx)
 1001bdc:	2800      	cmp	r0, #0
 1001bde:	d102      	bne.n	1001be6 <UART_SetITTimeout+0xa>
    {
        UART0_INTR = timeout;
 1001be0:	4b02      	ldr	r3, [pc, #8]	; (1001bec <UART_SetITTimeout+0x10>)
    }
    else
    {
        UART1_INTR = timeout;
 1001be2:	6019      	str	r1, [r3, #0]
    }
}
 1001be4:	4770      	bx	lr
        UART1_INTR = timeout;
 1001be6:	4b02      	ldr	r3, [pc, #8]	; (1001bf0 <UART_SetITTimeout+0x14>)
 1001be8:	e7fb      	b.n	1001be2 <UART_SetITTimeout+0x6>
 1001bea:	46c0      	nop			; (mov r8, r8)
 1001bec:	000f8b20 	.word	0x000f8b20
 1001bf0:	000f8c20 	.word	0x000f8c20

01001bf4 <UART_SetRxITNum>:

void UART_SetRxITNum(UART_TypeDef UARTx, uint8_t Bcnt)
{
 1001bf4:	b570      	push	{r4, r5, r6, lr}
 1001bf6:	020c      	lsls	r4, r1, #8
 1001bf8:	4d09      	ldr	r5, [pc, #36]	; (1001c20 <UART_SetRxITNum+0x2c>)
    _ASSERT(IS_UART(UARTx));
 1001bfa:	2801      	cmp	r0, #1
 1001bfc:	d907      	bls.n	1001c0e <UART_SetRxITNum+0x1a>
 1001bfe:	21c7      	movs	r1, #199	; 0xc7
 1001c00:	4a08      	ldr	r2, [pc, #32]	; (1001c24 <UART_SetRxITNum+0x30>)
 1001c02:	0049      	lsls	r1, r1, #1
 1001c04:	4808      	ldr	r0, [pc, #32]	; (1001c28 <UART_SetRxITNum+0x34>)
 1001c06:	f7fe fcf9 	bl	10005fc <_assert_handler>
    {
        UART0_CTRL = (UART0_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
    }
    else
    {
        UART1_CTRL = (UART1_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
 1001c0a:	4b08      	ldr	r3, [pc, #32]	; (1001c2c <UART_SetRxITNum+0x38>)
 1001c0c:	e002      	b.n	1001c14 <UART_SetRxITNum+0x20>
    if (UART0 == UARTx)
 1001c0e:	2800      	cmp	r0, #0
 1001c10:	d1fb      	bne.n	1001c0a <UART_SetRxITNum+0x16>
        UART0_CTRL = (UART0_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
 1001c12:	4b07      	ldr	r3, [pc, #28]	; (1001c30 <UART_SetRxITNum+0x3c>)
        UART1_CTRL = (UART1_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
 1001c14:	6819      	ldr	r1, [r3, #0]
 1001c16:	4029      	ands	r1, r5
 1001c18:	4321      	orrs	r1, r4
 1001c1a:	6019      	str	r1, [r3, #0]
    }

}
 1001c1c:	bd70      	pop	{r4, r5, r6, pc}
 1001c1e:	46c0      	nop			; (mov r8, r8)
 1001c20:	ffff00ff 	.word	0xffff00ff
 1001c24:	01005666 	.word	0x01005666
 1001c28:	01005593 	.word	0x01005593
 1001c2c:	000f8c1c 	.word	0x000f8c1c
 1001c30:	000f8b1c 	.word	0x000f8b1c

01001c34 <UART_StructInit>:

void UART_StructInit(UART_InitTypeDef *UART_InitStruct)
{
    UART_InitStruct->BaudRate = 9600;
 1001c34:	2296      	movs	r2, #150	; 0x96
    UART_InitStruct->DataBits = Databits_8b;
    UART_InitStruct->FlowCtrl = FlowCtrl_None ;
    UART_InitStruct->Mode = Mode_duplex;
 1001c36:	2300      	movs	r3, #0
    UART_InitStruct->BaudRate = 9600;
 1001c38:	0192      	lsls	r2, r2, #6
    UART_InitStruct->Mode = Mode_duplex;
 1001c3a:	7003      	strb	r3, [r0, #0]
    UART_InitStruct->BaudRate = 9600;
 1001c3c:	6042      	str	r2, [r0, #4]
 1001c3e:	6083      	str	r3, [r0, #8]
    UART_InitStruct->StopBits = StopBits_1;
    UART_InitStruct->Parity = 0;
}
 1001c40:	4770      	bx	lr
	...

01001c44 <UART_ReceiveDataLen>:

uint16_t UART_ReceiveDataLen(UART_TypeDef UARTx)
{
 1001c44:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1001c46:	2801      	cmp	r0, #1
 1001c48:	d907      	bls.n	1001c5a <UART_ReceiveDataLen+0x16>
 1001c4a:	21a8      	movs	r1, #168	; 0xa8
 1001c4c:	4a06      	ldr	r2, [pc, #24]	; (1001c68 <UART_ReceiveDataLen+0x24>)
 1001c4e:	31ff      	adds	r1, #255	; 0xff
 1001c50:	4806      	ldr	r0, [pc, #24]	; (1001c6c <UART_ReceiveDataLen+0x28>)
 1001c52:	f7fe fcd3 	bl	10005fc <_assert_handler>
    {
        return (uint16_t)(UART0_STATUS >> 16);
    }
    else
    {
        return (uint16_t)(UART1_STATUS >> 16);
 1001c56:	4b06      	ldr	r3, [pc, #24]	; (1001c70 <UART_ReceiveDataLen+0x2c>)
 1001c58:	e002      	b.n	1001c60 <UART_ReceiveDataLen+0x1c>
    if (UART0 == UARTx)
 1001c5a:	2800      	cmp	r0, #0
 1001c5c:	d1fb      	bne.n	1001c56 <UART_ReceiveDataLen+0x12>
        return (uint16_t)(UART0_STATUS >> 16);
 1001c5e:	4b05      	ldr	r3, [pc, #20]	; (1001c74 <UART_ReceiveDataLen+0x30>)
        return (uint16_t)(UART1_STATUS >> 16);
 1001c60:	6818      	ldr	r0, [r3, #0]
 1001c62:	0c00      	lsrs	r0, r0, #16
    }
}
 1001c64:	bd10      	pop	{r4, pc}
 1001c66:	46c0      	nop			; (mov r8, r8)
 1001c68:	01005676 	.word	0x01005676
 1001c6c:	01005593 	.word	0x01005593
 1001c70:	000f8c28 	.word	0x000f8c28
 1001c74:	000f8b28 	.word	0x000f8b28

01001c78 <lpm_read>:
#include "yc_lpm.h"

uint32_t lpm_read(volatile int *addr)
{
 1001c78:	b510      	push	{r4, lr}
    return ((uint32_t(*)(volatile int *addr))FUNC_LPM_READ_ADDR)(addr);
 1001c7a:	4b01      	ldr	r3, [pc, #4]	; (1001c80 <lpm_read+0x8>)
 1001c7c:	4798      	blx	r3
}
 1001c7e:	bd10      	pop	{r4, pc}
 1001c80:	00004c81 	.word	0x00004c81

01001c84 <lpm_write>:

void lpm_write(volatile int *addr, uint32_t value)
{
 1001c84:	b510      	push	{r4, lr}
    ((void(*)(volatile int *addr, uint32_t value))FUNC_LPM_WRITE_ADDR)(addr, value);
 1001c86:	4b01      	ldr	r3, [pc, #4]	; (1001c8c <lpm_write+0x8>)
 1001c88:	4798      	blx	r3
}
 1001c8a:	bd10      	pop	{r4, pc}
 1001c8c:	00004c9d 	.word	0x00004c9d

01001c90 <lpm_bt_write>:

void lpm_bt_write(uint8_t type, uint32_t val)
{
 1001c90:	b570      	push	{r4, r5, r6, lr}
 1001c92:	000c      	movs	r4, r1
    SYSCTRL_CLK_CLS &= ~(1 << id);
 1001c94:	4a14      	ldr	r2, [pc, #80]	; (1001ce8 <lpm_bt_write+0x58>)
 1001c96:	4915      	ldr	r1, [pc, #84]	; (1001cec <lpm_bt_write+0x5c>)
 1001c98:	6813      	ldr	r3, [r2, #0]
 1001c9a:	0005      	movs	r5, r0
 1001c9c:	400b      	ands	r3, r1
 1001c9e:	6013      	str	r3, [r2, #0]
    //  ((void(*)(uint8_t type,uint32_t val))FUNC_LPM_BT_WRITE_ADDR)(type,val);
    enable_clock(CLKCLS_BT);
    *(volatile uint8_t *)0xc804c = (val & 0x000000ff) >> 0;
 1001ca0:	4b13      	ldr	r3, [pc, #76]	; (1001cf0 <lpm_bt_write+0x60>)
 1001ca2:	b2e2      	uxtb	r2, r4
 1001ca4:	701a      	strb	r2, [r3, #0]
    delay_us(1);
 1001ca6:	2001      	movs	r0, #1
 1001ca8:	f7ff f85c 	bl	1000d64 <delay_us>
    *(volatile uint8_t *)0xc804d = (val & 0x0000ff00) >> 8;
 1001cac:	4a11      	ldr	r2, [pc, #68]	; (1001cf4 <lpm_bt_write+0x64>)
 1001cae:	0a23      	lsrs	r3, r4, #8
 1001cb0:	b2db      	uxtb	r3, r3
 1001cb2:	7013      	strb	r3, [r2, #0]
    delay_us(1);
 1001cb4:	2001      	movs	r0, #1
 1001cb6:	f7ff f855 	bl	1000d64 <delay_us>
    *(volatile uint8_t *)0xc804e = (val & 0x00ff0000) >> 16;
 1001cba:	4a0f      	ldr	r2, [pc, #60]	; (1001cf8 <lpm_bt_write+0x68>)
 1001cbc:	0c23      	lsrs	r3, r4, #16
 1001cbe:	b2db      	uxtb	r3, r3
 1001cc0:	7013      	strb	r3, [r2, #0]
    delay_us(1);
 1001cc2:	2001      	movs	r0, #1
 1001cc4:	f7ff f84e 	bl	1000d64 <delay_us>
    *(volatile uint8_t *)0xc804f = (val & 0xff000000) >> 24;
 1001cc8:	4b0c      	ldr	r3, [pc, #48]	; (1001cfc <lpm_bt_write+0x6c>)
 1001cca:	0e24      	lsrs	r4, r4, #24
 1001ccc:	701c      	strb	r4, [r3, #0]
    delay_us(1);
 1001cce:	2001      	movs	r0, #1
 1001cd0:	f7ff f848 	bl	1000d64 <delay_us>
    *(volatile uint8_t *)0xc8005 = 1 << type;
 1001cd4:	2001      	movs	r0, #1
 1001cd6:	0003      	movs	r3, r0
 1001cd8:	40ab      	lsls	r3, r5
 1001cda:	4a09      	ldr	r2, [pc, #36]	; (1001d00 <lpm_bt_write+0x70>)
 1001cdc:	b2db      	uxtb	r3, r3
 1001cde:	7013      	strb	r3, [r2, #0]
    delay_ms(1);
 1001ce0:	f7ff f846 	bl	1000d70 <delay_ms>
}
 1001ce4:	bd70      	pop	{r4, r5, r6, pc}
 1001ce6:	46c0      	nop			; (mov r8, r8)
 1001ce8:	000f856c 	.word	0x000f856c
 1001cec:	ffffdfff 	.word	0xffffdfff
 1001cf0:	000c804c 	.word	0x000c804c
 1001cf4:	000c804d 	.word	0x000c804d
 1001cf8:	000c804e 	.word	0x000c804e
 1001cfc:	000c804f 	.word	0x000c804f
 1001d00:	000c8005 	.word	0x000c8005

01001d04 <lpm_bt_read>:

uint32_t lpm_bt_read(uint8_t type)
{
    if (type == LPMBT_WKUPLOW || type == LPMBT_WKUPHIGH)
 1001d04:	1e82      	subs	r2, r0, #2
{
 1001d06:	b510      	push	{r4, lr}
 1001d08:	4b03      	ldr	r3, [pc, #12]	; (1001d18 <lpm_bt_read+0x14>)
    if (type == LPMBT_WKUPLOW || type == LPMBT_WKUPHIGH)
 1001d0a:	2a01      	cmp	r2, #1
 1001d0c:	d802      	bhi.n	1001d14 <lpm_bt_read+0x10>
    {
        return (((uint32_t(*)(uint8_t type))FUNC_LPM_BT_READ_ADDR)(type)) >> 2;
 1001d0e:	4798      	blx	r3
 1001d10:	0880      	lsrs	r0, r0, #2
    }
    else
    {
        return (((uint32_t(*)(uint8_t type))FUNC_LPM_BT_READ_ADDR)(type));
    }
}
 1001d12:	bd10      	pop	{r4, pc}
        return (((uint32_t(*)(uint8_t type))FUNC_LPM_BT_READ_ADDR)(type));
 1001d14:	4798      	blx	r3
 1001d16:	e7fc      	b.n	1001d12 <lpm_bt_read+0xe>
 1001d18:	00004d25 	.word	0x00004d25

01001d1c <lpm_sleep>:

void lpm_sleep(void)
{
 1001d1c:	b510      	push	{r4, lr}
    ((void(*)())FUNC_LPM_SLEEP_ADDR)();
 1001d1e:	4b01      	ldr	r3, [pc, #4]	; (1001d24 <lpm_sleep+0x8>)
 1001d20:	4798      	blx	r3
}
 1001d22:	bd10      	pop	{r4, pc}
 1001d24:	00004d69 	.word	0x00004d69

01001d28 <setlpmval>:

void setlpmval(volatile int *addr, uint8_t startbit, uint8_t bitwidth, uint32_t val)
{
 1001d28:	b510      	push	{r4, lr}
    ((void(*)(volatile int *addr, uint8_t startbit, uint8_t bitwidth, uint32_t val))FUNC_SETLPMVAL_ADDR)(addr, startbit, bitwidth, val);
 1001d2a:	4c01      	ldr	r4, [pc, #4]	; (1001d30 <setlpmval+0x8>)
 1001d2c:	47a0      	blx	r4
}
 1001d2e:	bd10      	pop	{r4, pc}
 1001d30:	00004281 	.word	0x00004281

01001d34 <readlpmval>:

uint32_t readlpmval(volatile int *addr, uint8_t startbit, uint8_t bitwidth)
{
 1001d34:	b510      	push	{r4, lr}
 1001d36:	000c      	movs	r4, r1
    uint32_t tmp = 0;
    if (32 == bitwidth)
 1001d38:	2a20      	cmp	r2, #32
 1001d3a:	d103      	bne.n	1001d44 <readlpmval+0x10>
    {
        tmp = lpm_read(addr);
 1001d3c:	f7ff ff9c 	bl	1001c78 <lpm_read>
        return ((tmp >> startbit) & ((1 << bitwidth) - 1));
 1001d40:	40e0      	lsrs	r0, r4
    }
    else
    {
        return lpm_read(addr);
    }
}
 1001d42:	bd10      	pop	{r4, pc}
        return lpm_read(addr);
 1001d44:	f7ff ff98 	bl	1001c78 <lpm_read>
 1001d48:	e7fb      	b.n	1001d42 <readlpmval+0xe>
	...

01001d4c <GPIO_Unused_Pd>:
{
    for (int i = 0; i < 48; i++)
    {
        if (GPIO_CONFIG(i) == 0 || GPIO_CONFIG(i) == 4 || GPIO_CONFIG(i) == 5)
        {
            GPIO_CONFIG(i) |= GPCFG_PD;
 1001d4c:	2080      	movs	r0, #128	; 0x80
{
 1001d4e:	4b0a      	ldr	r3, [pc, #40]	; (1001d78 <GPIO_Unused_Pd+0x2c>)
    for (int i = 0; i < 48; i++)
 1001d50:	490a      	ldr	r1, [pc, #40]	; (1001d7c <GPIO_Unused_Pd+0x30>)
            GPIO_CONFIG(i) |= GPCFG_PD;
 1001d52:	4240      	negs	r0, r0
        if (GPIO_CONFIG(i) == 0 || GPIO_CONFIG(i) == 4 || GPIO_CONFIG(i) == 5)
 1001d54:	781a      	ldrb	r2, [r3, #0]
 1001d56:	2a00      	cmp	r2, #0
 1001d58:	d005      	beq.n	1001d66 <GPIO_Unused_Pd+0x1a>
 1001d5a:	781a      	ldrb	r2, [r3, #0]
 1001d5c:	2a04      	cmp	r2, #4
 1001d5e:	d002      	beq.n	1001d66 <GPIO_Unused_Pd+0x1a>
 1001d60:	781a      	ldrb	r2, [r3, #0]
 1001d62:	2a05      	cmp	r2, #5
 1001d64:	d103      	bne.n	1001d6e <GPIO_Unused_Pd+0x22>
            GPIO_CONFIG(i) |= GPCFG_PD;
 1001d66:	781a      	ldrb	r2, [r3, #0]
 1001d68:	4302      	orrs	r2, r0
 1001d6a:	b2d2      	uxtb	r2, r2
 1001d6c:	701a      	strb	r2, [r3, #0]
 1001d6e:	3301      	adds	r3, #1
    for (int i = 0; i < 48; i++)
 1001d70:	428b      	cmp	r3, r1
 1001d72:	d1ef      	bne.n	1001d54 <GPIO_Unused_Pd+0x8>
        }
    }
}
 1001d74:	4770      	bx	lr
 1001d76:	46c0      	nop			; (mov r8, r8)
 1001d78:	000f8700 	.word	0x000f8700
 1001d7c:	000f8730 	.word	0x000f8730

01001d80 <BT_Hibernate>:
}

void BT_Hibernate(void)
{
#if (VERSIONS == EXIST_BT)
    if(TRUE == ipc_inited)
 1001d80:	4b15      	ldr	r3, [pc, #84]	; (1001dd8 <BT_Hibernate+0x58>)
{
 1001d82:	b513      	push	{r0, r1, r4, lr}
    if(TRUE == ipc_inited)
 1001d84:	781a      	ldrb	r2, [r3, #0]
 1001d86:	2a01      	cmp	r2, #1
 1001d88:	d124      	bne.n	1001dd4 <BT_Hibernate+0x54>
    {
        ipc_inited = FALSE;
 1001d8a:	2200      	movs	r2, #0

        read_otp(0x13e, (uint8_t *)&value_rtc_1s, 2);
 1001d8c:	209f      	movs	r0, #159	; 0x9f
 1001d8e:	4c13      	ldr	r4, [pc, #76]	; (1001ddc <BT_Hibernate+0x5c>)
        ipc_inited = FALSE;
 1001d90:	701a      	strb	r2, [r3, #0]
        read_otp(0x13e, (uint8_t *)&value_rtc_1s, 2);
 1001d92:	0021      	movs	r1, r4
 1001d94:	3202      	adds	r2, #2
 1001d96:	0040      	lsls	r0, r0, #1
 1001d98:	f000 f8ea 	bl	1001f70 <read_otp>
        value_rtc_1s = (value_rtc_1s == 0) ? 0x8000 : value_rtc_1s;
 1001d9c:	6823      	ldr	r3, [r4, #0]
 1001d9e:	2b00      	cmp	r3, #0
 1001da0:	d101      	bne.n	1001da6 <BT_Hibernate+0x26>
 1001da2:	2380      	movs	r3, #128	; 0x80
 1001da4:	021b      	lsls	r3, r3, #8

        BT_CONFIG &= ~(1 << BT_INIT_FLAG);
 1001da6:	217f      	movs	r1, #127	; 0x7f
 1001da8:	4a0d      	ldr	r2, [pc, #52]	; (1001de0 <BT_Hibernate+0x60>)
        value_rtc_1s = (value_rtc_1s == 0) ? 0x8000 : value_rtc_1s;
 1001daa:	6023      	str	r3, [r4, #0]
        BT_CONFIG &= ~(1 << BT_INIT_FLAG);
 1001dac:	7813      	ldrb	r3, [r2, #0]

        NVIC_DisableIRQ(BT_IRQn);
 1001dae:	200b      	movs	r0, #11
        BT_CONFIG &= ~(1 << BT_INIT_FLAG);
 1001db0:	400b      	ands	r3, r1
 1001db2:	7013      	strb	r3, [r2, #0]
        NVIC_DisableIRQ(BT_IRQn);
 1001db4:	f7fe fc62 	bl	100067c <NVIC_DisableIRQ>
        SYSCTRL_ROM_SWITCH = 0x90;
 1001db8:	2290      	movs	r2, #144	; 0x90
 1001dba:	4b0a      	ldr	r3, [pc, #40]	; (1001de4 <BT_Hibernate+0x64>)

        HCI_TypeDef IpcRxData;
        IpcRxData.type = 1;
        IpcRxData.opcode = 0x27;
        IpcRxData.DataLen = 0;
        IPC_TxData(&IpcRxData);
 1001dbc:	4668      	mov	r0, sp
        SYSCTRL_ROM_SWITCH = 0x90;
 1001dbe:	701a      	strb	r2, [r3, #0]
        IpcRxData.type = 1;
 1001dc0:	466a      	mov	r2, sp
 1001dc2:	4b09      	ldr	r3, [pc, #36]	; (1001de8 <BT_Hibernate+0x68>)
 1001dc4:	8013      	strh	r3, [r2, #0]
        IpcRxData.opcode = 0x27;
 1001dc6:	2300      	movs	r3, #0
 1001dc8:	7093      	strb	r3, [r2, #2]
        IPC_TxData(&IpcRxData);
 1001dca:	f7ff f993 	bl	10010f4 <IPC_TxData>
        //delay(10000);
        delay_ms(60);
 1001dce:	203c      	movs	r0, #60	; 0x3c
 1001dd0:	f7fe ffce 	bl	1000d70 <delay_ms>
        delay_us(1000);
        lpm_bt_write(4,0x50000);
        delay_us(1000);
    }
#endif
}
 1001dd4:	bd13      	pop	{r0, r1, r4, pc}
 1001dd6:	46c0      	nop			; (mov r8, r8)
 1001dd8:	00020245 	.word	0x00020245
 1001ddc:	00020a48 	.word	0x00020a48
 1001de0:	000c8043 	.word	0x000c8043
 1001de4:	000f853c 	.word	0x000f853c
 1001de8:	00002701 	.word	0x00002701

01001dec <Chip_Speedstep>:

void Chip_Speedstep(void)
{
 1001dec:	b510      	push	{r4, lr}
    SYSCTRL_HCLKConfig(SYSCTRL_HCLK_Div8);
 1001dee:	200e      	movs	r0, #14
 1001df0:	f000 f916 	bl	1002020 <SYSCTRL_HCLKConfig>
}
 1001df4:	bd10      	pop	{r4, pc}
	...

01001df8 <CM0_Sleep>:

void CM0_Sleep(uint32_t time, GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, uint8_t islow_wakeup, uint8_t is_powerdownbt)
{
 1001df8:	b5f0      	push	{r4, r5, r6, r7, lr}
 1001dfa:	001f      	movs	r7, r3
 1001dfc:	b085      	sub	sp, #20
 1001dfe:	ab0a      	add	r3, sp, #40	; 0x28
 1001e00:	781b      	ldrb	r3, [r3, #0]
 1001e02:	0006      	movs	r6, r0
 1001e04:	000c      	movs	r4, r1
    uint32_t temp;

    SYSCTRL_AHBPeriphClockCmd(SYSCTRL_AHBPeriph_INTR | SYSCTRL_AHBPeriph_SHA | \
 1001e06:	483b      	ldr	r0, [pc, #236]	; (1001ef4 <CM0_Sleep+0xfc>)
 1001e08:	2100      	movs	r1, #0
{
 1001e0a:	0015      	movs	r5, r2
 1001e0c:	9301      	str	r3, [sp, #4]
    SYSCTRL_AHBPeriphClockCmd(SYSCTRL_AHBPeriph_INTR | SYSCTRL_AHBPeriph_SHA | \
 1001e0e:	f000 f8c7 	bl	1001fa0 <SYSCTRL_AHBPeriphClockCmd>
                              SYSCTRL_AHBPeriph_7816 | SYSCTRL_AHBPeriph_SM4 | \
                              SYSCTRL_AHBPeriph_7811 | SYSCTRL_AHBPeriph_ADC7811 | \
                              SYSCTRL_AHBPeriph_CP, DISABLE);

    //DISABLE RTC WAKEUP
    setlpmval(LPM_GPIO_WKHI, 17, 1, 0);
 1001e12:	2201      	movs	r2, #1
 1001e14:	2300      	movs	r3, #0
 1001e16:	2111      	movs	r1, #17
 1001e18:	4837      	ldr	r0, [pc, #220]	; (1001ef8 <CM0_Sleep+0x100>)
 1001e1a:	f7ff ff85 	bl	1001d28 <setlpmval>

    //set gpio wakeup level
    setlpmval(LPM_GPIO_WKHI, 18, 1, islow_wakeup ? 1 : 0);
 1001e1e:	003b      	movs	r3, r7
 1001e20:	2112      	movs	r1, #18
 1001e22:	1e5a      	subs	r2, r3, #1
 1001e24:	4193      	sbcs	r3, r2
 1001e26:	4834      	ldr	r0, [pc, #208]	; (1001ef8 <CM0_Sleep+0x100>)
 1001e28:	2201      	movs	r2, #1
 1001e2a:	f7ff ff7d 	bl	1001d28 <setlpmval>

    //set gpio num
    if (islow_wakeup)
    {
        GPIO_Config(GPIOx, GPIO_Pin, PULL_UP);
 1001e2e:	2240      	movs	r2, #64	; 0x40
    if (islow_wakeup)
 1001e30:	2f00      	cmp	r7, #0
 1001e32:	d100      	bne.n	1001e36 <CM0_Sleep+0x3e>
    }
    else
    {
        GPIO_Config(GPIOx, GPIO_Pin, PULL_DOWN);
 1001e34:	2280      	movs	r2, #128	; 0x80
 1001e36:	0029      	movs	r1, r5
 1001e38:	0020      	movs	r0, r4
 1001e3a:	f7fe fc3f 	bl	10006bc <GPIO_Config>
    }

    if (GPIOx == GPIOA)
 1001e3e:	2c00      	cmp	r4, #0
 1001e40:	d13d      	bne.n	1001ebe <CM0_Sleep+0xc6>
    {
        setlpmval(LPM_GPIO_WKUP, 0, 16, GPIO_Pin);
 1001e42:	002b      	movs	r3, r5
 1001e44:	2210      	movs	r2, #16
 1001e46:	0021      	movs	r1, r4
    }
    else if (GPIOx == GPIOB)
    {
        setlpmval(LPM_GPIO_WKUP, 16, 16, GPIO_Pin);
 1001e48:	482c      	ldr	r0, [pc, #176]	; (1001efc <CM0_Sleep+0x104>)
        setlpmval(LPM_GPIO_WKHI, 0, 16, GPIO_Pin);
    }
    else
    {
        setlpmval(LPM_GPIO_WKUP, 0, 32, 0);
        setlpmval(LPM_GPIO_WKHI, 0, 16, 0);
 1001e4a:	f7ff ff6d 	bl	1001d28 <setlpmval>
    if (value_rtc_1s == 0)
 1001e4e:	4b2c      	ldr	r3, [pc, #176]	; (1001f00 <CM0_Sleep+0x108>)
 1001e50:	681a      	ldr	r2, [r3, #0]
 1001e52:	2a00      	cmp	r2, #0
 1001e54:	d14a      	bne.n	1001eec <CM0_Sleep+0xf4>
        read_otp(0x13e, (uint8_t *)&time, 2);
 1001e56:	209f      	movs	r0, #159	; 0x9f
 1001e58:	3202      	adds	r2, #2
 1001e5a:	a903      	add	r1, sp, #12
 1001e5c:	0040      	lsls	r0, r0, #1
 1001e5e:	f000 f887 	bl	1001f70 <read_otp>
        time = (time == 0) ? 0x8000 : time;
 1001e62:	9b03      	ldr	r3, [sp, #12]
 1001e64:	2b00      	cmp	r3, #0
 1001e66:	d101      	bne.n	1001e6c <CM0_Sleep+0x74>
 1001e68:	2380      	movs	r3, #128	; 0x80
 1001e6a:	021b      	lsls	r3, r3, #8
        time &= (~((uint32_t)0x1 << 31));
 1001e6c:	005b      	lsls	r3, r3, #1
 1001e6e:	085b      	lsrs	r3, r3, #1
        time |= ((uint32_t)0x1 << 31);
 1001e70:	9303      	str	r3, [sp, #12]
    return time;
 1001e72:	9c03      	ldr	r4, [sp, #12]
    }

    temp = get_otp();

    if (time)
 1001e74:	2e00      	cmp	r6, #0
 1001e76:	d017      	beq.n	1001ea8 <CM0_Sleep+0xb0>
    {
        //SET SECMAX
        setlpmval(LPM_SECMAX, 0, 16, temp);
 1001e78:	0023      	movs	r3, r4
 1001e7a:	2210      	movs	r2, #16
 1001e7c:	2100      	movs	r1, #0
 1001e7e:	4821      	ldr	r0, [pc, #132]	; (1001f04 <CM0_Sleep+0x10c>)
 1001e80:	f7ff ff52 	bl	1001d28 <setlpmval>
        //SET SLEEP CNT
        setlpmval(LPM_WKUP_TIMER, 0, 32, time);
 1001e84:	0033      	movs	r3, r6
 1001e86:	2220      	movs	r2, #32
 1001e88:	2100      	movs	r1, #0
 1001e8a:	481f      	ldr	r0, [pc, #124]	; (1001f08 <CM0_Sleep+0x110>)
 1001e8c:	f7ff ff4c 	bl	1001d28 <setlpmval>
        //clr RTC CNT
        setlpmval(LPM_RTC_CNT, 0, 32, 0);
 1001e90:	2300      	movs	r3, #0
 1001e92:	2220      	movs	r2, #32
 1001e94:	0019      	movs	r1, r3
 1001e96:	481d      	ldr	r0, [pc, #116]	; (1001f0c <CM0_Sleep+0x114>)
 1001e98:	f7ff ff46 	bl	1001d28 <setlpmval>
        // ENABLE RTC WAKEUP
        setlpmval(LPM_GPIO_WKHI, 17, 1, 1);
 1001e9c:	2301      	movs	r3, #1
 1001e9e:	2111      	movs	r1, #17
 1001ea0:	001a      	movs	r2, r3
 1001ea2:	4815      	ldr	r0, [pc, #84]	; (1001ef8 <CM0_Sleep+0x100>)
 1001ea4:	f7ff ff40 	bl	1001d28 <setlpmval>
    }

    if (is_powerdownbt == 1 && (temp >> 31) == 0)
 1001ea8:	9b01      	ldr	r3, [sp, #4]
 1001eaa:	2b01      	cmp	r3, #1
 1001eac:	d103      	bne.n	1001eb6 <CM0_Sleep+0xbe>
 1001eae:	2c00      	cmp	r4, #0
 1001eb0:	db01      	blt.n	1001eb6 <CM0_Sleep+0xbe>
    {
        BT_Hibernate();
 1001eb2:	f7ff ff65 	bl	1001d80 <BT_Hibernate>
    }

    lpm_sleep();
 1001eb6:	f7ff ff31 	bl	1001d1c <lpm_sleep>
}
 1001eba:	b005      	add	sp, #20
 1001ebc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (GPIOx == GPIOB)
 1001ebe:	2c01      	cmp	r4, #1
 1001ec0:	d103      	bne.n	1001eca <CM0_Sleep+0xd2>
        setlpmval(LPM_GPIO_WKUP, 16, 16, GPIO_Pin);
 1001ec2:	2210      	movs	r2, #16
 1001ec4:	002b      	movs	r3, r5
 1001ec6:	0011      	movs	r1, r2
 1001ec8:	e7be      	b.n	1001e48 <CM0_Sleep+0x50>
    else if (GPIOx == GPIOC)
 1001eca:	2c02      	cmp	r4, #2
 1001ecc:	d104      	bne.n	1001ed8 <CM0_Sleep+0xe0>
        setlpmval(LPM_GPIO_WKHI, 0, 16, GPIO_Pin);
 1001ece:	002b      	movs	r3, r5
 1001ed0:	2210      	movs	r2, #16
 1001ed2:	2100      	movs	r1, #0
        setlpmval(LPM_GPIO_WKHI, 0, 16, 0);
 1001ed4:	4808      	ldr	r0, [pc, #32]	; (1001ef8 <CM0_Sleep+0x100>)
 1001ed6:	e7b8      	b.n	1001e4a <CM0_Sleep+0x52>
        setlpmval(LPM_GPIO_WKUP, 0, 32, 0);
 1001ed8:	2300      	movs	r3, #0
 1001eda:	2220      	movs	r2, #32
 1001edc:	0019      	movs	r1, r3
 1001ede:	4807      	ldr	r0, [pc, #28]	; (1001efc <CM0_Sleep+0x104>)
 1001ee0:	f7ff ff22 	bl	1001d28 <setlpmval>
        setlpmval(LPM_GPIO_WKHI, 0, 16, 0);
 1001ee4:	2300      	movs	r3, #0
 1001ee6:	2210      	movs	r2, #16
 1001ee8:	0019      	movs	r1, r3
 1001eea:	e7f3      	b.n	1001ed4 <CM0_Sleep+0xdc>
        time |= ((uint32_t)0x1 << 31);
 1001eec:	2380      	movs	r3, #128	; 0x80
 1001eee:	061b      	lsls	r3, r3, #24
 1001ef0:	4313      	orrs	r3, r2
 1001ef2:	e7bd      	b.n	1001e70 <CM0_Sleep+0x78>
 1001ef4:	000757fe 	.word	0x000757fe
 1001ef8:	000f8414 	.word	0x000f8414
 1001efc:	000f8410 	.word	0x000f8410
 1001f00:	00020a48 	.word	0x00020a48
 1001f04:	000f840c 	.word	0x000f840c
 1001f08:	000f8408 	.word	0x000f8408
 1001f0c:	000f847c 	.word	0x000f847c

01001f10 <enable_gpio_32>:

void enable_gpio_32(void)
{
 1001f10:	b510      	push	{r4, lr}
    uint32_t value = lpm_bt_read(LPMBT_CONTROL1);
 1001f12:	2001      	movs	r0, #1
 1001f14:	f7ff fef6 	bl	1001d04 <lpm_bt_read>
    value &= ~(1<<17);
 1001f18:	4902      	ldr	r1, [pc, #8]	; (1001f24 <enable_gpio_32+0x14>)
 1001f1a:	4001      	ands	r1, r0
    lpm_bt_write(LPMBT_CONTROL1, value);
 1001f1c:	2001      	movs	r0, #1
 1001f1e:	f7ff feb7 	bl	1001c90 <lpm_bt_write>
}
 1001f22:	bd10      	pop	{r4, pc}
 1001f24:	fffdffff 	.word	0xfffdffff

01001f28 <deinit_otp>:
 * @brief:  OTP deint
 * @param:  none
 * @return: none
 */
void deinit_otp(void)
{
 1001f28:	b510      	push	{r4, lr}
    ((void(*)())FUNC_DEINIT_OTP_ADDR)();
 1001f2a:	4b01      	ldr	r3, [pc, #4]	; (1001f30 <deinit_otp+0x8>)
 1001f2c:	4798      	blx	r3
}
 1001f2e:	bd10      	pop	{r4, pc}
 1001f30:	00004481 	.word	0x00004481

01001f34 <init_otp>:
 * @brief:  OTP init
 * @param:  none
 * @return: none
 */
void init_otp(void)
{
 1001f34:	b510      	push	{r4, lr}
    ((void(*)())FUNC_INIT_OTP_ADDR)();
 1001f36:	4b01      	ldr	r3, [pc, #4]	; (1001f3c <init_otp+0x8>)
 1001f38:	4798      	blx	r3
}
 1001f3a:	bd10      	pop	{r4, pc}
 1001f3c:	0000442d 	.word	0x0000442d

01001f40 <read_chip_life>:

uint32_t read_chip_life(void)
{
 1001f40:	b510      	push	{r4, lr}
    uint32_t life = 0;
    init_otp();
 1001f42:	f7ff fff7 	bl	1001f34 <init_otp>
    life = ((uint32_t(*)(void))FUNC_READ_CHIPLF_ADDR)();
 1001f46:	4b03      	ldr	r3, [pc, #12]	; (1001f54 <read_chip_life+0x14>)
 1001f48:	4798      	blx	r3
 1001f4a:	0004      	movs	r4, r0
    deinit_otp();
 1001f4c:	f7ff ffec 	bl	1001f28 <deinit_otp>
    return life;
}
 1001f50:	0020      	movs	r0, r4
 1001f52:	bd10      	pop	{r4, pc}
 1001f54:	000045e7 	.word	0x000045e7

01001f58 <read_chipid>:

void read_chipid(uint8_t *id)
{
 1001f58:	b510      	push	{r4, lr}
 1001f5a:	0004      	movs	r4, r0
    init_otp();
 1001f5c:	f7ff ffea 	bl	1001f34 <init_otp>
    ((void(*)(uint8_t *id))FUNC_READ_CHIPID_ADDR)(id);
 1001f60:	0020      	movs	r0, r4
 1001f62:	4b02      	ldr	r3, [pc, #8]	; (1001f6c <read_chipid+0x14>)
 1001f64:	4798      	blx	r3
    deinit_otp();
 1001f66:	f7ff ffdf 	bl	1001f28 <deinit_otp>
}
 1001f6a:	bd10      	pop	{r4, pc}
 1001f6c:	000045d9 	.word	0x000045d9

01001f70 <read_otp>:
 * @param:  *data
 * @param:  len
 * @return: none
 */
uint8_t read_otp(uint32_t addr, uint8_t *data, uint32_t len)
{
 1001f70:	b570      	push	{r4, r5, r6, lr}
 1001f72:	000d      	movs	r5, r1
 1001f74:	0016      	movs	r6, r2
 1001f76:	0004      	movs	r4, r0
    init_otp();
 1001f78:	f7ff ffdc 	bl	1001f34 <init_otp>
    ((uint8_t(*)(uint32_t addr, uint8_t *data, uint32_t len))FUNC_READ_OTP_ADDR)(addr, data, len);
 1001f7c:	0032      	movs	r2, r6
 1001f7e:	0029      	movs	r1, r5
 1001f80:	4b03      	ldr	r3, [pc, #12]	; (1001f90 <read_otp+0x20>)
 1001f82:	0020      	movs	r0, r4
 1001f84:	4798      	blx	r3
    deinit_otp();
 1001f86:	f7ff ffcf 	bl	1001f28 <deinit_otp>
    return SUCCESS;
}
 1001f8a:	2001      	movs	r0, #1
 1001f8c:	bd70      	pop	{r4, r5, r6, pc}
 1001f8e:	46c0      	nop			; (mov r8, r8)
 1001f90:	0000449d 	.word	0x0000449d

01001f94 <write_otp>:
 * @param:  *data
 * @param:  len
 * @return: SUCCESS or ERROR
 */
uint8_t write_otp(uint32_t addr, uint8_t *data, uint32_t len)
{
 1001f94:	b510      	push	{r4, lr}
    uint8_t rtn = 0;

    //step2:
    rtn = ((uint8_t(*)(uint32_t addr, uint8_t *data, uint32_t len))FUNC_WRITE_OTP_ADDR)(addr, data, len);
 1001f96:	4b01      	ldr	r3, [pc, #4]	; (1001f9c <write_otp+0x8>)
 1001f98:	4798      	blx	r3

    return rtn;
}
 1001f9a:	bd10      	pop	{r4, pc}
 1001f9c:	00004595 	.word	0x00004595

01001fa0 <SYSCTRL_AHBPeriphClockCmd>:
#include "yc_sysctrl.h"

void SYSCTRL_AHBPeriphClockCmd(uint32_t SYSCTRL_AHBPeriph, FunctionalState NewState)
{
    _ASSERT(IS_SYSCTRL_AHB_PERIPH(SYSCTRL_AHBPeriph));
 1001fa0:	4b0a      	ldr	r3, [pc, #40]	; (1001fcc <SYSCTRL_AHBPeriphClockCmd+0x2c>)
{
 1001fa2:	b570      	push	{r4, r5, r6, lr}
 1001fa4:	0004      	movs	r4, r0
 1001fa6:	000d      	movs	r5, r1
    _ASSERT(IS_SYSCTRL_AHB_PERIPH(SYSCTRL_AHBPeriph));
 1001fa8:	4218      	tst	r0, r3
 1001faa:	d104      	bne.n	1001fb6 <SYSCTRL_AHBPeriphClockCmd+0x16>
 1001fac:	4a08      	ldr	r2, [pc, #32]	; (1001fd0 <SYSCTRL_AHBPeriphClockCmd+0x30>)
 1001fae:	2105      	movs	r1, #5
 1001fb0:	4808      	ldr	r0, [pc, #32]	; (1001fd4 <SYSCTRL_AHBPeriphClockCmd+0x34>)
 1001fb2:	f7fe fb23 	bl	10005fc <_assert_handler>
 1001fb6:	4b08      	ldr	r3, [pc, #32]	; (1001fd8 <SYSCTRL_AHBPeriphClockCmd+0x38>)
    if (NewState == DISABLE)
    {
        SYSCTRL_CLK_CLS |= SYSCTRL_AHBPeriph;
 1001fb8:	681a      	ldr	r2, [r3, #0]
    if (NewState == DISABLE)
 1001fba:	2d00      	cmp	r5, #0
 1001fbc:	d102      	bne.n	1001fc4 <SYSCTRL_AHBPeriphClockCmd+0x24>
        SYSCTRL_CLK_CLS |= SYSCTRL_AHBPeriph;
 1001fbe:	4314      	orrs	r4, r2
 1001fc0:	601c      	str	r4, [r3, #0]
    }
    else
    {
        SYSCTRL_CLK_CLS &= ~SYSCTRL_AHBPeriph;
    }
}
 1001fc2:	bd70      	pop	{r4, r5, r6, pc}
        SYSCTRL_CLK_CLS &= ~SYSCTRL_AHBPeriph;
 1001fc4:	43a2      	bics	r2, r4
 1001fc6:	601a      	str	r2, [r3, #0]
}
 1001fc8:	e7fb      	b.n	1001fc2 <SYSCTRL_AHBPeriphClockCmd+0x22>
 1001fca:	46c0      	nop			; (mov r8, r8)
 1001fcc:	0007fffe 	.word	0x0007fffe
 1001fd0:	010056b4 	.word	0x010056b4
 1001fd4:	0100568a 	.word	0x0100568a
 1001fd8:	000f856c 	.word	0x000f856c

01001fdc <SYSCTRL_EnterSleep>:

void SYSCTRL_EnterSleep(SleepMode_TypeDef SleepMode)
{
 1001fdc:	b510      	push	{r4, lr}
    _ASSERT(IS_ALL_SLEEP_MODE(SleepMode));
 1001fde:	2802      	cmp	r0, #2
 1001fe0:	d004      	beq.n	1001fec <SYSCTRL_EnterSleep+0x10>
 1001fe2:	4a04      	ldr	r2, [pc, #16]	; (1001ff4 <SYSCTRL_EnterSleep+0x18>)
 1001fe4:	2112      	movs	r1, #18
 1001fe6:	4804      	ldr	r0, [pc, #16]	; (1001ff8 <SYSCTRL_EnterSleep+0x1c>)
 1001fe8:	f7fe fb08 	bl	10005fc <_assert_handler>
    *LPM_SLEEP = 0x5a;
 1001fec:	225a      	movs	r2, #90	; 0x5a
 1001fee:	4b03      	ldr	r3, [pc, #12]	; (1001ffc <SYSCTRL_EnterSleep+0x20>)
 1001ff0:	601a      	str	r2, [r3, #0]
}
 1001ff2:	bd10      	pop	{r4, pc}
 1001ff4:	010056ce 	.word	0x010056ce
 1001ff8:	0100568a 	.word	0x0100568a
 1001ffc:	000f8420 	.word	0x000f8420

01002000 <HCLKConfig_Div_None>:

void __NOINLINE HCLKConfig_Div_None(uint32_t HCLK_Div)
{
    QSPI_CTRL  |= (0x80);
 1002000:	2380      	movs	r3, #128	; 0x80
 1002002:	4a05      	ldr	r2, [pc, #20]	; (1002018 <HCLKConfig_Div_None+0x18>)
 1002004:	6811      	ldr	r1, [r2, #0]
 1002006:	430b      	orrs	r3, r1
    int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
 1002008:	210f      	movs	r1, #15
    QSPI_CTRL  |= (0x80);
 100200a:	6013      	str	r3, [r2, #0]
    int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
 100200c:	4a03      	ldr	r2, [pc, #12]	; (100201c <HCLKConfig_Div_None+0x1c>)
 100200e:	6813      	ldr	r3, [r2, #0]
 1002010:	438b      	bics	r3, r1
 1002012:	4318      	orrs	r0, r3
    SYSCTRL_HCLK_CON =  temp;
 1002014:	6010      	str	r0, [r2, #0]
}
 1002016:	4770      	bx	lr
 1002018:	000f881c 	.word	0x000f881c
 100201c:	000f8560 	.word	0x000f8560

01002020 <SYSCTRL_HCLKConfig>:

void SYSCTRL_HCLKConfig(uint32_t HCLK_Div)
{
    _ASSERT(IS_GET_SYSCTRL_HCLK_DIV(HCLK_Div));
 1002020:	2302      	movs	r3, #2
 1002022:	0002      	movs	r2, r0
{
 1002024:	b510      	push	{r4, lr}
    _ASSERT(IS_GET_SYSCTRL_HCLK_DIV(HCLK_Div));
 1002026:	439a      	bics	r2, r3
{
 1002028:	0004      	movs	r4, r0
    _ASSERT(IS_GET_SYSCTRL_HCLK_DIV(HCLK_Div));
 100202a:	2a00      	cmp	r2, #0
 100202c:	d009      	beq.n	1002042 <SYSCTRL_HCLKConfig+0x22>
 100202e:	2308      	movs	r3, #8
 1002030:	0002      	movs	r2, r0
 1002032:	439a      	bics	r2, r3
 1002034:	2a06      	cmp	r2, #6
 1002036:	d004      	beq.n	1002042 <SYSCTRL_HCLKConfig+0x22>
 1002038:	4a0c      	ldr	r2, [pc, #48]	; (100206c <SYSCTRL_HCLKConfig+0x4c>)
 100203a:	211f      	movs	r1, #31
 100203c:	480c      	ldr	r0, [pc, #48]	; (1002070 <SYSCTRL_HCLKConfig+0x50>)
 100203e:	f7fe fadd 	bl	10005fc <_assert_handler>
    __asm("CPSID i");
 1002042:	b672      	cpsid	i
    if (HCLK_Div == SYSCTRL_HCLK_Div_None)
 1002044:	2c00      	cmp	r4, #0
 1002046:	d109      	bne.n	100205c <SYSCTRL_HCLKConfig+0x3c>
    {
        uint32_t HCLKConfig_Div_None_addr = (uint32_t)HCLKConfig_Div_None;
        ((void(*)(void *, void *))FUNC_PREFETCH)(((uint32_t *)HCLKConfig_Div_None_addr), ((uint32_t *)(HCLKConfig_Div_None_addr + 64)));
 1002048:	480a      	ldr	r0, [pc, #40]	; (1002074 <SYSCTRL_HCLKConfig+0x54>)
 100204a:	4b0b      	ldr	r3, [pc, #44]	; (1002078 <SYSCTRL_HCLKConfig+0x58>)
 100204c:	0001      	movs	r1, r0
 100204e:	3140      	adds	r1, #64	; 0x40
 1002050:	4798      	blx	r3
        HCLKConfig_Div_None(HCLK_Div);
 1002052:	0020      	movs	r0, r4
 1002054:	f7ff ffd4 	bl	1002000 <HCLKConfig_Div_None>
    else
    {
        int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
        SYSCTRL_HCLK_CON =  temp;
    }
    __asm("CPSIE i");
 1002058:	b662      	cpsie	i
}
 100205a:	bd10      	pop	{r4, pc}
        int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
 100205c:	220f      	movs	r2, #15
 100205e:	4b07      	ldr	r3, [pc, #28]	; (100207c <SYSCTRL_HCLKConfig+0x5c>)
 1002060:	6818      	ldr	r0, [r3, #0]
 1002062:	4390      	bics	r0, r2
 1002064:	4320      	orrs	r0, r4
        SYSCTRL_HCLK_CON =  temp;
 1002066:	6018      	str	r0, [r3, #0]
 1002068:	e7f6      	b.n	1002058 <SYSCTRL_HCLKConfig+0x38>
 100206a:	46c0      	nop			; (mov r8, r8)
 100206c:	010056e1 	.word	0x010056e1
 1002070:	0100568a 	.word	0x0100568a
 1002074:	01002001 	.word	0x01002001
 1002078:	00004405 	.word	0x00004405
 100207c:	000f8560 	.word	0x000f8560

01002080 <SYSCTRL_GetClocksFreq>:

void SYSCTRL_GetClocksFreq(SYSCTRL_ClocksTypeDef *SYSCTRL_Clocks)
{
    SYSCTRL_Clocks->HCLK_Frequency = CPU_MHZ;
 1002080:	4b05      	ldr	r3, [pc, #20]	; (1002098 <SYSCTRL_GetClocksFreq+0x18>)
{
 1002082:	b510      	push	{r4, lr}
    SYSCTRL_Clocks->HCLK_Frequency = CPU_MHZ;
 1002084:	6819      	ldr	r1, [r3, #0]
 1002086:	230f      	movs	r3, #15
 1002088:	4019      	ands	r1, r3
{
 100208a:	0004      	movs	r4, r0
    SYSCTRL_Clocks->HCLK_Frequency = CPU_MHZ;
 100208c:	3102      	adds	r1, #2
 100208e:	4803      	ldr	r0, [pc, #12]	; (100209c <SYSCTRL_GetClocksFreq+0x1c>)
 1002090:	f001 ffd6 	bl	1004040 <__divsi3>
 1002094:	6020      	str	r0, [r4, #0]
}
 1002096:	bd10      	pop	{r4, pc}
 1002098:	000f8560 	.word	0x000f8560
 100209c:	0b71b000 	.word	0x0b71b000

010020a0 <SYSCTRL_EnableDpllClk>:
 10020a0:	4a0e      	ldr	r2, [pc, #56]	; (10020dc <SYSCTRL_EnableDpllClk+0x3c>)
 10020a2:	490f      	ldr	r1, [pc, #60]	; (10020e0 <SYSCTRL_EnableDpllClk+0x40>)
 10020a4:	6813      	ldr	r3, [r2, #0]

void SYSCTRL_EnableDpllClk(void)
{
 10020a6:	b510      	push	{r4, lr}
 10020a8:	400b      	ands	r3, r1
 10020aa:	6013      	str	r3, [r2, #0]
    enable_clock(CLKCLS_BT);
    SYSCTRL_ROM_SWITCH = 0x94;
    delay(500);
 10020ac:	20fa      	movs	r0, #250	; 0xfa
    SYSCTRL_ROM_SWITCH = 0x94;
 10020ae:	2294      	movs	r2, #148	; 0x94
 10020b0:	4b0c      	ldr	r3, [pc, #48]	; (10020e4 <SYSCTRL_EnableDpllClk+0x44>)
    delay(500);
 10020b2:	0040      	lsls	r0, r0, #1
    SYSCTRL_ROM_SWITCH = 0x94;
 10020b4:	701a      	strb	r2, [r3, #0]
    delay(500);
 10020b6:	f7fe f946 	bl	1000346 <delay>

    *(volatile byte *)0xc4ab1 = 0x7f;
 10020ba:	227f      	movs	r2, #127	; 0x7f
 10020bc:	4b0a      	ldr	r3, [pc, #40]	; (10020e8 <SYSCTRL_EnableDpllClk+0x48>)
    *(volatile byte *)0xc4ab2 = 0xff;
    *(volatile byte *)0xc4ab3 = 0xff;

    *(volatile byte *)0xc40c3 = 0xb1;
 10020be:	21b1      	movs	r1, #177	; 0xb1
    *(volatile byte *)0xc4ab1 = 0x7f;
 10020c0:	701a      	strb	r2, [r3, #0]
    *(volatile byte *)0xc4ab2 = 0xff;
 10020c2:	23ff      	movs	r3, #255	; 0xff
 10020c4:	4a09      	ldr	r2, [pc, #36]	; (10020ec <SYSCTRL_EnableDpllClk+0x4c>)
 10020c6:	7013      	strb	r3, [r2, #0]
    *(volatile byte *)0xc4ab3 = 0xff;
 10020c8:	4a09      	ldr	r2, [pc, #36]	; (10020f0 <SYSCTRL_EnableDpllClk+0x50>)
 10020ca:	7013      	strb	r3, [r2, #0]
    *(volatile byte *)0xc40c3 = 0xb1;
 10020cc:	4a09      	ldr	r2, [pc, #36]	; (10020f4 <SYSCTRL_EnableDpllClk+0x54>)
 10020ce:	7011      	strb	r1, [r2, #0]
    *(volatile byte *)0xc40c4 = 0x4a;
 10020d0:	4a09      	ldr	r2, [pc, #36]	; (10020f8 <SYSCTRL_EnableDpllClk+0x58>)
 10020d2:	3967      	subs	r1, #103	; 0x67
 10020d4:	7011      	strb	r1, [r2, #0]

    BT_CLKPLL_EN = 0xff;
 10020d6:	4a09      	ldr	r2, [pc, #36]	; (10020fc <SYSCTRL_EnableDpllClk+0x5c>)
 10020d8:	7013      	strb	r3, [r2, #0]
}
 10020da:	bd10      	pop	{r4, pc}
 10020dc:	000f856c 	.word	0x000f856c
 10020e0:	ffffdfff 	.word	0xffffdfff
 10020e4:	000f853c 	.word	0x000f853c
 10020e8:	000c4ab1 	.word	0x000c4ab1
 10020ec:	000c4ab2 	.word	0x000c4ab2
 10020f0:	000c4ab3 	.word	0x000c4ab3
 10020f4:	000c40c3 	.word	0x000c40c3
 10020f8:	000c40c4 	.word	0x000c40c4
 10020fc:	000c8905 	.word	0x000c8905

01002100 <USB_OTG_WritePacket>:

USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev,
                                uint8_t             *src,
                                uint8_t             ch_ep_num,
                                uint8_t            len)
{
 1002100:	b510      	push	{r4, lr}
    USB_OTG_STS status = USB_OTG_OK;
    uint8_t i = 0;

    if (pdev->cfg.dma_enable == 0)
 1002102:	78c4      	ldrb	r4, [r0, #3]
 1002104:	2c00      	cmp	r4, #0
 1002106:	d105      	bne.n	1002114 <USB_OTG_WritePacket+0x14>
    {
        for (i = 0; i < len; i++)
        {
            USB_OTG_WRITE_REG8(pdev->regs.ep[ch_ep_num], *src++);
 1002108:	3204      	adds	r2, #4
 100210a:	0092      	lsls	r2, r2, #2
 100210c:	18cb      	adds	r3, r1, r3
 100210e:	1882      	adds	r2, r0, r2
        for (i = 0; i < len; i++)
 1002110:	4299      	cmp	r1, r3
 1002112:	d101      	bne.n	1002118 <USB_OTG_WritePacket+0x18>
        }
    }

    return status;
}
 1002114:	2000      	movs	r0, #0
 1002116:	bd10      	pop	{r4, pc}
            USB_OTG_WRITE_REG8(pdev->regs.ep[ch_ep_num], *src++);
 1002118:	7808      	ldrb	r0, [r1, #0]
 100211a:	6854      	ldr	r4, [r2, #4]
 100211c:	3101      	adds	r1, #1
 100211e:	7020      	strb	r0, [r4, #0]
 1002120:	e7f6      	b.n	1002110 <USB_OTG_WritePacket+0x10>
	...

01002124 <USB_OTG_ReadPacket>:
    uint8_t i = 0;
    uint8_t count8b = len ;
    uint8_t *data_buff = (uint8_t *)dest;
    for (i = 0; i < count8b; i++, data_buff++)
    {
        *data_buff = USB_OTG_READ_REG8(CORE_USB_EP(ch_ep_num));
 1002124:	4804      	ldr	r0, [pc, #16]	; (1002138 <USB_OTG_ReadPacket+0x14>)
 1002126:	18cb      	adds	r3, r1, r3
 1002128:	1812      	adds	r2, r2, r0
    for (i = 0; i < count8b; i++, data_buff++)
 100212a:	4299      	cmp	r1, r3
 100212c:	d100      	bne.n	1002130 <USB_OTG_ReadPacket+0xc>
    }
}
 100212e:	4770      	bx	lr
        *data_buff = USB_OTG_READ_REG8(CORE_USB_EP(ch_ep_num));
 1002130:	7810      	ldrb	r0, [r2, #0]
 1002132:	7008      	strb	r0, [r1, #0]
    for (i = 0; i < count8b; i++, data_buff++)
 1002134:	3101      	adds	r1, #1
 1002136:	e7f8      	b.n	100212a <USB_OTG_ReadPacket+0x6>
 1002138:	000f6018 	.word	0x000f6018

0100213c <USB_OTG_SelectCore>:
#else
    pdev->cfg.dma_enable       = 0;
#endif

    /* at startup the core is in FS mode */
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 100213c:	2301      	movs	r3, #1
 100213e:	8043      	strh	r3, [r0, #2]
    pdev->cfg.dma_enable       = 0;
 1002140:	333f      	adds	r3, #63	; 0x3f
 1002142:	8083      	strh	r3, [r0, #4]
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;


    /* initialize device cfg following its address */
    if (coreID == USB_OTG_FS_CORE_ID)
 1002144:	2901      	cmp	r1, #1
 1002146:	d11e      	bne.n	1002186 <USB_OTG_SelectCore+0x4a>
    {
        baseAddress                = USB_OTG_FS_BASE_ADDR;
        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
        pdev->cfg.dev_endpoints    = 4 ;
 1002148:	2204      	movs	r2, #4
        pdev->cfg.TotalFifoSize    = 64; /* in 8-bits */
 100214a:	80c3      	strh	r3, [r0, #6]
        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
 100214c:	3b3e      	subs	r3, #62	; 0x3e
        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 100214e:	72c1      	strb	r1, [r0, #11]
        pdev->cfg.dev_endpoints    = 4 ;
 1002150:	7042      	strb	r2, [r0, #1]
        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
 1002152:	7203      	strb	r3, [r0, #8]
        pdev->cfg.low_power        = 1;
#endif
    }

    /* Common USB Registers */
    pdev ->regs.CTRLREGS = (USB_OTG_CTRLREGS *)CORE_USB_CONFIG;
 1002154:	23f6      	movs	r3, #246	; 0xf6
 1002156:	031b      	lsls	r3, r3, #12
 1002158:	60c3      	str	r3, [r0, #12]
    pdev ->regs.xferctl = (USB_OTG_XFERCTL *)CORE_USB_TRIG;
 100215a:	4b10      	ldr	r3, [pc, #64]	; (100219c <USB_OTG_SelectCore+0x60>)
 100215c:	6103      	str	r3, [r0, #16]
    /* FIFOS */
    for (i = 0; i < NUM_EP_FIFO; i++)
    {
        pdev->regs.ep[i] = (uint8_t *)(CORE_USB_EP(i));
 100215e:	4b10      	ldr	r3, [pc, #64]	; (10021a0 <USB_OTG_SelectCore+0x64>)
 1002160:	6143      	str	r3, [r0, #20]
 1002162:	4b10      	ldr	r3, [pc, #64]	; (10021a4 <USB_OTG_SelectCore+0x68>)
 1002164:	6183      	str	r3, [r0, #24]
 1002166:	4b10      	ldr	r3, [pc, #64]	; (10021a8 <USB_OTG_SelectCore+0x6c>)
 1002168:	61c3      	str	r3, [r0, #28]
 100216a:	4b10      	ldr	r3, [pc, #64]	; (10021ac <USB_OTG_SelectCore+0x70>)
 100216c:	6203      	str	r3, [r0, #32]
    }
    /* fifo len*/
    for (i = 0; i < NUM_EP_FIFO; i++)
    {
        pdev->regs.LENREGS[i] = (uint8_t *)(CORE_USB_EP_LEN(i));
 100216e:	4b10      	ldr	r3, [pc, #64]	; (10021b0 <USB_OTG_SelectCore+0x74>)
 1002170:	6243      	str	r3, [r0, #36]	; 0x24
 1002172:	4b10      	ldr	r3, [pc, #64]	; (10021b4 <USB_OTG_SelectCore+0x78>)
 1002174:	6283      	str	r3, [r0, #40]	; 0x28
 1002176:	4b10      	ldr	r3, [pc, #64]	; (10021b8 <USB_OTG_SelectCore+0x7c>)
 1002178:	62c3      	str	r3, [r0, #44]	; 0x2c
 100217a:	4b10      	ldr	r3, [pc, #64]	; (10021bc <USB_OTG_SelectCore+0x80>)
 100217c:	6303      	str	r3, [r0, #48]	; 0x30
    }
    pdev ->regs.STATUSEGS = (USB_OTG_STATUSREGS *)CORE_USB_STALL_STATUS;
 100217e:	4b10      	ldr	r3, [pc, #64]	; (10021c0 <USB_OTG_SelectCore+0x84>)
 1002180:	6343      	str	r3, [r0, #52]	; 0x34
    return status;
}
 1002182:	2000      	movs	r0, #0
 1002184:	4770      	bx	lr
    else if (coreID == USB_OTG_HS_CORE_ID)
 1002186:	2900      	cmp	r1, #0
 1002188:	d1e4      	bne.n	1002154 <USB_OTG_SelectCore+0x18>
        pdev->cfg.host_channels    = 8 ;
 100218a:	2381      	movs	r3, #129	; 0x81
 100218c:	00db      	lsls	r3, r3, #3
 100218e:	8003      	strh	r3, [r0, #0]
        pdev->cfg.TotalFifoSize    = 512;/* in 8-bits */
 1002190:	2380      	movs	r3, #128	; 0x80
 1002192:	009b      	lsls	r3, r3, #2
        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;
 1002194:	72c1      	strb	r1, [r0, #11]
        pdev->cfg.TotalFifoSize    = 512;/* in 8-bits */
 1002196:	80c3      	strh	r3, [r0, #6]
 1002198:	e7dc      	b.n	1002154 <USB_OTG_SelectCore+0x18>
 100219a:	46c0      	nop			; (mov r8, r8)
 100219c:	000f6010 	.word	0x000f6010
 10021a0:	000f6018 	.word	0x000f6018
 10021a4:	000f6019 	.word	0x000f6019
 10021a8:	000f601a 	.word	0x000f601a
 10021ac:	000f601b 	.word	0x000f601b
 10021b0:	000f6020 	.word	0x000f6020
 10021b4:	000f6021 	.word	0x000f6021
 10021b8:	000f6022 	.word	0x000f6022
 10021bc:	000f6023 	.word	0x000f6023
 10021c0:	000f6025 	.word	0x000f6025

010021c4 <USB_OTG_CoreInit>:
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
    USB_OTG_STS status = USB_OTG_OK;
    return status;
}
 10021c4:	2000      	movs	r0, #0
 10021c6:	4770      	bx	lr

010021c8 <USB_OTG_SetCurrentMode>:
* @param  pdev : Selected device
* @param  mode :  (Host/device)only device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev, uint8_t mode)
{
 10021c8:	b510      	push	{r4, lr}
    USB_OTG_STS status = USB_OTG_OK;
    if (mode == HOST_MODE)
    {

    }
    else if (mode == DEVICE_MODE)
 10021ca:	2900      	cmp	r1, #0
 10021cc:	d108      	bne.n	10021e0 <USB_OTG_SetCurrentMode+0x18>
    {
#ifdef USE_DEVICE_MODE
        pdev->dev.out_ep[0].xfer_buff = pdev->dev.setup_packet;
 10021ce:	0002      	movs	r2, r0
 10021d0:	0003      	movs	r3, r0
 10021d2:	3265      	adds	r2, #101	; 0x65
 10021d4:	33dc      	adds	r3, #220	; 0xdc
 10021d6:	32ff      	adds	r2, #255	; 0xff
 10021d8:	601a      	str	r2, [r3, #0]
        pdev->dev.out_ep[0].xfer_len = 8;
 10021da:	2308      	movs	r3, #8
 10021dc:	30e4      	adds	r0, #228	; 0xe4
 10021de:	6003      	str	r3, [r0, #0]
#endif
    }
    delay_us(50);
 10021e0:	2032      	movs	r0, #50	; 0x32
 10021e2:	f7fe fdbf 	bl	1000d64 <delay_us>

    return status;
}
 10021e6:	2000      	movs	r0, #0
 10021e8:	bd10      	pop	{r4, pc}

010021ea <USB_OTG_EPActivate>:
* @brief  USB_OTG_EPActivate : Activates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev, USB_OTG_EP *ep)
{
 10021ea:	2301      	movs	r3, #1
 10021ec:	68c2      	ldr	r2, [r0, #12]
 10021ee:	7808      	ldrb	r0, [r1, #0]
        USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS->IRQ_MASK1, intr_rxtxe.d8, 0);
    }
    else
    {
        intr_rxtxe.d8 = 1 << ep->num;
        USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS ->IRQ_MASK1, intr_rxtxe.d8, 0);
 10021f0:	7851      	ldrb	r1, [r2, #1]
 10021f2:	4083      	lsls	r3, r0
 10021f4:	43db      	mvns	r3, r3
 10021f6:	b25b      	sxtb	r3, r3
 10021f8:	400b      	ands	r3, r1
    }
    return status;
}
 10021fa:	2000      	movs	r0, #0
        USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS ->IRQ_MASK1, intr_rxtxe.d8, 0);
 10021fc:	7053      	strb	r3, [r2, #1]
}
 10021fe:	4770      	bx	lr

01002200 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev, USB_OTG_EP *ep)
{
 1002200:	2301      	movs	r3, #1
 1002202:	780a      	ldrb	r2, [r1, #0]
    {
        intr_rxtxe.d8 = 1 << ep->num;
        USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS ->IRQ_MASK1, 0, intr_rxtxe.d8);
    }
    return status;
}
 1002204:	4093      	lsls	r3, r2
 1002206:	68c2      	ldr	r2, [r0, #12]
 1002208:	b2db      	uxtb	r3, r3
        USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS ->IRQ_MASK1, 0, intr_rxtxe.d8);
 100220a:	7851      	ldrb	r1, [r2, #1]
}
 100220c:	2000      	movs	r0, #0
        USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS ->IRQ_MASK1, 0, intr_rxtxe.d8);
 100220e:	430b      	orrs	r3, r1
 1002210:	7053      	strb	r3, [r2, #1]
}
 1002212:	4770      	bx	lr

01002214 <USB_OTG_GetMode>:
* @retval current mode
*/
uint8_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
    return DEVICE_MODE;
}
 1002214:	2000      	movs	r0, #0
 1002216:	4770      	bx	lr

01002218 <USB_OTG_IsDeviceMode>:
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
    return (USB_OTG_GetMode(pdev) != HOST_MODE);
}
 1002218:	2001      	movs	r0, #1
 100221a:	4770      	bx	lr

0100221c <USB_OTG_EP0StartXfer>:
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
extern uint8_t out0_data_len;
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev, USB_OTG_EP *ep)
{
 100221c:	b570      	push	{r4, r5, r6, lr}
    USB_OTG_STS  status = USB_OTG_OK;
    uint8_t rx_count;
    uint32_t fifoemptymsk = 0;
    /* IN endpoint */
    if (ep->is_in == 1)
 100221e:	784b      	ldrb	r3, [r1, #1]
{
 1002220:	0005      	movs	r5, r0
 1002222:	000c      	movs	r4, r1
 1002224:	6908      	ldr	r0, [r1, #16]
    if (ep->is_in == 1)
 1002226:	2b01      	cmp	r3, #1
 1002228:	d131      	bne.n	100228e <USB_OTG_EP0StartXfer+0x72>
    {
        ep->rem_data_len = ep->xfer_len - ep->xfer_count;
 100222a:	6949      	ldr	r1, [r1, #20]
 100222c:	1a42      	subs	r2, r0, r1
 100222e:	61a2      	str	r2, [r4, #24]
        /* Zero Length Packet? */
        if (ep->rem_data_len == 0)
 1002230:	d10f      	bne.n	1002252 <USB_OTG_EP0StartXfer+0x36>
        {
            if (ep->xfer_len != 0 && ep->xfer_len % ep->maxpacket == 0)
 1002232:	2800      	cmp	r0, #0
 1002234:	d00b      	beq.n	100224e <USB_OTG_EP0StartXfer+0x32>
 1002236:	79e1      	ldrb	r1, [r4, #7]
 1002238:	f001 fefe 	bl	1004038 <__aeabi_uidivmod>
 100223c:	2900      	cmp	r1, #0
 100223e:	d106      	bne.n	100224e <USB_OTG_EP0StartXfer+0x32>
*/

USB_OTG_STS USB_OTG_EPReply_Zerolen(USB_OTG_CORE_HANDLE *pdev, USB_OTG_EP *ep)
{
    USB_OTG_STS status = USB_OTG_OK;
    USB_OTG_WRITE_REG8(&pdev->regs.xferctl ->TRIG, 0x10 << (ep ->num));
 1002240:	2310      	movs	r3, #16
 1002242:	7820      	ldrb	r0, [r4, #0]
 1002244:	692a      	ldr	r2, [r5, #16]
 1002246:	4083      	lsls	r3, r0
 1002248:	b2db      	uxtb	r3, r3
 100224a:	7013      	strb	r3, [r2, #0]
                ep->xfer_len = 0;
 100224c:	6121      	str	r1, [r4, #16]
}
 100224e:	2000      	movs	r0, #0
 1002250:	bd70      	pop	{r4, r5, r6, pc}
 1002252:	68a0      	ldr	r0, [r4, #8]
            if (ep->rem_data_len > ep->maxpacket)
 1002254:	79e3      	ldrb	r3, [r4, #7]
 1002256:	1841      	adds	r1, r0, r1
 1002258:	429a      	cmp	r2, r3
 100225a:	d90f      	bls.n	100227c <USB_OTG_EP0StartXfer+0x60>
                USB_OTG_WritePacket(pdev,
 100225c:	2200      	movs	r2, #0
 100225e:	0028      	movs	r0, r5
 1002260:	f7ff ff4e 	bl	1002100 <USB_OTG_WritePacket>
                ep->xfer_count += ep->maxpacket;
 1002264:	6962      	ldr	r2, [r4, #20]
 1002266:	79e3      	ldrb	r3, [r4, #7]
 1002268:	189b      	adds	r3, r3, r2
                ep->rem_data_len = ep->xfer_len - ep->xfer_count;
 100226a:	6922      	ldr	r2, [r4, #16]
                ep->xfer_count += ep->maxpacket;
 100226c:	6163      	str	r3, [r4, #20]
                ep->rem_data_len = ep->xfer_len - ep->xfer_count;
 100226e:	1ad3      	subs	r3, r2, r3
                ep->rem_data_len = 0;
 1002270:	61a3      	str	r3, [r4, #24]
                USB_OTG_TRIG(pdev, ep);
 1002272:	0021      	movs	r1, r4
 1002274:	0028      	movs	r0, r5
 1002276:	f000 f897 	bl	10023a8 <USB_OTG_TRIG>
 100227a:	e7e8      	b.n	100224e <USB_OTG_EP0StartXfer+0x32>
                USB_OTG_WritePacket(pdev,
 100227c:	b2d3      	uxtb	r3, r2
 100227e:	0028      	movs	r0, r5
 1002280:	2200      	movs	r2, #0
 1002282:	f7ff ff3d 	bl	1002100 <USB_OTG_WritePacket>
                ep->xfer_count = ep->xfer_len;
 1002286:	6923      	ldr	r3, [r4, #16]
 1002288:	6163      	str	r3, [r4, #20]
                ep->rem_data_len = 0;
 100228a:	2300      	movs	r3, #0
 100228c:	e7f0      	b.n	1002270 <USB_OTG_EP0StartXfer+0x54>
        if (ep->xfer_len == 0)
 100228e:	2800      	cmp	r0, #0
 1002290:	d0dd      	beq.n	100224e <USB_OTG_EP0StartXfer+0x32>
            if (out0_data_len)
 1002292:	4b0a      	ldr	r3, [pc, #40]	; (10022bc <USB_OTG_EP0StartXfer+0xa0>)
 1002294:	781b      	ldrb	r3, [r3, #0]
 1002296:	2b00      	cmp	r3, #0
 1002298:	d101      	bne.n	100229e <USB_OTG_EP0StartXfer+0x82>
                rx_count = USB_OTG_READ_REG8(pdev->regs.LENREGS[0]);
 100229a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 100229c:	781b      	ldrb	r3, [r3, #0]
            USB_OTG_ReadPacket(pdev, ep->xfer_buff + ep->xfer_count, ep->num, ep->xfer_len);
 100229e:	b2c3      	uxtb	r3, r0
 10022a0:	68a1      	ldr	r1, [r4, #8]
 10022a2:	6960      	ldr	r0, [r4, #20]
 10022a4:	7822      	ldrb	r2, [r4, #0]
 10022a6:	1809      	adds	r1, r1, r0
 10022a8:	0028      	movs	r0, r5
 10022aa:	f7ff ff3b 	bl	1002124 <USB_OTG_ReadPacket>
            ep->xfer_count = 0;
 10022ae:	2300      	movs	r3, #0
            ep->xfer_buff = pdev->dev.setup_packet;
 10022b0:	3565      	adds	r5, #101	; 0x65
 10022b2:	35ff      	adds	r5, #255	; 0xff
            ep->xfer_count = 0;
 10022b4:	6163      	str	r3, [r4, #20]
            ep->xfer_buff = pdev->dev.setup_packet;
 10022b6:	60a5      	str	r5, [r4, #8]
 10022b8:	e7c9      	b.n	100224e <USB_OTG_EP0StartXfer+0x32>
 10022ba:	46c0      	nop			; (mov r8, r8)
 10022bc:	00020a50 	.word	0x00020a50

010022c0 <USB_OTG_EPStartXfer>:
{
 10022c0:	b570      	push	{r4, r5, r6, lr}
    if (ep->is_in == 1)
 10022c2:	784b      	ldrb	r3, [r1, #1]
{
 10022c4:	0006      	movs	r6, r0
 10022c6:	000c      	movs	r4, r1
 10022c8:	780a      	ldrb	r2, [r1, #0]
    if (ep->is_in == 1)
 10022ca:	2b01      	cmp	r3, #1
 10022cc:	d150      	bne.n	1002370 <USB_OTG_EPStartXfer+0xb0>
        if ((pdev->cfg.dma_enable == 0) || ((USB_OTG_DEV_DMA_EP_NUM & 0x07) != ep->num))
 10022ce:	78c3      	ldrb	r3, [r0, #3]
 10022d0:	2b00      	cmp	r3, #0
 10022d2:	d001      	beq.n	10022d8 <USB_OTG_EPStartXfer+0x18>
 10022d4:	2a01      	cmp	r2, #1
 10022d6:	d01c      	beq.n	1002312 <USB_OTG_EPStartXfer+0x52>
            ep->rem_data_len = ep->xfer_len - ep->xfer_count;
 10022d8:	6961      	ldr	r1, [r4, #20]
 10022da:	6923      	ldr	r3, [r4, #16]
 10022dc:	68a0      	ldr	r0, [r4, #8]
 10022de:	1a5d      	subs	r5, r3, r1
            if (ep->rem_data_len == ep->maxpacket)
 10022e0:	79e3      	ldrb	r3, [r4, #7]
            ep->rem_data_len = ep->xfer_len - ep->xfer_count;
 10022e2:	61a5      	str	r5, [r4, #24]
 10022e4:	1841      	adds	r1, r0, r1
            if (ep->rem_data_len == ep->maxpacket)
 10022e6:	429d      	cmp	r5, r3
 10022e8:	d115      	bne.n	1002316 <USB_OTG_EPStartXfer+0x56>
                USB_OTG_WritePacket(pdev,
 10022ea:	002b      	movs	r3, r5
 10022ec:	0030      	movs	r0, r6
 10022ee:	f7ff ff07 	bl	1002100 <USB_OTG_WritePacket>
                ep->xfer_count += ep->maxpacket;
 10022f2:	6962      	ldr	r2, [r4, #20]
 10022f4:	79e3      	ldrb	r3, [r4, #7]
                USB_OTG_TRIG(pdev, ep);
 10022f6:	0021      	movs	r1, r4
                ep->xfer_count += ep->maxpacket;
 10022f8:	18d3      	adds	r3, r2, r3
 10022fa:	6163      	str	r3, [r4, #20]
                USB_OTG_TRIG(pdev, ep);
 10022fc:	0030      	movs	r0, r6
 10022fe:	f000 f853 	bl	10023a8 <USB_OTG_TRIG>
                ep->xfer_count = ep->xfer_len;
 1002302:	6923      	ldr	r3, [r4, #16]
                pdev->dev.zero_replay_flag = 1;
 1002304:	2201      	movs	r2, #1
                ep->xfer_count = ep->xfer_len;
 1002306:	6163      	str	r3, [r4, #20]
                ep->rem_data_len = 0;
 1002308:	2300      	movs	r3, #0
 100230a:	61a3      	str	r3, [r4, #24]
                pdev->dev.zero_replay_flag = 1;
 100230c:	337d      	adds	r3, #125	; 0x7d
 100230e:	33ff      	adds	r3, #255	; 0xff
 1002310:	54f2      	strb	r2, [r6, r3]
}
 1002312:	2000      	movs	r0, #0
 1002314:	bd70      	pop	{r4, r5, r6, pc}
            else if (ep->rem_data_len == 0)
 1002316:	2d00      	cmp	r5, #0
 1002318:	d107      	bne.n	100232a <USB_OTG_EPStartXfer+0x6a>
                USB_OTG_WritePacket(pdev,
 100231a:	002b      	movs	r3, r5
 100231c:	0030      	movs	r0, r6
 100231e:	f7ff feef 	bl	1002100 <USB_OTG_WritePacket>
                ep->xfer_count = ep->xfer_len;
 1002322:	6923      	ldr	r3, [r4, #16]
                ep->rem_data_len = 0;
 1002324:	61a5      	str	r5, [r4, #24]
                ep->xfer_count = ep->xfer_len;
 1002326:	6163      	str	r3, [r4, #20]
 1002328:	e7f3      	b.n	1002312 <USB_OTG_EPStartXfer+0x52>
                if (ep->rem_data_len > ep->maxpacket)
 100232a:	429d      	cmp	r5, r3
 100232c:	d913      	bls.n	1002356 <USB_OTG_EPStartXfer+0x96>
                    USB_OTG_WritePacket(pdev,
 100232e:	0030      	movs	r0, r6
 1002330:	f7ff fee6 	bl	1002100 <USB_OTG_WritePacket>
                    USB_OTG_TRIG(pdev, ep);
 1002334:	0021      	movs	r1, r4
 1002336:	0030      	movs	r0, r6
 1002338:	f000 f836 	bl	10023a8 <USB_OTG_TRIG>
                    ep->xfer_count += ep->maxpacket;
 100233c:	6963      	ldr	r3, [r4, #20]
 100233e:	79e2      	ldrb	r2, [r4, #7]
 1002340:	18d2      	adds	r2, r2, r3
                    if (ep->xfer_len >= ep->xfer_count)
 1002342:	6923      	ldr	r3, [r4, #16]
                    ep->xfer_count += ep->maxpacket;
 1002344:	6162      	str	r2, [r4, #20]
                    if (ep->xfer_len >= ep->xfer_count)
 1002346:	429a      	cmp	r2, r3
 1002348:	d801      	bhi.n	100234e <USB_OTG_EPStartXfer+0x8e>
            ep->rem_data_len = ep->xfer_count - ep->xfer_len;
 100234a:	1a9b      	subs	r3, r3, r2
 100234c:	e00e      	b.n	100236c <USB_OTG_EPStartXfer+0xac>
                        ep->rem_data_len = 0;
 100234e:	2200      	movs	r2, #0
                        ep->xfer_count = ep->xfer_len;
 1002350:	6163      	str	r3, [r4, #20]
                        ep->rem_data_len = 0;
 1002352:	61a2      	str	r2, [r4, #24]
 1002354:	e7dd      	b.n	1002312 <USB_OTG_EPStartXfer+0x52>
                    USB_OTG_WritePacket(pdev,
 1002356:	b2eb      	uxtb	r3, r5
 1002358:	0030      	movs	r0, r6
 100235a:	f7ff fed1 	bl	1002100 <USB_OTG_WritePacket>
                    USB_OTG_TRIG(pdev, ep);
 100235e:	0021      	movs	r1, r4
 1002360:	0030      	movs	r0, r6
 1002362:	f000 f821 	bl	10023a8 <USB_OTG_TRIG>
                    ep->xfer_count = ep->xfer_len;
 1002366:	6923      	ldr	r3, [r4, #16]
 1002368:	6163      	str	r3, [r4, #20]
                    ep->rem_data_len = 0;
 100236a:	2300      	movs	r3, #0
            ep->rem_data_len = ep->xfer_count - ep->xfer_len;
 100236c:	61a3      	str	r3, [r4, #24]
 100236e:	e7d0      	b.n	1002312 <USB_OTG_EPStartXfer+0x52>
        rx_count = USB_OTG_READ_REG8(pdev->regs.LENREGS[ep ->num]);
 1002370:	0013      	movs	r3, r2
 1002372:	3308      	adds	r3, #8
 1002374:	009b      	lsls	r3, r3, #2
 1002376:	18c3      	adds	r3, r0, r3
 1002378:	685b      	ldr	r3, [r3, #4]
 100237a:	781d      	ldrb	r5, [r3, #0]
        USB_OTG_ReadPacket(pdev, ep->xfer_buff + ep->xfer_count, ep->num, rx_count);
 100237c:	688b      	ldr	r3, [r1, #8]
 100237e:	6949      	ldr	r1, [r1, #20]
        rx_count = USB_OTG_READ_REG8(pdev->regs.LENREGS[ep ->num]);
 1002380:	b2ed      	uxtb	r5, r5
        USB_OTG_ReadPacket(pdev, ep->xfer_buff + ep->xfer_count, ep->num, rx_count);
 1002382:	1859      	adds	r1, r3, r1
 1002384:	002b      	movs	r3, r5
 1002386:	f7ff fecd 	bl	1002124 <USB_OTG_ReadPacket>
        data_len = rx_count;
 100238a:	4a06      	ldr	r2, [pc, #24]	; (10023a4 <USB_OTG_EPStartXfer+0xe4>)
        ep->xfer_count += rx_count;
 100238c:	6963      	ldr	r3, [r4, #20]
        data_len = rx_count;
 100238e:	7015      	strb	r5, [r2, #0]
        if (ep->xfer_len <= ep->xfer_count)
 1002390:	6922      	ldr	r2, [r4, #16]
        ep->xfer_count += rx_count;
 1002392:	18eb      	adds	r3, r5, r3
 1002394:	6163      	str	r3, [r4, #20]
        if (ep->xfer_len <= ep->xfer_count)
 1002396:	4293      	cmp	r3, r2
 1002398:	d2d7      	bcs.n	100234a <USB_OTG_EPStartXfer+0x8a>
            ep->rem_data_len = 0;
 100239a:	2200      	movs	r2, #0
            ep->xfer_len = ep->xfer_count;
 100239c:	6123      	str	r3, [r4, #16]
            ep->rem_data_len = 0;
 100239e:	61a2      	str	r2, [r4, #24]
 10023a0:	e7b7      	b.n	1002312 <USB_OTG_EPStartXfer+0x52>
 10023a2:	46c0      	nop			; (mov r8, r8)
 10023a4:	00020ab1 	.word	0x00020ab1

010023a8 <USB_OTG_TRIG>:
    USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_NAK);
 10023a8:	2340      	movs	r3, #64	; 0x40
 10023aa:	4a0c      	ldr	r2, [pc, #48]	; (10023dc <USB_OTG_TRIG+0x34>)
 10023ac:	480c      	ldr	r0, [pc, #48]	; (10023e0 <USB_OTG_TRIG+0x38>)
{
 10023ae:	b510      	push	{r4, lr}
    USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_NAK);
 10023b0:	7013      	strb	r3, [r2, #0]
        if (USB_OTG_READ_REG8(CORE_USB_STATUS) & USB_STATUS_NAK)  break;
 10023b2:	7814      	ldrb	r4, [r2, #0]
 10023b4:	421c      	tst	r4, r3
 10023b6:	d102      	bne.n	10023be <USB_OTG_TRIG+0x16>
 10023b8:	3801      	subs	r0, #1
    for (i = 0; i < 10000; i++)
 10023ba:	2800      	cmp	r0, #0
 10023bc:	d1f9      	bne.n	10023b2 <USB_OTG_TRIG+0xa>
    USB_OTG_WRITE_REG8(CORE_USB_FIFO_EMPTY, 1 << ep ->num);
 10023be:	2301      	movs	r3, #1
 10023c0:	0018      	movs	r0, r3
 10023c2:	780a      	ldrb	r2, [r1, #0]
 10023c4:	4090      	lsls	r0, r2
 10023c6:	b2c2      	uxtb	r2, r0
 10023c8:	4806      	ldr	r0, [pc, #24]	; (10023e4 <USB_OTG_TRIG+0x3c>)
 10023ca:	7002      	strb	r2, [r0, #0]
    USB_OTG_WRITE_REG8(CORE_USB_TRIG, 1 << ep ->num);
 10023cc:	780a      	ldrb	r2, [r1, #0]
}
 10023ce:	2000      	movs	r0, #0
    USB_OTG_WRITE_REG8(CORE_USB_TRIG, 1 << ep ->num);
 10023d0:	4093      	lsls	r3, r2
 10023d2:	4a05      	ldr	r2, [pc, #20]	; (10023e8 <USB_OTG_TRIG+0x40>)
 10023d4:	b2db      	uxtb	r3, r3
 10023d6:	7013      	strb	r3, [r2, #0]
}
 10023d8:	bd10      	pop	{r4, pc}
 10023da:	46c0      	nop			; (mov r8, r8)
 10023dc:	000f6026 	.word	0x000f6026
 10023e0:	00002710 	.word	0x00002710
 10023e4:	000f6027 	.word	0x000f6027
 10023e8:	000f6010 	.word	0x000f6010

010023ec <USB_OTG_EPSetStall>:
    if (ep->num == 0)
 10023ec:	780b      	ldrb	r3, [r1, #0]
 10023ee:	2b00      	cmp	r3, #0
 10023f0:	d104      	bne.n	10023fc <USB_OTG_EPSetStall+0x10>
        USB_OTG_WRITE_REG8(&pdev->regs.xferctl ->STALL, 0x01);
 10023f2:	2201      	movs	r2, #1
 10023f4:	6903      	ldr	r3, [r0, #16]
 10023f6:	705a      	strb	r2, [r3, #1]
    USB_OTG_WRITE_REG8(&pdev->regs.xferctl ->TRIG, 0x10 << (ep ->num));
 10023f8:	320f      	adds	r2, #15
 10023fa:	701a      	strb	r2, [r3, #0]
}
 10023fc:	2000      	movs	r0, #0
 10023fe:	4770      	bx	lr

01002400 <USB_OTG_EPReply_Zerolen>:
    USB_OTG_WRITE_REG8(&pdev->regs.xferctl ->TRIG, 0x10 << (ep ->num));
 1002400:	2310      	movs	r3, #16
 1002402:	7809      	ldrb	r1, [r1, #0]
 1002404:	6902      	ldr	r2, [r0, #16]
 1002406:	408b      	lsls	r3, r1
 1002408:	b2db      	uxtb	r3, r3
    return status;
}
 100240a:	2000      	movs	r0, #0
    USB_OTG_WRITE_REG8(&pdev->regs.xferctl ->TRIG, 0x10 << (ep ->num));
 100240c:	7013      	strb	r3, [r2, #0]
}
 100240e:	4770      	bx	lr

01002410 <USB_OTG_ActiveRemoteWakeup>:
* @brief  USB_OTG_RemoteWakeup : active remote wakeup signalling
* @param  None
* @retval : None
*/
void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
{
 1002410:	b570      	push	{r4, r5, r6, lr}
    USB_OTG_CTL_TypeDef power;
    /* Note: If CLK has been stopped,it will need be restarted before
     * this write can occur.
     */
    power.d8 = USB_OTG_READ_REG8(CORE_USB_CONFIG);
 1002412:	25f6      	movs	r5, #246	; 0xf6
    power.b.resume = 1;
 1002414:	2640      	movs	r6, #64	; 0x40
    power.b.wakeup_enable = 1;
 1002416:	2380      	movs	r3, #128	; 0x80
    power.d8 = USB_OTG_READ_REG8(CORE_USB_CONFIG);
 1002418:	032d      	lsls	r5, r5, #12
 100241a:	782c      	ldrb	r4, [r5, #0]
    power.b.wakeup_enable = 1;
 100241c:	425b      	negs	r3, r3
    power.b.resume = 1;
 100241e:	4334      	orrs	r4, r6
    power.b.wakeup_enable = 1;
 1002420:	431c      	orrs	r4, r3
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, power.d8);
 1002422:	b2e3      	uxtb	r3, r4
 1002424:	702b      	strb	r3, [r5, #0]
    /* The software should leave then this bit set for approximately 10ms
     * (minimum of 2ms, a maximum of 15ms) before resetting it to 0.
     */
    delay_ms(2);
 1002426:	2002      	movs	r0, #2
 1002428:	f7fe fca2 	bl	1000d70 <delay_ms>
    delay_us(500);
 100242c:	20fa      	movs	r0, #250	; 0xfa
 100242e:	0040      	lsls	r0, r0, #1
 1002430:	f7fe fc98 	bl	1000d64 <delay_us>
    power.b.resume = 0;
    power.b.wakeup_enable = 0;
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, power.d8);
 1002434:	237f      	movs	r3, #127	; 0x7f
    power.b.resume = 0;
 1002436:	43b4      	bics	r4, r6
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, power.d8);
 1002438:	401c      	ands	r4, r3
 100243a:	702c      	strb	r4, [r5, #0]
}
 100243c:	bd70      	pop	{r4, r5, r6, pc}

0100243e <DCD_Init>:
#include "usb_bsp.h"
#include "yc_timer.h"

void DCD_Init(USB_OTG_CORE_HANDLE *pdev,
              USB_OTG_CORE_ID_TypeDef coreID)
{
 100243e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1002440:	0004      	movs	r4, r0
    uint32_t i;
    USB_OTG_EP *ep;
    /* Set Register Address */
    USB_OTG_SelectCore(pdev, coreID);
 1002442:	f7ff fe7b 	bl	100213c <USB_OTG_SelectCore>

    /* Force_FS */
    pdev->dev.device_status = USB_OTG_DEFAULT;
    pdev->dev.device_address = 0;
 1002446:	2200      	movs	r2, #0
    pdev->dev.device_status = USB_OTG_DEFAULT;
 1002448:	0023      	movs	r3, r4
 100244a:	2101      	movs	r1, #1
        /* Init ep structure */
        ep->is_in = 1;
        ep->num = i;
        ep->tx_fifo_num = i;
        /* Control until ep is actvated */
        ep->type = EP_TYPE_CTRL;
 100244c:	0015      	movs	r5, r2
        ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 100244e:	2740      	movs	r7, #64	; 0x40
    pdev->dev.device_status = USB_OTG_DEFAULT;
 1002450:	333a      	adds	r3, #58	; 0x3a
 1002452:	7019      	strb	r1, [r3, #0]
    pdev->dev.device_address = 0;
 1002454:	70da      	strb	r2, [r3, #3]
    for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 1002456:	7860      	ldrb	r0, [r4, #1]
 1002458:	330a      	adds	r3, #10
 100245a:	4290      	cmp	r0, r2
 100245c:	d80e      	bhi.n	100247c <DCD_Init+0x3e>
        ep->xfer_buff = 0;
        ep->xfer_len = 0;
    }

    for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 100245e:	2200      	movs	r2, #0
 1002460:	0023      	movs	r3, r4
    {
        ep = &pdev->dev.out_ep[i];
        /* Init ep structure */
        ep->is_in = 0;
 1002462:	0011      	movs	r1, r2
        ep->num = i;
        ep->tx_fifo_num = i;
        /* Control until ep is activated */
        ep->type = EP_TYPE_CTRL;
        ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 1002464:	2640      	movs	r6, #64	; 0x40
 1002466:	33d4      	adds	r3, #212	; 0xd4
    for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 1002468:	4290      	cmp	r0, r2
 100246a:	d812      	bhi.n	1002492 <DCD_Init+0x54>
        ep->xfer_buff = 0;
        ep->xfer_len = 0;
    }

    /* Init the Core (common init.) */
    USB_OTG_CoreInit(pdev);
 100246c:	0020      	movs	r0, r4
 100246e:	f7ff fea9 	bl	10021c4 <USB_OTG_CoreInit>

    /* Force Device Mode*/
    USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 1002472:	2100      	movs	r1, #0
 1002474:	0020      	movs	r0, r4
 1002476:	f7ff fea7 	bl	10021c8 <USB_OTG_SetCurrentMode>

}
 100247a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ep->num = i;
 100247c:	b2d6      	uxtb	r6, r2
        ep->is_in = 1;
 100247e:	7059      	strb	r1, [r3, #1]
        ep->num = i;
 1002480:	701e      	strb	r6, [r3, #0]
        ep->tx_fifo_num = i;
 1002482:	719e      	strb	r6, [r3, #6]
        ep->type = EP_TYPE_CTRL;
 1002484:	70dd      	strb	r5, [r3, #3]
        ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 1002486:	71df      	strb	r7, [r3, #7]
        ep->xfer_buff = 0;
 1002488:	609d      	str	r5, [r3, #8]
        ep->xfer_len = 0;
 100248a:	611d      	str	r5, [r3, #16]
    for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 100248c:	3201      	adds	r2, #1
 100248e:	3324      	adds	r3, #36	; 0x24
 1002490:	e7e3      	b.n	100245a <DCD_Init+0x1c>
        ep->num = i;
 1002492:	b2d5      	uxtb	r5, r2
        ep->is_in = 0;
 1002494:	7059      	strb	r1, [r3, #1]
        ep->num = i;
 1002496:	701d      	strb	r5, [r3, #0]
        ep->tx_fifo_num = i;
 1002498:	719d      	strb	r5, [r3, #6]
        ep->type = EP_TYPE_CTRL;
 100249a:	70d9      	strb	r1, [r3, #3]
        ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 100249c:	71de      	strb	r6, [r3, #7]
        ep->xfer_buff = 0;
 100249e:	6099      	str	r1, [r3, #8]
        ep->xfer_len = 0;
 10024a0:	6119      	str	r1, [r3, #16]
    for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 10024a2:	3201      	adds	r2, #1
 10024a4:	3324      	adds	r3, #36	; 0x24
 10024a6:	e7df      	b.n	1002468 <DCD_Init+0x2a>

010024a8 <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev,
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 10024a8:	b570      	push	{r4, r5, r6, lr}
 10024aa:	257f      	movs	r5, #127	; 0x7f
    USB_OTG_EP *ep;

    if ((ep_addr & 0x80) == 0x80)
 10024ac:	b24e      	sxtb	r6, r1
 10024ae:	400d      	ands	r5, r1
 10024b0:	2424      	movs	r4, #36	; 0x24
 10024b2:	2e00      	cmp	r6, #0
 10024b4:	da13      	bge.n	10024de <DCD_EP_Open+0x36>
    {
        ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 10024b6:	436c      	muls	r4, r5
 10024b8:	0021      	movs	r1, r4
 10024ba:	3144      	adds	r1, #68	; 0x44
    }
    else
    {
        ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 10024bc:	1841      	adds	r1, r0, r1
    }
    ep->num   = ep_addr & 0x7F;

    ep->is_in = (0x80 & ep_addr) != 0;
 10024be:	0ff4      	lsrs	r4, r6, #31
    ep->num   = ep_addr & 0x7F;
 10024c0:	700d      	strb	r5, [r1, #0]
    ep->is_in = (0x80 & ep_addr) != 0;
 10024c2:	704c      	strb	r4, [r1, #1]
    ep->maxpacket = ep_mps;
 10024c4:	71ca      	strb	r2, [r1, #7]
    ep->type = ep_type;
 10024c6:	70cb      	strb	r3, [r1, #3]
    if (ep->is_in)
 10024c8:	2e00      	cmp	r6, #0
 10024ca:	da00      	bge.n	10024ce <DCD_EP_Open+0x26>
    {
        /* Assign a Tx FIFO */
        ep->tx_fifo_num = ep->num;
 10024cc:	718d      	strb	r5, [r1, #6]
    }
    /* Set initial data PID. */
    if (ep_type == USB_OTG_EP_BULK)
 10024ce:	2b02      	cmp	r3, #2
 10024d0:	d101      	bne.n	10024d6 <DCD_EP_Open+0x2e>
    {
        ep->data_pid_start = 0;
 10024d2:	2300      	movs	r3, #0
 10024d4:	710b      	strb	r3, [r1, #4]
    }
    USB_OTG_EPActivate(pdev, ep);
 10024d6:	f7ff fe88 	bl	10021ea <USB_OTG_EPActivate>
    return 0;
}
 10024da:	2000      	movs	r0, #0
 10024dc:	bd70      	pop	{r4, r5, r6, pc}
        ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 10024de:	4361      	muls	r1, r4
 10024e0:	31d4      	adds	r1, #212	; 0xd4
 10024e2:	e7eb      	b.n	10024bc <DCD_EP_Open+0x14>

010024e4 <DCD_EP_Close>:
* @param pdev: device instance
* @param ep_addr: endpoint address
* @retval : status
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev, uint8_t  ep_addr)
{
 10024e4:	227f      	movs	r2, #127	; 0x7f
 10024e6:	b510      	push	{r4, lr}
    USB_OTG_EP *ep;

    if ((ep_addr & 0x80) == 0x80)
 10024e8:	b24c      	sxtb	r4, r1
 10024ea:	400a      	ands	r2, r1
 10024ec:	2324      	movs	r3, #36	; 0x24
 10024ee:	2c00      	cmp	r4, #0
 10024f0:	da0b      	bge.n	100250a <DCD_EP_Close+0x26>
    {
        ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 10024f2:	4353      	muls	r3, r2
 10024f4:	3344      	adds	r3, #68	; 0x44
    }
    else
    {
        ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 10024f6:	18c3      	adds	r3, r0, r3
    }
    ep->num   = ep_addr & 0x7F;
 10024f8:	701a      	strb	r2, [r3, #0]
    ep->is_in = (0x80 & ep_addr) ;
 10024fa:	227f      	movs	r2, #127	; 0x7f
 10024fc:	4391      	bics	r1, r2
 10024fe:	7059      	strb	r1, [r3, #1]
    USB_OTG_EPDeactivate(pdev, ep);
 1002500:	0019      	movs	r1, r3
 1002502:	f7ff fe7d 	bl	1002200 <USB_OTG_EPDeactivate>
    return 0;
}
 1002506:	2000      	movs	r0, #0
 1002508:	bd10      	pop	{r4, pc}
        ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 100250a:	434b      	muls	r3, r1
 100250c:	33d4      	adds	r3, #212	; 0xd4
 100250e:	e7f2      	b.n	10024f6 <DCD_EP_Close+0x12>

01002510 <DCD_EP_PrepareRx>:
extern volatile uint8_t epone_rx_datalen;
uint32_t   DCD_EP_PrepareRx(USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,
                            uint16_t  buf_len)
{
 1002510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1002512:	001d      	movs	r5, r3
 1002514:	267f      	movs	r6, #127	; 0x7f
    USB_OTG_EP *ep;

    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 1002516:	2324      	movs	r3, #36	; 0x24
 1002518:	400e      	ands	r6, r1
 100251a:	0019      	movs	r1, r3
 100251c:	4371      	muls	r1, r6
 100251e:	000f      	movs	r7, r1

    /*setup and start the Xfer */
    ep->xfer_buff = pbuf;
 1002520:	1841      	adds	r1, r0, r1
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 1002522:	37d4      	adds	r7, #212	; 0xd4
{
 1002524:	0004      	movs	r4, r0
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 1002526:	19c7      	adds	r7, r0, r7
    ep->xfer_buff = pbuf;
 1002528:	0008      	movs	r0, r1
 100252a:	30dc      	adds	r0, #220	; 0xdc
    ep->xfer_len = buf_len;
 100252c:	6085      	str	r5, [r0, #8]
    ep->xfer_count = 0;
 100252e:	000d      	movs	r5, r1
    ep->xfer_buff = pbuf;
 1002530:	6002      	str	r2, [r0, #0]
    ep->xfer_count = 0;
 1002532:	2000      	movs	r0, #0
 1002534:	35e8      	adds	r5, #232	; 0xe8
 1002536:	6028      	str	r0, [r5, #0]
    ep->is_in = 0;
 1002538:	3d13      	subs	r5, #19
 100253a:	7028      	strb	r0, [r5, #0]
    ep->num = ep_addr & 0x7F;
 100253c:	0008      	movs	r0, r1
 100253e:	30d4      	adds	r0, #212	; 0xd4
 1002540:	7006      	strb	r6, [r0, #0]

    if (pdev->cfg.dma_enable == 1)
 1002542:	78e0      	ldrb	r0, [r4, #3]
 1002544:	2801      	cmp	r0, #1
 1002546:	d101      	bne.n	100254c <DCD_EP_PrepareRx+0x3c>
    {
        ep->dma_addr = (uint32_t)pbuf;
 1002548:	31e0      	adds	r1, #224	; 0xe0
 100254a:	600a      	str	r2, [r1, #0]
    }


    if (ep->num == 0)
 100254c:	4373      	muls	r3, r6
 100254e:	18e3      	adds	r3, r4, r3
 1002550:	33d4      	adds	r3, #212	; 0xd4
 1002552:	781b      	ldrb	r3, [r3, #0]
 1002554:	2b00      	cmp	r3, #0
 1002556:	d105      	bne.n	1002564 <DCD_EP_PrepareRx+0x54>
    {
        USB_OTG_EP0StartXfer(pdev, ep);
 1002558:	0039      	movs	r1, r7
 100255a:	0020      	movs	r0, r4
 100255c:	f7ff fe5e 	bl	100221c <USB_OTG_EP0StartXfer>
            USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_OUT(ep->num));
            USB_OTG_EPStartXfer(pdev, ep);
        }
    }
    return 0;
}
 1002560:	2000      	movs	r0, #0
 1002562:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        next_flag = 0;
 1002564:	2300      	movs	r3, #0
 1002566:	4a17      	ldr	r2, [pc, #92]	; (10025c4 <DCD_EP_PrepareRx+0xb4>)
        USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_NAK);
 1002568:	4d17      	ldr	r5, [pc, #92]	; (10025c8 <DCD_EP_PrepareRx+0xb8>)
        next_flag = 0;
 100256a:	7013      	strb	r3, [r2, #0]
        USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_NAK);
 100256c:	2240      	movs	r2, #64	; 0x40
 100256e:	23fa      	movs	r3, #250	; 0xfa
 1002570:	702a      	strb	r2, [r5, #0]
 1002572:	009b      	lsls	r3, r3, #2
            if (USB_OTG_READ_REG8(CORE_USB_STATUS) & USB_STATUS_NAK)
 1002574:	7829      	ldrb	r1, [r5, #0]
 1002576:	4211      	tst	r1, r2
 1002578:	d020      	beq.n	10025bc <DCD_EP_PrepareRx+0xac>
                next_flag = 1;
 100257a:	2301      	movs	r3, #1
 100257c:	4911      	ldr	r1, [pc, #68]	; (10025c4 <DCD_EP_PrepareRx+0xb4>)
                USB_OTG_EPStartXfer(pdev, ep);
 100257e:	0020      	movs	r0, r4
                next_flag = 1;
 1002580:	700b      	strb	r3, [r1, #0]
                USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_OUT(ep->num));
 1002582:	3323      	adds	r3, #35	; 0x23
 1002584:	4373      	muls	r3, r6
 1002586:	18e3      	adds	r3, r4, r3
 1002588:	33d4      	adds	r3, #212	; 0xd4
 100258a:	7819      	ldrb	r1, [r3, #0]
 100258c:	2302      	movs	r3, #2
 100258e:	404b      	eors	r3, r1
 1002590:	702b      	strb	r3, [r5, #0]
                USB_OTG_EPStartXfer(pdev, ep);
 1002592:	0039      	movs	r1, r7
                USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_NAK);
 1002594:	702a      	strb	r2, [r5, #0]
                USB_OTG_EPStartXfer(pdev, ep);
 1002596:	f7ff fe93 	bl	10022c0 <USB_OTG_EPStartXfer>
        if (next_flag == 0)
 100259a:	4b0a      	ldr	r3, [pc, #40]	; (10025c4 <DCD_EP_PrepareRx+0xb4>)
 100259c:	781b      	ldrb	r3, [r3, #0]
 100259e:	2b00      	cmp	r3, #0
 10025a0:	d1de      	bne.n	1002560 <DCD_EP_PrepareRx+0x50>
            USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_OUT(ep->num));
 10025a2:	2124      	movs	r1, #36	; 0x24
 10025a4:	434e      	muls	r6, r1
 10025a6:	19a6      	adds	r6, r4, r6
 10025a8:	36d4      	adds	r6, #212	; 0xd4
 10025aa:	7832      	ldrb	r2, [r6, #0]
 10025ac:	3302      	adds	r3, #2
 10025ae:	4053      	eors	r3, r2
 10025b0:	702b      	strb	r3, [r5, #0]
            USB_OTG_EPStartXfer(pdev, ep);
 10025b2:	0039      	movs	r1, r7
 10025b4:	0020      	movs	r0, r4
 10025b6:	f7ff fe83 	bl	10022c0 <USB_OTG_EPStartXfer>
 10025ba:	e7d1      	b.n	1002560 <DCD_EP_PrepareRx+0x50>
 10025bc:	3b01      	subs	r3, #1
        for (int i = 0; i < 1000; i++)
 10025be:	2b00      	cmp	r3, #0
 10025c0:	d1d8      	bne.n	1002574 <DCD_EP_PrepareRx+0x64>
 10025c2:	e7ea      	b.n	100259a <DCD_EP_PrepareRx+0x8a>
 10025c4:	00020a4c 	.word	0x00020a4c
 10025c8:	000f6026 	.word	0x000f6026

010025cc <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx(USB_OTG_CORE_HANDLE *pdev,
                    uint8_t   ep_addr,
                    uint8_t   *pbuf,
                    uint32_t   buf_len)
{
 10025cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10025ce:	257f      	movs	r5, #127	; 0x7f
    USB_OTG_EP *ep;

    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 10025d0:	2424      	movs	r4, #36	; 0x24
 10025d2:	400d      	ands	r5, r1
 10025d4:	436c      	muls	r4, r5
 10025d6:	0021      	movs	r1, r4

    /* Setup and start the Transfer */
    ep->is_in = 1;
 10025d8:	1904      	adds	r4, r0, r4
 10025da:	0026      	movs	r6, r4
 10025dc:	2701      	movs	r7, #1
 10025de:	3645      	adds	r6, #69	; 0x45
 10025e0:	7037      	strb	r7, [r6, #0]
    ep->num = ep_addr & 0x7F;
 10025e2:	3e01      	subs	r6, #1
 10025e4:	7035      	strb	r5, [r6, #0]
    ep->xfer_buff = pbuf;
 10025e6:	64e2      	str	r2, [r4, #76]	; 0x4c
    ep->xfer_count = 0;
 10025e8:	2200      	movs	r2, #0
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 10025ea:	3144      	adds	r1, #68	; 0x44
 10025ec:	1841      	adds	r1, r0, r1
    ep->xfer_count = 0;
 10025ee:	65a2      	str	r2, [r4, #88]	; 0x58
    ep->xfer_len  = buf_len;
 10025f0:	6563      	str	r3, [r4, #84]	; 0x54

    if (ep->num == 0)
 10025f2:	4295      	cmp	r5, r2
 10025f4:	d103      	bne.n	10025fe <DCD_EP_Tx+0x32>
    {
        USB_OTG_EP0StartXfer(pdev, ep);
 10025f6:	f7ff fe11 	bl	100221c <USB_OTG_EP0StartXfer>
    else
    {
        USB_OTG_EPStartXfer(pdev, ep);
    }
    return 0;
}
 10025fa:	2000      	movs	r0, #0
 10025fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        USB_OTG_EPStartXfer(pdev, ep);
 10025fe:	f7ff fe5f 	bl	10022c0 <USB_OTG_EPStartXfer>
 1002602:	e7fa      	b.n	10025fa <DCD_EP_Tx+0x2e>

01002604 <DCD_EP_Stall>:
* @param epnum: endpoint address
* @retval : status
*/

uint32_t  DCD_EP_Stall(USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
 1002604:	b510      	push	{r4, lr}
 1002606:	247f      	movs	r4, #127	; 0x7f
    USB_OTG_EP *ep;
    if ((0x80 & epnum) == 0x80)
 1002608:	b24a      	sxtb	r2, r1
 100260a:	400c      	ands	r4, r1
 100260c:	2324      	movs	r3, #36	; 0x24
 100260e:	2a00      	cmp	r2, #0
 1002610:	da0c      	bge.n	100262c <DCD_EP_Stall+0x28>
    {
        ep = &pdev->dev.in_ep[epnum & 0x7F];
 1002612:	4363      	muls	r3, r4
 1002614:	3344      	adds	r3, #68	; 0x44
 1002616:	0019      	movs	r1, r3
    else
    {
        ep = &pdev->dev.out_ep[epnum];
    }

    ep->is_stall = 1;
 1002618:	2301      	movs	r3, #1
        ep = &pdev->dev.out_ep[epnum];
 100261a:	1841      	adds	r1, r0, r1
    ep->num   = epnum & 0x7F;
    ep->is_in = ((epnum & 0x80) == 0x80);
 100261c:	0fd2      	lsrs	r2, r2, #31
    ep->is_stall = 1;
 100261e:	708b      	strb	r3, [r1, #2]
    ep->num   = epnum & 0x7F;
 1002620:	700c      	strb	r4, [r1, #0]
    ep->is_in = ((epnum & 0x80) == 0x80);
 1002622:	704a      	strb	r2, [r1, #1]

    USB_OTG_EPSetStall(pdev, ep);
 1002624:	f7ff fee2 	bl	10023ec <USB_OTG_EPSetStall>
    return (0);
}
 1002628:	2000      	movs	r0, #0
 100262a:	bd10      	pop	{r4, pc}
        ep = &pdev->dev.out_ep[epnum];
 100262c:	4359      	muls	r1, r3
 100262e:	31d4      	adds	r1, #212	; 0xd4
 1002630:	e7f2      	b.n	1002618 <DCD_EP_Stall+0x14>

01002632 <_delay_>:
static uint32_t DCD_HandleInEP_ISR(USB_OTG_CORE_HANDLE *pdev, uint16_t ep_intr);
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev, uint16_t ep_intr);


void _delay_(uint32_t t)
{
 1002632:	b510      	push	{r4, lr}
    ((void(*)())(0xc6 + 1))(t);
 1002634:	23c7      	movs	r3, #199	; 0xc7
 1002636:	4798      	blx	r3
}
 1002638:	bd10      	pop	{r4, pc}
	...

0100263c <USBD_OTG_ISR_Handler>:
uint8_t setup_cnt = 0;
uint8_t SetAddress_Flag = 0;
uint8_t Address_Value = 0;
extern volatile uint8_t usb_configration_flag;
uint32_t USBD_OTG_ISR_Handler(USB_OTG_CORE_HANDLE *pdev)
{
 100263c:	b5f0      	push	{r4, r5, r6, r7, lr}
    USB_OTG_IRQ2_TypeDef fifo_empty_irq;

    uint32_t retval = 0;
    USB_OTG_EP *ep;

    gintr_status.d8 = USB_OTG_READ_REG8(&(pdev ->regs.STATUSEGS ->STATUS));
 100263e:	6b43      	ldr	r3, [r0, #52]	; 0x34
{
 1002640:	b087      	sub	sp, #28
    gintr_status.d8 = USB_OTG_READ_REG8(&(pdev ->regs.STATUSEGS ->STATUS));
 1002642:	785d      	ldrb	r5, [r3, #1]
    fifo_empty_irq.d8 = USB_OTG_READ_REG8(&pdev ->regs.STATUSEGS ->EMPTY);
 1002644:	789b      	ldrb	r3, [r3, #2]
    gintr_status.d8 = USB_OTG_READ_REG8(&(pdev ->regs.STATUSEGS ->STATUS));
 1002646:	b2ed      	uxtb	r5, r5
    fifo_empty_irq.d8 = USB_OTG_READ_REG8(&pdev ->regs.STATUSEGS ->EMPTY);
 1002648:	b2db      	uxtb	r3, r3
{
 100264a:	0006      	movs	r6, r0
    fifo_empty_irq.d8 = USB_OTG_READ_REG8(&pdev ->regs.STATUSEGS ->EMPTY);
 100264c:	9302      	str	r3, [sp, #8]

    if ((!gintr_status.d8) && (!fifo_empty_irq.d8))
 100264e:	2d00      	cmp	r5, #0
 1002650:	d106      	bne.n	1002660 <USBD_OTG_ISR_Handler+0x24>
        return 0;
 1002652:	9501      	str	r5, [sp, #4]
    if ((!gintr_status.d8) && (!fifo_empty_irq.d8))
 1002654:	2b00      	cmp	r3, #0
 1002656:	d000      	beq.n	100265a <USBD_OTG_ISR_Handler+0x1e>
 1002658:	e072      	b.n	1002740 <USBD_OTG_ISR_Handler+0x104>
    {
        USB_OTG_WRITE_REG8(&pdev->regs.STATUSEGS ->EMPTY, fifo_empty_irq.d8 & 0xFF);
        retval |= DCD_HandleInEP_ISR(pdev, fifo_empty_irq.d8 & 0x0F);
    }
    return retval;
}
 100265a:	9801      	ldr	r0, [sp, #4]
 100265c:	b007      	add	sp, #28
 100265e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (gintr_status.b.reset)
 1002660:	b26b      	sxtb	r3, r5
 1002662:	2b00      	cmp	r3, #0
 1002664:	da6c      	bge.n	1002740 <USBD_OTG_ISR_Handler+0x104>
        retval |= USBD_DCD_INT_fops->Reset(pdev);
 1002666:	4b60      	ldr	r3, [pc, #384]	; (10027e8 <USBD_OTG_ISR_Handler+0x1ac>)
 1002668:	681b      	ldr	r3, [r3, #0]
 100266a:	691b      	ldr	r3, [r3, #16]
 100266c:	4798      	blx	r3
 100266e:	9001      	str	r0, [sp, #4]
    if (gintr_status.b.suspend)
 1002670:	06ab      	lsls	r3, r5, #26
 1002672:	d507      	bpl.n	1002684 <USBD_OTG_ISR_Handler+0x48>
        retval |= USBD_DCD_INT_fops->Suspend(pdev);
 1002674:	4b5c      	ldr	r3, [pc, #368]	; (10027e8 <USBD_OTG_ISR_Handler+0x1ac>)
 1002676:	0030      	movs	r0, r6
 1002678:	681b      	ldr	r3, [r3, #0]
 100267a:	695b      	ldr	r3, [r3, #20]
 100267c:	4798      	blx	r3
 100267e:	9b01      	ldr	r3, [sp, #4]
 1002680:	4303      	orrs	r3, r0
 1002682:	9301      	str	r3, [sp, #4]
    USB_OTG_WRITE_REG8(&pdev->regs.STATUSEGS ->STATUS, 0xE0);
 1002684:	22e0      	movs	r2, #224	; 0xe0
 1002686:	240e      	movs	r4, #14
 1002688:	6b73      	ldr	r3, [r6, #52]	; 0x34
 100268a:	402c      	ands	r4, r5
 100268c:	705a      	strb	r2, [r3, #1]
    if (gintr_status.d8 & 0x0E)
 100268e:	d008      	beq.n	10026a2 <USBD_OTG_ISR_Handler+0x66>
* @retval status
*/
static uint32_t DCD_HandleOutEP_ISR(USB_OTG_CORE_HANDLE *pdev, uint16_t ep_intr)
{

    uint32_t epnum = 1;
 1002690:	2701      	movs	r7, #1
        USB_OTG_WRITE_REG8(&pdev->regs.STATUSEGS ->STATUS, gintr_status.d8 & 0x0E);
 1002692:	705c      	strb	r4, [r3, #1]
    uint8_t rx_count;
    ep_intr >>= 1;
 1002694:	0864      	lsrs	r4, r4, #1
    while (ep_intr)
 1002696:	2c00      	cmp	r4, #0
 1002698:	d155      	bne.n	1002746 <USBD_OTG_ISR_Handler+0x10a>
        retval |= DCD_HandleOutEP_ISR(pdev, gintr_status.d8 & 0x0E);
 100269a:	2201      	movs	r2, #1
 100269c:	9b01      	ldr	r3, [sp, #4]
 100269e:	4313      	orrs	r3, r2
 10026a0:	9301      	str	r3, [sp, #4]
    if (gintr_status.b.outep0_irq)
 10026a2:	07eb      	lsls	r3, r5, #31
 10026a4:	d514      	bpl.n	10026d0 <USBD_OTG_ISR_Handler+0x94>
        USB_OTG_WRITE_REG8(&pdev->regs.STATUSEGS ->STATUS, 0x11);
 10026a6:	2311      	movs	r3, #17
 10026a8:	6b72      	ldr	r2, [r6, #52]	; 0x34
 10026aa:	7053      	strb	r3, [r2, #1]
        if (SetAddress_Flag)
 10026ac:	4a4f      	ldr	r2, [pc, #316]	; (10027ec <USBD_OTG_ISR_Handler+0x1b0>)
 10026ae:	7813      	ldrb	r3, [r2, #0]
 10026b0:	2b00      	cmp	r3, #0
 10026b2:	d006      	beq.n	10026c2 <USBD_OTG_ISR_Handler+0x86>
            USB_OTG_MODIFY_REG8(&pdev->regs.CTRLREGS->FADDR, 0, 0x80);  /* set 1,address  0 data can not into fifo*/
 10026b4:	2080      	movs	r0, #128	; 0x80
 10026b6:	68f1      	ldr	r1, [r6, #12]
 10026b8:	790b      	ldrb	r3, [r1, #4]
 10026ba:	4303      	orrs	r3, r0
 10026bc:	710b      	strb	r3, [r1, #4]
            SetAddress_Flag = 0;
 10026be:	2300      	movs	r3, #0
 10026c0:	7013      	strb	r3, [r2, #0]
        if (gintr_status.b.setup)
 10026c2:	06eb      	lsls	r3, r5, #27
 10026c4:	d504      	bpl.n	10026d0 <USBD_OTG_ISR_Handler+0x94>
            USBD_DCD_INT_fops->SetupStage(pdev);
 10026c6:	4b48      	ldr	r3, [pc, #288]	; (10027e8 <USBD_OTG_ISR_Handler+0x1ac>)
 10026c8:	0030      	movs	r0, r6
 10026ca:	681b      	ldr	r3, [r3, #0]
 10026cc:	689b      	ldr	r3, [r3, #8]
 10026ce:	4798      	blx	r3
 10026d0:	230f      	movs	r3, #15
 10026d2:	9a02      	ldr	r2, [sp, #8]
 10026d4:	4013      	ands	r3, r2
    if (fifo_empty_irq.d8 & 0x0F)
 10026d6:	d0c0      	beq.n	100265a <USBD_OTG_ISR_Handler+0x1e>
        retval |= DCD_HandleInEP_ISR(pdev, fifo_empty_irq.d8 & 0x0F);
 10026d8:	b29b      	uxth	r3, r3
 10026da:	9304      	str	r3, [sp, #16]
    uint16_t epnum = 0;
 10026dc:	2300      	movs	r3, #0
        USB_OTG_WRITE_REG8(&pdev->regs.STATUSEGS ->EMPTY, fifo_empty_irq.d8 & 0xFF);
 10026de:	6b72      	ldr	r2, [r6, #52]	; 0x34
 10026e0:	9902      	ldr	r1, [sp, #8]
    uint16_t epnum = 0;
 10026e2:	9303      	str	r3, [sp, #12]
        USB_OTG_WRITE_REG8(&pdev->regs.STATUSEGS ->EMPTY, fifo_empty_irq.d8 & 0xFF);
 10026e4:	7091      	strb	r1, [r2, #2]
        ep->is_in = 1;
 10026e6:	2724      	movs	r7, #36	; 0x24
 10026e8:	9b03      	ldr	r3, [sp, #12]
 10026ea:	2201      	movs	r2, #1
 10026ec:	435f      	muls	r7, r3
 10026ee:	19f4      	adds	r4, r6, r7
 10026f0:	0023      	movs	r3, r4
 10026f2:	3345      	adds	r3, #69	; 0x45
 10026f4:	701a      	strb	r2, [r3, #0]
        ep->num = epnum;
 10026f6:	466b      	mov	r3, sp
 10026f8:	7b1b      	ldrb	r3, [r3, #12]
 10026fa:	9302      	str	r3, [sp, #8]
 10026fc:	0023      	movs	r3, r4
 10026fe:	9902      	ldr	r1, [sp, #8]
 1002700:	3344      	adds	r3, #68	; 0x44
 1002702:	7019      	strb	r1, [r3, #0]
        if (ep_intr & 0x01) /* In ITR */
 1002704:	9b04      	ldr	r3, [sp, #16]
 1002706:	4213      	tst	r3, r2
 1002708:	d04c      	beq.n	10027a4 <USBD_OTG_ISR_Handler+0x168>
 100270a:	0023      	movs	r3, r4
            if (pdev->dev.in_ep[epnum].rem_data_len == 0)
 100270c:	6de5      	ldr	r5, [r4, #92]	; 0x5c
        ep = &pdev->dev.in_ep[epnum];
 100270e:	3744      	adds	r7, #68	; 0x44
 1002710:	3354      	adds	r3, #84	; 0x54
 1002712:	19f7      	adds	r7, r6, r7
 1002714:	9305      	str	r3, [sp, #20]
 1002716:	6d60      	ldr	r0, [r4, #84]	; 0x54
            if (pdev->dev.in_ep[epnum].rem_data_len == 0)
 1002718:	2d00      	cmp	r5, #0
 100271a:	d127      	bne.n	100276c <USBD_OTG_ISR_Handler+0x130>
                if (pdev->dev.in_ep[epnum].xfer_len != 0 && pdev->dev.in_ep[epnum].xfer_len % pdev->dev.in_ep[epnum].maxpacket == 0)
 100271c:	2800      	cmp	r0, #0
 100271e:	d00b      	beq.n	1002738 <USBD_OTG_ISR_Handler+0xfc>
 1002720:	344b      	adds	r4, #75	; 0x4b
 1002722:	7821      	ldrb	r1, [r4, #0]
 1002724:	f001 fc88 	bl	1004038 <__aeabi_uidivmod>
 1002728:	2900      	cmp	r1, #0
 100272a:	d105      	bne.n	1002738 <USBD_OTG_ISR_Handler+0xfc>
                    USB_OTG_EPReply_Zerolen(pdev, ep);
 100272c:	0039      	movs	r1, r7
 100272e:	0030      	movs	r0, r6
 1002730:	f7ff fe66 	bl	1002400 <USB_OTG_EPReply_Zerolen>
                    pdev->dev.in_ep[epnum].xfer_len = 0;
 1002734:	9b05      	ldr	r3, [sp, #20]
 1002736:	601d      	str	r5, [r3, #0]
        retval |= DCD_HandleInEP_ISR(pdev, fifo_empty_irq.d8 & 0x0F);
 1002738:	9b01      	ldr	r3, [sp, #4]
 100273a:	432b      	orrs	r3, r5
 100273c:	9301      	str	r3, [sp, #4]
 100273e:	e78c      	b.n	100265a <USBD_OTG_ISR_Handler+0x1e>
    uint32_t retval = 0;
 1002740:	2300      	movs	r3, #0
 1002742:	9301      	str	r3, [sp, #4]
 1002744:	e794      	b.n	1002670 <USBD_OTG_ISR_Handler+0x34>
    {
        if (ep_intr & 0x1)
 1002746:	2301      	movs	r3, #1
 1002748:	421c      	tst	r4, r3
 100274a:	d00c      	beq.n	1002766 <USBD_OTG_ISR_Handler+0x12a>
 100274c:	0033      	movs	r3, r6
 100274e:	00ba      	lsls	r2, r7, #2
 1002750:	3324      	adds	r3, #36	; 0x24
 1002752:	189b      	adds	r3, r3, r2
        {
            rx_count = USB_OTG_READ_REG8(&pdev ->regs.LENREGS[epnum]);
 1002754:	781b      	ldrb	r3, [r3, #0]
            if (rx_count)
 1002756:	2b00      	cmp	r3, #0
 1002758:	d005      	beq.n	1002766 <USBD_OTG_ISR_Handler+0x12a>
            {
                USBD_DCD_INT_fops->DataOutStage(pdev, epnum);
 100275a:	4b23      	ldr	r3, [pc, #140]	; (10027e8 <USBD_OTG_ISR_Handler+0x1ac>)
 100275c:	b2f9      	uxtb	r1, r7
 100275e:	681b      	ldr	r3, [r3, #0]
 1002760:	0030      	movs	r0, r6
 1002762:	681b      	ldr	r3, [r3, #0]
 1002764:	4798      	blx	r3
            }
        }
        /* Endpoint disable  */
        epnum++;
 1002766:	3701      	adds	r7, #1
        ep_intr >>= 1;
 1002768:	0864      	lsrs	r4, r4, #1
 100276a:	e794      	b.n	1002696 <USBD_OTG_ISR_Handler+0x5a>
                if (pdev->dev.in_ep[epnum].xfer_len - pdev->dev.in_ep[epnum].xfer_count >= pdev->dev.in_ep[epnum].maxpacket)
 100276c:	0025      	movs	r5, r4
 100276e:	354b      	adds	r5, #75	; 0x4b
 1002770:	6da2      	ldr	r2, [r4, #88]	; 0x58
 1002772:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 1002774:	782b      	ldrb	r3, [r5, #0]
 1002776:	1889      	adds	r1, r1, r2
 1002778:	1a80      	subs	r0, r0, r2
 100277a:	4298      	cmp	r0, r3
 100277c:	d31c      	bcc.n	10027b8 <USBD_OTG_ISR_Handler+0x17c>
                    USB_OTG_WritePacket(pdev,
 100277e:	9a02      	ldr	r2, [sp, #8]
 1002780:	0030      	movs	r0, r6
 1002782:	f7ff fcbd 	bl	1002100 <USB_OTG_WritePacket>
                    USB_OTG_TRIG(pdev, ep);
 1002786:	0039      	movs	r1, r7
 1002788:	0030      	movs	r0, r6
 100278a:	f7ff fe0d 	bl	10023a8 <USB_OTG_TRIG>
                    pdev->dev.in_ep[epnum].xfer_count += pdev->dev.in_ep[epnum].maxpacket;
 100278e:	782b      	ldrb	r3, [r5, #0]
 1002790:	6da2      	ldr	r2, [r4, #88]	; 0x58
 1002792:	189b      	adds	r3, r3, r2
                    pdev->dev.in_ep[epnum].rem_data_len = pdev->dev.in_ep[epnum].xfer_len - pdev->dev.in_ep[epnum].xfer_count;
 1002794:	6d62      	ldr	r2, [r4, #84]	; 0x54
                    pdev->dev.in_ep[epnum].xfer_count += pdev->dev.in_ep[epnum].maxpacket;
 1002796:	65a3      	str	r3, [r4, #88]	; 0x58
                    pdev->dev.in_ep[epnum].rem_data_len = pdev->dev.in_ep[epnum].xfer_len - pdev->dev.in_ep[epnum].xfer_count;
 1002798:	1ad3      	subs	r3, r2, r3
 100279a:	65e3      	str	r3, [r4, #92]	; 0x5c
                    pdev->dev.zero_replay_flag = 1;
 100279c:	23be      	movs	r3, #190	; 0xbe
 100279e:	2201      	movs	r2, #1
 10027a0:	005b      	lsls	r3, r3, #1
 10027a2:	54f2      	strb	r2, [r6, r3]
        epnum++;
 10027a4:	9b03      	ldr	r3, [sp, #12]
 10027a6:	3301      	adds	r3, #1
 10027a8:	b29b      	uxth	r3, r3
 10027aa:	9303      	str	r3, [sp, #12]
        ep_intr >>= 1;
 10027ac:	9b04      	ldr	r3, [sp, #16]
 10027ae:	085b      	lsrs	r3, r3, #1
 10027b0:	9304      	str	r3, [sp, #16]
    while (ep_intr)
 10027b2:	d198      	bne.n	10026e6 <USBD_OTG_ISR_Handler+0xaa>
    return 1;
 10027b4:	2501      	movs	r5, #1
 10027b6:	e7bf      	b.n	1002738 <USBD_OTG_ISR_Handler+0xfc>
                    pdev->dev.in_ep[epnum].rem_data_len = 0;
 10027b8:	2500      	movs	r5, #0
                    USB_OTG_WritePacket(pdev,
 10027ba:	b2c3      	uxtb	r3, r0
 10027bc:	9a02      	ldr	r2, [sp, #8]
 10027be:	0030      	movs	r0, r6
 10027c0:	f7ff fc9e 	bl	1002100 <USB_OTG_WritePacket>
                    USB_OTG_TRIG(pdev, ep);
 10027c4:	0039      	movs	r1, r7
 10027c6:	0030      	movs	r0, r6
 10027c8:	f7ff fdee 	bl	10023a8 <USB_OTG_TRIG>
                    pdev->dev.in_ep[epnum].xfer_count = pdev->dev.in_ep[epnum].xfer_len;
 10027cc:	6d63      	ldr	r3, [r4, #84]	; 0x54
                    pdev->dev.in_ep[epnum].rem_data_len = 0;
 10027ce:	65e5      	str	r5, [r4, #92]	; 0x5c
                    pdev->dev.in_ep[epnum].xfer_count = pdev->dev.in_ep[epnum].xfer_len;
 10027d0:	65a3      	str	r3, [r4, #88]	; 0x58
                    USBD_DCD_INT_fops->DataInStage(pdev, epnum);
 10027d2:	4b05      	ldr	r3, [pc, #20]	; (10027e8 <USBD_OTG_ISR_Handler+0x1ac>)
 10027d4:	9902      	ldr	r1, [sp, #8]
 10027d6:	681b      	ldr	r3, [r3, #0]
 10027d8:	0030      	movs	r0, r6
 10027da:	685b      	ldr	r3, [r3, #4]
 10027dc:	4798      	blx	r3
                    pdev->dev.zero_replay_flag = 0;
 10027de:	23be      	movs	r3, #190	; 0xbe
 10027e0:	005b      	lsls	r3, r3, #1
 10027e2:	54f5      	strb	r5, [r6, r3]
 10027e4:	e7de      	b.n	10027a4 <USBD_OTG_ISR_Handler+0x168>
 10027e6:	46c0      	nop			; (mov r8, r8)
 10027e8:	00020034 	.word	0x00020034
 10027ec:	00020a4e 	.word	0x00020a4e

010027f0 <USBD_SetupStage>:
* @param  pdev: device instance
* @retval status
*/
uint8_t out0_data_len = 0;
static uint8_t USBD_SetupStage(USB_OTG_CORE_HANDLE *pdev)
{
 10027f0:	b530      	push	{r4, r5, lr}
    uint8_t rx_DataLength = 0;

    rx_DataLength = USB_OTG_READ_REG8(pdev->regs.LENREGS[0]);
 10027f2:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 10027f4:	b091      	sub	sp, #68	; 0x44
    rx_DataLength = USB_OTG_READ_REG8(pdev->regs.LENREGS[0]);
 10027f6:	781d      	ldrb	r5, [r3, #0]
{
 10027f8:	0004      	movs	r4, r0
    rx_DataLength = USB_OTG_READ_REG8(pdev->regs.LENREGS[0]);
 10027fa:	b2ed      	uxtb	r5, r5

    /* receive setup packet*/

    if (rx_DataLength == USB_SETUP_PACKET_LEN)
 10027fc:	2d08      	cmp	r5, #8
 10027fe:	d11b      	bne.n	1002838 <USBD_SetupStage+0x48>
    {
        USB_OTG_ReadPacket(pdev, pdev->dev.setup_packet, 0, USB_SETUP_PACKET_LEN);
 1002800:	0001      	movs	r1, r0
 1002802:	002b      	movs	r3, r5
 1002804:	2200      	movs	r2, #0
 1002806:	3165      	adds	r1, #101	; 0x65
 1002808:	31ff      	adds	r1, #255	; 0xff
        {
            if (USB_OTG_READ_REG8(CORE_USB_STATUS) & USB_STATUS_NAK)
            {
                uint8_t rx_reminebuffer[64] = {0};
                USB_OTG_ReadPacket(pdev, pdev->dev.setup_packet, 0, USB_SETUP_PACKET_LEN);
                USB_OTG_ReadPacket(pdev, rx_reminebuffer, 0, rx_DataLength - USB_SETUP_PACKET_LEN);
 100280a:	0020      	movs	r0, r4
 100280c:	f7ff fc8a 	bl	1002124 <USB_OTG_ReadPacket>

    }

    /* deal with receive setup packet */
    USB_SETUP_REQ req;
    USBD_ParseSetupRequest(pdev, &req);
 1002810:	4669      	mov	r1, sp
 1002812:	0020      	movs	r0, r4
 1002814:	f000 faee 	bl	1002df4 <USBD_ParseSetupRequest>

    switch (req.bmRequest & 0x1F)
 1002818:	466b      	mov	r3, sp
 100281a:	7819      	ldrb	r1, [r3, #0]
 100281c:	231f      	movs	r3, #31
 100281e:	400b      	ands	r3, r1
 1002820:	2b01      	cmp	r3, #1
 1002822:	d02f      	beq.n	1002884 <USBD_SetupStage+0x94>
 1002824:	2b00      	cmp	r3, #0
 1002826:	d026      	beq.n	1002876 <USBD_SetupStage+0x86>
 1002828:	2b02      	cmp	r3, #2
 100282a:	d030      	beq.n	100288e <USBD_SetupStage+0x9e>
    case USB_REQ_RECIPIENT_ENDPOINT:
        USBD_StdEPReq(pdev, &req);
        break;

    default:
        DCD_EP_Stall(pdev, req.bmRequest & 0x80);
 100282c:	237f      	movs	r3, #127	; 0x7f
 100282e:	0020      	movs	r0, r4
 1002830:	4399      	bics	r1, r3
 1002832:	f7ff fee7 	bl	1002604 <DCD_EP_Stall>
        break;
 1002836:	e022      	b.n	100287e <USBD_SetupStage+0x8e>
        USB_OTG_WRITE_REG8(CORE_USB_STATUS, USB_STATUS_NAK);
 1002838:	2340      	movs	r3, #64	; 0x40
 100283a:	21fa      	movs	r1, #250	; 0xfa
 100283c:	4a16      	ldr	r2, [pc, #88]	; (1002898 <USBD_SetupStage+0xa8>)
 100283e:	0089      	lsls	r1, r1, #2
 1002840:	7013      	strb	r3, [r2, #0]
            if (USB_OTG_READ_REG8(CORE_USB_STATUS) & USB_STATUS_NAK)
 1002842:	7810      	ldrb	r0, [r2, #0]
 1002844:	4218      	tst	r0, r3
 1002846:	d012      	beq.n	100286e <USBD_SetupStage+0x7e>
                uint8_t rx_reminebuffer[64] = {0};
 1002848:	2240      	movs	r2, #64	; 0x40
 100284a:	2100      	movs	r1, #0
 100284c:	4668      	mov	r0, sp
 100284e:	f001 fb0b 	bl	1003e68 <memset>
                USB_OTG_ReadPacket(pdev, pdev->dev.setup_packet, 0, USB_SETUP_PACKET_LEN);
 1002852:	0021      	movs	r1, r4
 1002854:	3165      	adds	r1, #101	; 0x65
 1002856:	2308      	movs	r3, #8
 1002858:	2200      	movs	r2, #0
 100285a:	31ff      	adds	r1, #255	; 0xff
 100285c:	0020      	movs	r0, r4
 100285e:	f7ff fc61 	bl	1002124 <USB_OTG_ReadPacket>
                USB_OTG_ReadPacket(pdev, rx_reminebuffer, 0, rx_DataLength - USB_SETUP_PACKET_LEN);
 1002862:	002b      	movs	r3, r5
 1002864:	3b08      	subs	r3, #8
 1002866:	b2db      	uxtb	r3, r3
 1002868:	2200      	movs	r2, #0
 100286a:	4669      	mov	r1, sp
 100286c:	e7cd      	b.n	100280a <USBD_SetupStage+0x1a>
 100286e:	3901      	subs	r1, #1
        for (int i = 0; i < 1000; i++)
 1002870:	2900      	cmp	r1, #0
 1002872:	d1e6      	bne.n	1002842 <USBD_SetupStage+0x52>
 1002874:	e7cc      	b.n	1002810 <USBD_SetupStage+0x20>
        USBD_StdDevReq(pdev, &req);
 1002876:	4669      	mov	r1, sp
 1002878:	0020      	movs	r0, r4
 100287a:	f000 f931 	bl	1002ae0 <USBD_StdDevReq>
    }
    return USBD_OK;
}
 100287e:	2000      	movs	r0, #0
 1002880:	b011      	add	sp, #68	; 0x44
 1002882:	bd30      	pop	{r4, r5, pc}
        USBD_StdItfReq(pdev, &req);
 1002884:	4669      	mov	r1, sp
 1002886:	0020      	movs	r0, r4
 1002888:	f000 fa38 	bl	1002cfc <USBD_StdItfReq>
        break;
 100288c:	e7f7      	b.n	100287e <USBD_SetupStage+0x8e>
        USBD_StdEPReq(pdev, &req);
 100288e:	4669      	mov	r1, sp
 1002890:	0020      	movs	r0, r4
 1002892:	f000 fa51 	bl	1002d38 <USBD_StdEPReq>
        break;
 1002896:	e7f2      	b.n	100287e <USBD_SetupStage+0x8e>
 1002898:	000f6026 	.word	0x000f6026

0100289c <USBD_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataOutStage(USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 100289c:	b510      	push	{r4, lr}
    USB_OTG_EP *ep;

    if (epnum == 0)
    {
        ep = &pdev->dev.out_ep[0];
        if (pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 100289e:	0003      	movs	r3, r0
{
 10028a0:	0004      	movs	r4, r0
    if (epnum == 0)
 10028a2:	2900      	cmp	r1, #0
 10028a4:	d12b      	bne.n	10028fe <USBD_DataOutStage+0x62>
        if (pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 10028a6:	3339      	adds	r3, #57	; 0x39
 10028a8:	781b      	ldrb	r3, [r3, #0]
 10028aa:	2b03      	cmp	r3, #3
 10028ac:	d115      	bne.n	10028da <USBD_DataOutStage+0x3e>
        {
            if (ep->rem_data_len > ep->maxpacket)
 10028ae:	0003      	movs	r3, r0
 10028b0:	33d4      	adds	r3, #212	; 0xd4
 10028b2:	6999      	ldr	r1, [r3, #24]
 10028b4:	79da      	ldrb	r2, [r3, #7]
 10028b6:	4291      	cmp	r1, r2
 10028b8:	d911      	bls.n	10028de <USBD_DataOutStage+0x42>
            {
                ep->rem_data_len -=  ep->maxpacket;
 10028ba:	1a89      	subs	r1, r1, r2
 10028bc:	6199      	str	r1, [r3, #24]

                if (pdev->cfg.dma_enable == 1)
 10028be:	78c0      	ldrb	r0, [r0, #3]
 10028c0:	2801      	cmp	r0, #1
 10028c2:	d102      	bne.n	10028ca <USBD_DataOutStage+0x2e>
                {
                    /* in slave mode this, is handled by the RxSTSQLvl ISR */
                    ep->xfer_buff += ep->maxpacket;
 10028c4:	6898      	ldr	r0, [r3, #8]
 10028c6:	1880      	adds	r0, r0, r2
 10028c8:	6098      	str	r0, [r3, #8]
                }
                USBD_CtlContinueRx(pdev,
                                   ep->xfer_buff,
                                   MIN(ep->rem_data_len, ep->maxpacket));
 10028ca:	428a      	cmp	r2, r1
 10028cc:	d900      	bls.n	10028d0 <USBD_DataOutStage+0x34>
 10028ce:	000a      	movs	r2, r1
                USBD_CtlContinueRx(pdev,
 10028d0:	b292      	uxth	r2, r2
 10028d2:	6899      	ldr	r1, [r3, #8]
 10028d4:	0020      	movs	r0, r4
 10028d6:	f000 f8dd 	bl	1002a94 <USBD_CtlContinueRx>
    {

        pdev->dev.class_cb->DataOut(pdev, epnum);
    }
    return USBD_OK;
}
 10028da:	2000      	movs	r0, #0
 10028dc:	bd10      	pop	{r4, pc}
                if ((pdev->dev.class_cb->EP0_RxReady != NULL) &&
 10028de:	0003      	movs	r3, r0
 10028e0:	33fc      	adds	r3, #252	; 0xfc
 10028e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 10028e4:	691b      	ldr	r3, [r3, #16]
 10028e6:	2b00      	cmp	r3, #0
 10028e8:	d005      	beq.n	10028f6 <USBD_DataOutStage+0x5a>
                        (pdev->dev.device_status == USB_OTG_CONFIGURED))
 10028ea:	0002      	movs	r2, r0
 10028ec:	323a      	adds	r2, #58	; 0x3a
                if ((pdev->dev.class_cb->EP0_RxReady != NULL) &&
 10028ee:	7812      	ldrb	r2, [r2, #0]
 10028f0:	2a03      	cmp	r2, #3
 10028f2:	d100      	bne.n	10028f6 <USBD_DataOutStage+0x5a>
                    pdev->dev.class_cb->EP0_RxReady(pdev);
 10028f4:	4798      	blx	r3
                USBD_CtlSendStatus(pdev);
 10028f6:	0020      	movs	r0, r4
 10028f8:	f000 f8d4 	bl	1002aa4 <USBD_CtlSendStatus>
 10028fc:	e7ed      	b.n	10028da <USBD_DataOutStage+0x3e>
    else if ((pdev->dev.class_cb->DataOut != NULL) &&
 10028fe:	33fc      	adds	r3, #252	; 0xfc
 1002900:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 1002902:	699b      	ldr	r3, [r3, #24]
 1002904:	2b00      	cmp	r3, #0
 1002906:	d0e8      	beq.n	10028da <USBD_DataOutStage+0x3e>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
 1002908:	0002      	movs	r2, r0
 100290a:	323a      	adds	r2, #58	; 0x3a
    else if ((pdev->dev.class_cb->DataOut != NULL) &&
 100290c:	7812      	ldrb	r2, [r2, #0]
 100290e:	2a03      	cmp	r2, #3
 1002910:	d1e3      	bne.n	10028da <USBD_DataOutStage+0x3e>
        pdev->dev.class_cb->DataOut(pdev, epnum);
 1002912:	4798      	blx	r3
 1002914:	e7e1      	b.n	10028da <USBD_DataOutStage+0x3e>

01002916 <USBD_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
static uint8_t USBD_DataInStage(USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 1002916:	b510      	push	{r4, lr}
    USB_OTG_EP *ep;

    if (epnum == 0)
 1002918:	2900      	cmp	r1, #0
 100291a:	d00b      	beq.n	1002934 <USBD_DataInStage+0x1e>
    {

    }
    else if ((pdev->dev.class_cb->DataIn != NULL) &&
 100291c:	0003      	movs	r3, r0
 100291e:	33fc      	adds	r3, #252	; 0xfc
 1002920:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 1002922:	695b      	ldr	r3, [r3, #20]
 1002924:	2b00      	cmp	r3, #0
 1002926:	d005      	beq.n	1002934 <USBD_DataInStage+0x1e>
             (pdev->dev.device_status == USB_OTG_CONFIGURED))
 1002928:	0002      	movs	r2, r0
 100292a:	323a      	adds	r2, #58	; 0x3a
    else if ((pdev->dev.class_cb->DataIn != NULL) &&
 100292c:	7812      	ldrb	r2, [r2, #0]
 100292e:	2a03      	cmp	r2, #3
 1002930:	d100      	bne.n	1002934 <USBD_DataInStage+0x1e>
    {
        pdev->dev.class_cb->DataIn(pdev, epnum);
 1002932:	4798      	blx	r3
    }
    return USBD_OK;
}
 1002934:	2000      	movs	r0, #0
 1002936:	bd10      	pop	{r4, pc}

01002938 <USBD_Init>:
void USBD_Init(USB_OTG_CORE_HANDLE *pdev,
               USB_OTG_CORE_ID_TypeDef coreID,
               USBD_DEVICE *pDevice,
               USBD_Class_cb_TypeDef *class_cb,
               USBD_Usr_cb_TypeDef *usr_cb)
{
 1002938:	b510      	push	{r4, lr}

    /* Hardware Init */
    USBD_DeInit(pdev);

    /*Register class and user callbacks */
    pdev->dev.class_cb = class_cb;
 100293a:	0004      	movs	r4, r0
 100293c:	34fc      	adds	r4, #252	; 0xfc
 100293e:	6723      	str	r3, [r4, #112]	; 0x70
    pdev->dev.usr_cb = usr_cb;
 1002940:	9b02      	ldr	r3, [sp, #8]
    pdev->dev.usr_device = pDevice;
 1002942:	67a2      	str	r2, [r4, #120]	; 0x78
    pdev->dev.usr_cb = usr_cb;
 1002944:	6763      	str	r3, [r4, #116]	; 0x74

    /* set USB OTG core params */
    DCD_Init(pdev, coreID);
 1002946:	f7ff fd7a 	bl	100243e <DCD_Init>
}
 100294a:	bd10      	pop	{r4, pc}

0100294c <USBD_DeInit>:
USBD_Status USBD_DeInit(USB_OTG_CORE_HANDLE *pdev)
{
    /* Software Init */

    return USBD_OK;
}
 100294c:	2000      	movs	r0, #0
 100294e:	4770      	bx	lr

01002950 <USBD_Reset>:


static uint8_t USBD_Reset(USB_OTG_CORE_HANDLE  *pdev)
{
    /* Open EP0 OUT */
    DCD_EP_Open(pdev,
 1002950:	2300      	movs	r3, #0
{
 1002952:	b510      	push	{r4, lr}
 1002954:	0004      	movs	r4, r0
    DCD_EP_Open(pdev,
 1002956:	0019      	movs	r1, r3
 1002958:	2240      	movs	r2, #64	; 0x40
 100295a:	f7ff fda5 	bl	10024a8 <DCD_EP_Open>
                0x00,
                USB_OTG_MAX_EP0_SIZE,
                EP_TYPE_CTRL);

    /* Open EP0 IN */
    DCD_EP_Open(pdev,
 100295e:	2180      	movs	r1, #128	; 0x80
 1002960:	2300      	movs	r3, #0
 1002962:	2240      	movs	r2, #64	; 0x40
 1002964:	0020      	movs	r0, r4
 1002966:	f7ff fd9f 	bl	10024a8 <DCD_EP_Open>
                0x80,
                USB_OTG_MAX_EP0_SIZE,
                EP_TYPE_CTRL);

    /* Upon Reset call usr call back */
    pdev->dev.device_status = USB_OTG_DEFAULT;
 100296a:	0023      	movs	r3, r4
 100296c:	2201      	movs	r2, #1
 100296e:	333a      	adds	r3, #58	; 0x3a
 1002970:	701a      	strb	r2, [r3, #0]
    pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 1002972:	78a0      	ldrb	r0, [r4, #2]
 1002974:	34fc      	adds	r4, #252	; 0xfc
 1002976:	6f63      	ldr	r3, [r4, #116]	; 0x74
 1002978:	685b      	ldr	r3, [r3, #4]
 100297a:	4798      	blx	r3

    return USBD_OK;
}
 100297c:	2000      	movs	r0, #0
 100297e:	bd10      	pop	{r4, pc}

01002980 <USBD_Resume>:
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
    /* Upon Resume call usr call back */
    pdev->dev.usr_cb->DeviceResumed();
 1002980:	0003      	movs	r3, r0
 1002982:	33fc      	adds	r3, #252	; 0xfc
 1002984:	6f5b      	ldr	r3, [r3, #116]	; 0x74
{
 1002986:	b510      	push	{r4, lr}
    pdev->dev.usr_cb->DeviceResumed();
 1002988:	691b      	ldr	r3, [r3, #16]
{
 100298a:	0004      	movs	r4, r0
    pdev->dev.usr_cb->DeviceResumed();
 100298c:	4798      	blx	r3
    pdev->dev.device_status = pdev->dev.device_old_status;
    pdev->dev.device_status = USB_OTG_CONFIGURED;
 100298e:	2303      	movs	r3, #3
 1002990:	343a      	adds	r4, #58	; 0x3a
    return USBD_OK;
}
 1002992:	2000      	movs	r0, #0
    pdev->dev.device_status = USB_OTG_CONFIGURED;
 1002994:	7023      	strb	r3, [r4, #0]
}
 1002996:	bd10      	pop	{r4, pc}

01002998 <USBD_Suspend>:
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
    pdev->dev.device_old_status = pdev->dev.device_status;
 1002998:	0003      	movs	r3, r0
 100299a:	0002      	movs	r2, r0
{
 100299c:	b510      	push	{r4, lr}
    pdev->dev.device_old_status = pdev->dev.device_status;
 100299e:	333a      	adds	r3, #58	; 0x3a
 10029a0:	7819      	ldrb	r1, [r3, #0]
 10029a2:	323c      	adds	r2, #60	; 0x3c
 10029a4:	7011      	strb	r1, [r2, #0]
    pdev->dev.device_status  = USB_OTG_SUSPENDED;
 10029a6:	2204      	movs	r2, #4
    /* Upon Resume call usr call back */
    pdev->dev.usr_cb->DeviceSuspended();
 10029a8:	30fc      	adds	r0, #252	; 0xfc
    pdev->dev.device_status  = USB_OTG_SUSPENDED;
 10029aa:	701a      	strb	r2, [r3, #0]
    pdev->dev.usr_cb->DeviceSuspended();
 10029ac:	6f43      	ldr	r3, [r0, #116]	; 0x74
 10029ae:	68db      	ldr	r3, [r3, #12]
 10029b0:	4798      	blx	r3
    return USBD_OK;
}
 10029b2:	2000      	movs	r0, #0
 10029b4:	bd10      	pop	{r4, pc}

010029b6 <USBD_SOF>:
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
    if (pdev->dev.class_cb->SOF)
 10029b6:	0003      	movs	r3, r0
 10029b8:	33fc      	adds	r3, #252	; 0xfc
 10029ba:	6f1b      	ldr	r3, [r3, #112]	; 0x70
{
 10029bc:	b510      	push	{r4, lr}
    if (pdev->dev.class_cb->SOF)
 10029be:	69db      	ldr	r3, [r3, #28]
 10029c0:	2b00      	cmp	r3, #0
 10029c2:	d000      	beq.n	10029c6 <USBD_SOF+0x10>
    {
        pdev->dev.class_cb->SOF(pdev);
 10029c4:	4798      	blx	r3
    }
    return USBD_OK;
}
 10029c6:	2000      	movs	r0, #0
 10029c8:	bd10      	pop	{r4, pc}

010029ca <USBD_SetCfg>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_Status USBD_SetCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
 10029ca:	b510      	push	{r4, lr}
    pdev->dev.class_cb->Init(pdev, cfgidx);
 10029cc:	0004      	movs	r4, r0
 10029ce:	34fc      	adds	r4, #252	; 0xfc
 10029d0:	6f23      	ldr	r3, [r4, #112]	; 0x70
 10029d2:	681b      	ldr	r3, [r3, #0]
 10029d4:	4798      	blx	r3

    /* Upon set config call usr call back */
    pdev->dev.usr_cb->DeviceConfigured();
 10029d6:	6f63      	ldr	r3, [r4, #116]	; 0x74
 10029d8:	689b      	ldr	r3, [r3, #8]
 10029da:	4798      	blx	r3
    return USBD_OK;
}
 10029dc:	2000      	movs	r0, #0
 10029de:	bd10      	pop	{r4, pc}

010029e0 <USBD_ClrCfg>:
* @param  cfgidx: configuration index
* @retval status: USBD_Status
*/
USBD_Status USBD_ClrCfg(USB_OTG_CORE_HANDLE  *pdev, uint8_t cfgidx)
{
    pdev->dev.class_cb->DeInit(pdev, cfgidx);
 10029e0:	0003      	movs	r3, r0
{
 10029e2:	b510      	push	{r4, lr}
    pdev->dev.class_cb->DeInit(pdev, cfgidx);
 10029e4:	33fc      	adds	r3, #252	; 0xfc
 10029e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 10029e8:	685b      	ldr	r3, [r3, #4]
 10029ea:	4798      	blx	r3
    return USBD_OK;
}
 10029ec:	2000      	movs	r0, #0
 10029ee:	bd10      	pop	{r4, pc}

010029f0 <USBD_IsoINIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
    pdev->dev.class_cb->IsoINIncomplete(pdev);
 10029f0:	0003      	movs	r3, r0
{
 10029f2:	b510      	push	{r4, lr}
    pdev->dev.class_cb->IsoINIncomplete(pdev);
 10029f4:	33fc      	adds	r3, #252	; 0xfc
 10029f6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 10029f8:	6a1b      	ldr	r3, [r3, #32]
 10029fa:	4798      	blx	r3
    return USBD_OK;
}
 10029fc:	2000      	movs	r0, #0
 10029fe:	bd10      	pop	{r4, pc}

01002a00 <USBD_IsoOUTIncomplete>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
    pdev->dev.class_cb->IsoOUTIncomplete(pdev);
 1002a00:	0003      	movs	r3, r0
{
 1002a02:	b510      	push	{r4, lr}
    pdev->dev.class_cb->IsoOUTIncomplete(pdev);
 1002a04:	33fc      	adds	r3, #252	; 0xfc
 1002a06:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 1002a08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 1002a0a:	4798      	blx	r3
    return USBD_OK;
}
 1002a0c:	2000      	movs	r0, #0
 1002a0e:	bd10      	pop	{r4, pc}

01002a10 <USBD_DevConnected>:
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_DevConnected(USB_OTG_CORE_HANDLE  *pdev)
{
    pdev->dev.usr_cb->DeviceConnected();
 1002a10:	0003      	movs	r3, r0
 1002a12:	33fc      	adds	r3, #252	; 0xfc
 1002a14:	6f5b      	ldr	r3, [r3, #116]	; 0x74
{
 1002a16:	b510      	push	{r4, lr}
    pdev->dev.usr_cb->DeviceConnected();
 1002a18:	695b      	ldr	r3, [r3, #20]
{
 1002a1a:	0004      	movs	r4, r0
    pdev->dev.usr_cb->DeviceConnected();
 1002a1c:	4798      	blx	r3
    pdev->dev.connection_status = 1;
 1002a1e:	2301      	movs	r3, #1
 1002a20:	343e      	adds	r4, #62	; 0x3e
    return USBD_OK;
}
 1002a22:	2000      	movs	r0, #0
    pdev->dev.connection_status = 1;
 1002a24:	7023      	strb	r3, [r4, #0]
}
 1002a26:	bd10      	pop	{r4, pc}

01002a28 <USBD_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_DevDisconnected(USB_OTG_CORE_HANDLE  *pdev)
{
 1002a28:	b570      	push	{r4, r5, r6, lr}
    pdev->dev.usr_cb->DeviceDisconnected();
 1002a2a:	0005      	movs	r5, r0
{
 1002a2c:	0004      	movs	r4, r0
    pdev->dev.usr_cb->DeviceDisconnected();
 1002a2e:	35fc      	adds	r5, #252	; 0xfc
 1002a30:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 1002a32:	699b      	ldr	r3, [r3, #24]
 1002a34:	4798      	blx	r3
    pdev->dev.class_cb->DeInit(pdev, 0);
 1002a36:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 1002a38:	2100      	movs	r1, #0
 1002a3a:	685b      	ldr	r3, [r3, #4]
 1002a3c:	0020      	movs	r0, r4
 1002a3e:	4798      	blx	r3
    pdev->dev.connection_status = 0;
 1002a40:	2000      	movs	r0, #0
 1002a42:	343e      	adds	r4, #62	; 0x3e
 1002a44:	7020      	strb	r0, [r4, #0]
    return USBD_OK;
}
 1002a46:	bd70      	pop	{r4, r5, r6, pc}

01002a48 <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData(USB_OTG_CORE_HANDLE  *pdev,
                              uint8_t *pbuf,
                              uint16_t len)
{
 1002a48:	b510      	push	{r4, lr}
 1002a4a:	0013      	movs	r3, r2
    USBD_Status ret = USBD_OK;
    pdev->dev.in_ep[0].total_data_len = len;
 1002a4c:	6602      	str	r2, [r0, #96]	; 0x60
    pdev->dev.in_ep[0].rem_data_len   = len;
 1002a4e:	65c2      	str	r2, [r0, #92]	; 0x5c
    pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 1002a50:	0002      	movs	r2, r0
 1002a52:	2402      	movs	r4, #2
 1002a54:	3239      	adds	r2, #57	; 0x39
 1002a56:	7014      	strb	r4, [r2, #0]
    DCD_EP_Tx(pdev, 0, pbuf, len);
 1002a58:	000a      	movs	r2, r1
 1002a5a:	2100      	movs	r1, #0
 1002a5c:	f7ff fdb6 	bl	10025cc <DCD_EP_Tx>
    return ret;
}
 1002a60:	2000      	movs	r0, #0
 1002a62:	bd10      	pop	{r4, pc}

01002a64 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData(USB_OTG_CORE_HANDLE  *pdev,
                                      uint8_t *pbuf,
                                      uint16_t len)
{
 1002a64:	b510      	push	{r4, lr}
 1002a66:	0013      	movs	r3, r2
    USBD_Status ret = USBD_OK;
    DCD_EP_Tx(pdev, 0, pbuf, len);
 1002a68:	000a      	movs	r2, r1
 1002a6a:	2100      	movs	r1, #0
 1002a6c:	f7ff fdae 	bl	10025cc <DCD_EP_Tx>
    return ret;
}
 1002a70:	2000      	movs	r0, #0
 1002a72:	bd10      	pop	{r4, pc}

01002a74 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_Status  USBD_CtlPrepareRx(USB_OTG_CORE_HANDLE  *pdev,
                               uint8_t *pbuf,
                               uint16_t len)
{
 1002a74:	0013      	movs	r3, r2
    USBD_Status ret = USBD_OK;

    pdev->dev.out_ep[0].total_data_len = len;
 1002a76:	0002      	movs	r2, r0
{
 1002a78:	b510      	push	{r4, lr}
    pdev->dev.out_ep[0].rem_data_len   = len;
    pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 1002a7a:	2403      	movs	r4, #3
    pdev->dev.out_ep[0].total_data_len = len;
 1002a7c:	32f0      	adds	r2, #240	; 0xf0
 1002a7e:	6013      	str	r3, [r2, #0]
    pdev->dev.out_ep[0].rem_data_len   = len;
 1002a80:	3a04      	subs	r2, #4
 1002a82:	6013      	str	r3, [r2, #0]
    pdev->dev.device_state = USB_OTG_EP0_DATA_OUT;
 1002a84:	3ab3      	subs	r2, #179	; 0xb3
 1002a86:	7014      	strb	r4, [r2, #0]
    DCD_EP_PrepareRx(pdev,
 1002a88:	000a      	movs	r2, r1
 1002a8a:	2100      	movs	r1, #0
 1002a8c:	f7ff fd40 	bl	1002510 <DCD_EP_PrepareRx>
                     0,
                     pbuf,
                     len);

    return ret;
}
 1002a90:	2000      	movs	r0, #0
 1002a92:	bd10      	pop	{r4, pc}

01002a94 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx(USB_OTG_CORE_HANDLE  *pdev,
                                uint8_t *pbuf,
                                uint16_t len)
{
 1002a94:	b510      	push	{r4, lr}
 1002a96:	0013      	movs	r3, r2
    USBD_Status ret = USBD_OK;
    DCD_EP_PrepareRx(pdev,
 1002a98:	000a      	movs	r2, r1
 1002a9a:	2100      	movs	r1, #0
 1002a9c:	f7ff fd38 	bl	1002510 <DCD_EP_PrepareRx>
                     0,
                     pbuf,
                     len);
    return ret;
}
 1002aa0:	2000      	movs	r0, #0
 1002aa2:	bd10      	pop	{r4, pc}

01002aa4 <USBD_CtlSendStatus>:
* @retval status
*/
USBD_Status  USBD_CtlSendStatus(USB_OTG_CORE_HANDLE  *pdev)
{
    USBD_Status ret = USBD_OK;
    pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 1002aa4:	0003      	movs	r3, r0
 1002aa6:	2204      	movs	r2, #4
{
 1002aa8:	b510      	push	{r4, lr}
    pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 1002aaa:	3339      	adds	r3, #57	; 0x39
 1002aac:	701a      	strb	r2, [r3, #0]
    //    DCD_EP_Tx (pdev,
    //               0,
    //               NULL,
    //               0);
    USB_OTG_EPReply_Zerolen(pdev, 0);
 1002aae:	2100      	movs	r1, #0
 1002ab0:	f7ff fca6 	bl	1002400 <USB_OTG_EPReply_Zerolen>

    //    USB_OTG_EP0_OutStart(pdev);

    return ret;
}
 1002ab4:	2000      	movs	r0, #0
 1002ab6:	bd10      	pop	{r4, pc}

01002ab8 <USBD_CtlReceiveStatus>:
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus(USB_OTG_CORE_HANDLE  *pdev)
{
    USBD_Status ret = USBD_OK;
    pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;
 1002ab8:	0003      	movs	r3, r0
 1002aba:	2205      	movs	r2, #5
 1002abc:	3339      	adds	r3, #57	; 0x39
{
 1002abe:	b510      	push	{r4, lr}
    pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;
 1002ac0:	701a      	strb	r2, [r3, #0]
    DCD_EP_PrepareRx(pdev,
 1002ac2:	2300      	movs	r3, #0
 1002ac4:	001a      	movs	r2, r3
 1002ac6:	0019      	movs	r1, r3
 1002ac8:	f7ff fd22 	bl	1002510 <DCD_EP_PrepareRx>
                     0,
                     NULL,
                     0);

    return ret;
}
 1002acc:	2000      	movs	r0, #0
 1002ace:	bd10      	pop	{r4, pc}

01002ad0 <USBD_GetRxCount>:
*         epnum: endpoint index
* @retval Rx Data blength
*/
uint16_t  USBD_GetRxCount(USB_OTG_CORE_HANDLE  *pdev, uint8_t epnum)
{
    return pdev->dev.out_ep[epnum].xfer_count;
 1002ad0:	2324      	movs	r3, #36	; 0x24
 1002ad2:	4359      	muls	r1, r3
 1002ad4:	1840      	adds	r0, r0, r1
 1002ad6:	30e8      	adds	r0, #232	; 0xe8
 1002ad8:	6800      	ldr	r0, [r0, #0]
 1002ada:	b280      	uxth	r0, r0
}
 1002adc:	4770      	bx	lr
	...

01002ae0 <USBD_StdDevReq>:
* @retval status
*/
extern uint8_t SetAddress_Flag;
extern uint8_t Address_Value;
USBD_Status  USBD_StdDevReq(USB_OTG_CORE_HANDLE  *pdev, USB_SETUP_REQ  *req)
{
 1002ae0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1002ae2:	0004      	movs	r4, r0
    USBD_Status ret = USBD_OK;
    USB_OTG_CTL_TypeDef power;

    switch (req->bRequest)
 1002ae4:	7848      	ldrb	r0, [r1, #1]
{
 1002ae6:	000d      	movs	r5, r1
    switch (req->bRequest)
 1002ae8:	2809      	cmp	r0, #9
 1002aea:	d900      	bls.n	1002aee <USBD_StdDevReq+0xe>
 1002aec:	e07d      	b.n	1002bea <USBD_StdDevReq+0x10a>
 1002aee:	f001 fa13 	bl	1003f18 <__gnu_thumb1_case_uhi>
 1002af2:	00cf      	.short	0x00cf
 1002af4:	007c00e8 	.word	0x007c00e8
 1002af8:	007c00df 	.word	0x007c00df
 1002afc:	000a0069 	.word	0x000a0069
 1002b00:	00c0008d 	.word	0x00c0008d
 1002b04:	0091      	.short	0x0091
                               USB_SETUP_REQ *req)
{
    uint16_t len;
    uint8_t *pbuf;

    switch (req->wValue >> 8)
 1002b06:	8849      	ldrh	r1, [r1, #2]
 1002b08:	0a0e      	lsrs	r6, r1, #8
 1002b0a:	2e02      	cmp	r6, #2
 1002b0c:	d01e      	beq.n	1002b4c <USBD_StdDevReq+0x6c>
 1002b0e:	2e03      	cmp	r6, #3
 1002b10:	d027      	beq.n	1002b62 <USBD_StdDevReq+0x82>
 1002b12:	2e01      	cmp	r6, #1
 1002b14:	d169      	bne.n	1002bea <USBD_StdDevReq+0x10a>
    {
    case USB_DESC_TYPE_DEVICE:
        pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 1002b16:	0023      	movs	r3, r4
 1002b18:	466a      	mov	r2, sp
 1002b1a:	33fc      	adds	r3, #252	; 0xfc
 1002b1c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 1002b1e:	78a0      	ldrb	r0, [r4, #2]
 1002b20:	681b      	ldr	r3, [r3, #0]
 1002b22:	1d91      	adds	r1, r2, #6
 1002b24:	4798      	blx	r3
    default:
        USBD_CtlError(pdev, req);
        return;
    }

    if ((len != 0) && (req->wLength != 0))
 1002b26:	466b      	mov	r3, sp
 1002b28:	1d9e      	adds	r6, r3, #6
 1002b2a:	8831      	ldrh	r1, [r6, #0]
 1002b2c:	2900      	cmp	r1, #0
 1002b2e:	d06d      	beq.n	1002c0c <USBD_StdDevReq+0x12c>
 1002b30:	88ea      	ldrh	r2, [r5, #6]
 1002b32:	2a00      	cmp	r2, #0
 1002b34:	d06a      	beq.n	1002c0c <USBD_StdDevReq+0x12c>
    {

        len = MIN(len, req->wLength);
 1002b36:	1c0b      	adds	r3, r1, #0
 1002b38:	4291      	cmp	r1, r2
 1002b3a:	d900      	bls.n	1002b3e <USBD_StdDevReq+0x5e>
 1002b3c:	1c13      	adds	r3, r2, #0

        USBD_CtlSendData(pdev,
 1002b3e:	0001      	movs	r1, r0
        len = MIN(len, req->wLength);
 1002b40:	b29a      	uxth	r2, r3
 1002b42:	8033      	strh	r3, [r6, #0]
        if (pdev->dev.DevRemoteWakeup)
        {
            USBD_cfg_status |= USB_CONFIG_REMOTE_WAKEUP;
        }

        USBD_CtlSendData(pdev,
 1002b44:	0020      	movs	r0, r4
 1002b46:	f7ff ff7f 	bl	1002a48 <USBD_CtlSendData>
 1002b4a:	e05f      	b.n	1002c0c <USBD_StdDevReq+0x12c>
        pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 1002b4c:	0027      	movs	r7, r4
 1002b4e:	466a      	mov	r2, sp
 1002b50:	37fc      	adds	r7, #252	; 0xfc
 1002b52:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 1002b54:	78a0      	ldrb	r0, [r4, #2]
 1002b56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1002b58:	1d91      	adds	r1, r2, #6
 1002b5a:	4798      	blx	r3
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 1002b5c:	7046      	strb	r6, [r0, #1]
        pdev->dev.pConfig_descriptor = pbuf;
 1002b5e:	67f8      	str	r0, [r7, #124]	; 0x7c
 1002b60:	e7e1      	b.n	1002b26 <USBD_StdDevReq+0x46>
 1002b62:	0022      	movs	r2, r4
        switch ((uint8_t)(req->wValue))
 1002b64:	b2c9      	uxtb	r1, r1
 1002b66:	78a3      	ldrb	r3, [r4, #2]
 1002b68:	32fc      	adds	r2, #252	; 0xfc
 1002b6a:	2905      	cmp	r1, #5
 1002b6c:	d823      	bhi.n	1002bb6 <USBD_StdDevReq+0xd6>
 1002b6e:	0008      	movs	r0, r1
            pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 1002b70:	6f92      	ldr	r2, [r2, #120]	; 0x78
        switch ((uint8_t)(req->wValue))
 1002b72:	f001 f9c7 	bl	1003f04 <__gnu_thumb1_case_uqi>
 1002b76:	0903      	.short	0x0903
 1002b78:	1e1c0d0b 	.word	0x1e1c0d0b
            pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);
 1002b7c:	6852      	ldr	r2, [r2, #4]
            pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 1002b7e:	4669      	mov	r1, sp
 1002b80:	0018      	movs	r0, r3
 1002b82:	3106      	adds	r1, #6
 1002b84:	4790      	blx	r2
 1002b86:	e7ce      	b.n	1002b26 <USBD_StdDevReq+0x46>
            pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 1002b88:	6892      	ldr	r2, [r2, #8]
 1002b8a:	e7f8      	b.n	1002b7e <USBD_StdDevReq+0x9e>
            pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 1002b8c:	68d2      	ldr	r2, [r2, #12]
 1002b8e:	e7f6      	b.n	1002b7e <USBD_StdDevReq+0x9e>
            pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 1002b90:	4669      	mov	r1, sp
 1002b92:	0018      	movs	r0, r3
 1002b94:	6912      	ldr	r2, [r2, #16]
 1002b96:	3106      	adds	r1, #6
 1002b98:	4790      	blx	r2
            if (pdev->dev.device_status == USB_OTG_CONFIGURED)
 1002b9a:	0023      	movs	r3, r4
 1002b9c:	333a      	adds	r3, #58	; 0x3a
 1002b9e:	781b      	ldrb	r3, [r3, #0]
 1002ba0:	2b03      	cmp	r3, #3
 1002ba2:	d1c0      	bne.n	1002b26 <USBD_StdDevReq+0x46>
                pdev->dev.device_status_new = USB_OTG_END;
 1002ba4:	0023      	movs	r3, r4
 1002ba6:	2205      	movs	r2, #5
 1002ba8:	333b      	adds	r3, #59	; 0x3b
 1002baa:	701a      	strb	r2, [r3, #0]
 1002bac:	e7bb      	b.n	1002b26 <USBD_StdDevReq+0x46>
            pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 1002bae:	6952      	ldr	r2, [r2, #20]
 1002bb0:	e7e5      	b.n	1002b7e <USBD_StdDevReq+0x9e>
            pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 1002bb2:	6992      	ldr	r2, [r2, #24]
 1002bb4:	e7e3      	b.n	1002b7e <USBD_StdDevReq+0x9e>
            pbuf = pdev->dev.class_cb->GetUsrStrDescriptor(pdev->cfg.speed, (req->wValue), &len);
 1002bb6:	6f12      	ldr	r2, [r2, #112]	; 0x70
 1002bb8:	0018      	movs	r0, r3
 1002bba:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
 1002bbc:	466a      	mov	r2, sp
 1002bbe:	3206      	adds	r2, #6
 1002bc0:	47b0      	blx	r6
 1002bc2:	e7b0      	b.n	1002b26 <USBD_StdDevReq+0x46>
        SetAddress_Flag = 1;
 1002bc4:	2701      	movs	r7, #1
 1002bc6:	4b48      	ldr	r3, [pc, #288]	; (1002ce8 <USBD_StdDevReq+0x208>)
 1002bc8:	701f      	strb	r7, [r3, #0]
        Address_Value = (uint8_t)(req->wValue) & 0x7F;
 1002bca:	237f      	movs	r3, #127	; 0x7f
 1002bcc:	884e      	ldrh	r6, [r1, #2]
 1002bce:	401e      	ands	r6, r3
 1002bd0:	4b46      	ldr	r3, [pc, #280]	; (1002cec <USBD_StdDevReq+0x20c>)
 1002bd2:	701e      	strb	r6, [r3, #0]
    if ((req->wIndex == 0) && (req->wLength == 0))
 1002bd4:	888b      	ldrh	r3, [r1, #4]
 1002bd6:	2b00      	cmp	r3, #0
 1002bd8:	d107      	bne.n	1002bea <USBD_StdDevReq+0x10a>
 1002bda:	88cb      	ldrh	r3, [r1, #6]
 1002bdc:	2b00      	cmp	r3, #0
 1002bde:	d104      	bne.n	1002bea <USBD_StdDevReq+0x10a>
        if (pdev->dev.device_status == USB_OTG_CONFIGURED)
 1002be0:	0025      	movs	r5, r4
 1002be2:	353a      	adds	r5, #58	; 0x3a
 1002be4:	782b      	ldrb	r3, [r5, #0]
 1002be6:	2b03      	cmp	r3, #3
 1002be8:	d104      	bne.n	1002bf4 <USBD_StdDevReq+0x114>
*/

void USBD_CtlError(USB_OTG_CORE_HANDLE  *pdev,
                   USB_SETUP_REQ *req)
{
    DCD_EP_Stall(pdev, 0);
 1002bea:	2100      	movs	r1, #0
 1002bec:	0020      	movs	r0, r4
 1002bee:	f7ff fd09 	bl	1002604 <DCD_EP_Stall>
 1002bf2:	e00b      	b.n	1002c0c <USBD_StdDevReq+0x12c>
            pdev->dev.device_address = dev_addr;
 1002bf4:	0023      	movs	r3, r4
 1002bf6:	333d      	adds	r3, #61	; 0x3d
 1002bf8:	701e      	strb	r6, [r3, #0]
            USB_OTG_WRITE_REG8(&pdev->regs.CTRLREGS->FADDR, Address_Value);
 1002bfa:	68e3      	ldr	r3, [r4, #12]
            USBD_CtlSendStatus(pdev);
 1002bfc:	0020      	movs	r0, r4
            USB_OTG_WRITE_REG8(&pdev->regs.CTRLREGS->FADDR, Address_Value);
 1002bfe:	711e      	strb	r6, [r3, #4]
            USBD_CtlSendStatus(pdev);
 1002c00:	f7ff ff50 	bl	1002aa4 <USBD_CtlSendStatus>
            if (dev_addr != 0)
 1002c04:	2e00      	cmp	r6, #0
 1002c06:	d003      	beq.n	1002c10 <USBD_StdDevReq+0x130>
                pdev->dev.device_status  = USB_OTG_ADDRESSED;
 1002c08:	2302      	movs	r3, #2
 1002c0a:	702b      	strb	r3, [r5, #0]
}
 1002c0c:	2000      	movs	r0, #0
 1002c0e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                pdev->dev.device_status  = USB_OTG_DEFAULT;
 1002c10:	702f      	strb	r7, [r5, #0]
 1002c12:	e7fb      	b.n	1002c0c <USBD_StdDevReq+0x12c>
    cfgidx = (uint8_t)(req->wValue);
 1002c14:	7889      	ldrb	r1, [r1, #2]
 1002c16:	4e36      	ldr	r6, [pc, #216]	; (1002cf0 <USBD_StdDevReq+0x210>)
 1002c18:	7031      	strb	r1, [r6, #0]
    if (cfgidx > USBD_CFG_MAX_NUM)
 1002c1a:	2901      	cmp	r1, #1
 1002c1c:	d8e5      	bhi.n	1002bea <USBD_StdDevReq+0x10a>
        switch (pdev->dev.device_status)
 1002c1e:	0023      	movs	r3, r4
 1002c20:	333a      	adds	r3, #58	; 0x3a
 1002c22:	781a      	ldrb	r2, [r3, #0]
 1002c24:	2a02      	cmp	r2, #2
 1002c26:	d00f      	beq.n	1002c48 <USBD_StdDevReq+0x168>
 1002c28:	2a03      	cmp	r2, #3
 1002c2a:	d1de      	bne.n	1002bea <USBD_StdDevReq+0x10a>
 1002c2c:	0025      	movs	r5, r4
 1002c2e:	3538      	adds	r5, #56	; 0x38
            if (cfgidx == 0)
 1002c30:	2900      	cmp	r1, #0
 1002c32:	d115      	bne.n	1002c60 <USBD_StdDevReq+0x180>
                pdev->dev.device_status = USB_OTG_ADDRESSED;
 1002c34:	2202      	movs	r2, #2
                USBD_ClrCfg(pdev, cfgidx);
 1002c36:	0020      	movs	r0, r4
                pdev->dev.device_status = USB_OTG_ADDRESSED;
 1002c38:	701a      	strb	r2, [r3, #0]
                pdev->dev.device_config = cfgidx;
 1002c3a:	7029      	strb	r1, [r5, #0]
                USBD_ClrCfg(pdev, cfgidx);
 1002c3c:	f7ff fed0 	bl	10029e0 <USBD_ClrCfg>
            USBD_CtlSendStatus(pdev);
 1002c40:	0020      	movs	r0, r4
 1002c42:	f7ff ff2f 	bl	1002aa4 <USBD_CtlSendStatus>
 1002c46:	e7e1      	b.n	1002c0c <USBD_StdDevReq+0x12c>
            if (cfgidx)
 1002c48:	2900      	cmp	r1, #0
 1002c4a:	d0f9      	beq.n	1002c40 <USBD_StdDevReq+0x160>
                pdev->dev.device_config = cfgidx;
 1002c4c:	0022      	movs	r2, r4
 1002c4e:	2101      	movs	r1, #1
 1002c50:	3238      	adds	r2, #56	; 0x38
 1002c52:	7011      	strb	r1, [r2, #0]
                pdev->dev.device_status = USB_OTG_CONFIGURED;
 1002c54:	2203      	movs	r2, #3
 1002c56:	701a      	strb	r2, [r3, #0]
                USBD_SetCfg(pdev, cfgidx);
 1002c58:	0020      	movs	r0, r4
 1002c5a:	f7ff feb6 	bl	10029ca <USBD_SetCfg>
 1002c5e:	e7ef      	b.n	1002c40 <USBD_StdDevReq+0x160>
            else  if (cfgidx != pdev->dev.device_config)
 1002c60:	7829      	ldrb	r1, [r5, #0]
 1002c62:	2901      	cmp	r1, #1
 1002c64:	d0ec      	beq.n	1002c40 <USBD_StdDevReq+0x160>
                USBD_ClrCfg(pdev, pdev->dev.device_config);
 1002c66:	0020      	movs	r0, r4
 1002c68:	f7ff feba 	bl	10029e0 <USBD_ClrCfg>
                pdev->dev.device_config = cfgidx;
 1002c6c:	7831      	ldrb	r1, [r6, #0]
 1002c6e:	7029      	strb	r1, [r5, #0]
 1002c70:	e7f2      	b.n	1002c58 <USBD_StdDevReq+0x178>
    if (req->wLength != 1)
 1002c72:	88ca      	ldrh	r2, [r1, #6]
 1002c74:	2a01      	cmp	r2, #1
 1002c76:	d1b8      	bne.n	1002bea <USBD_StdDevReq+0x10a>
        switch (pdev->dev.device_status)
 1002c78:	0023      	movs	r3, r4
 1002c7a:	333a      	adds	r3, #58	; 0x3a
 1002c7c:	781b      	ldrb	r3, [r3, #0]
 1002c7e:	2b02      	cmp	r3, #2
 1002c80:	d004      	beq.n	1002c8c <USBD_StdDevReq+0x1ac>
 1002c82:	2b03      	cmp	r3, #3
 1002c84:	d1b1      	bne.n	1002bea <USBD_StdDevReq+0x10a>
            USBD_CtlSendData(pdev,
 1002c86:	0021      	movs	r1, r4
 1002c88:	3138      	adds	r1, #56	; 0x38
 1002c8a:	e75b      	b.n	1002b44 <USBD_StdDevReq+0x64>
            USBD_CtlSendData(pdev,
 1002c8c:	4919      	ldr	r1, [pc, #100]	; (1002cf4 <USBD_StdDevReq+0x214>)
 1002c8e:	e759      	b.n	1002b44 <USBD_StdDevReq+0x64>
    switch (pdev->dev.device_status)
 1002c90:	0023      	movs	r3, r4
 1002c92:	333a      	adds	r3, #58	; 0x3a
 1002c94:	781b      	ldrb	r3, [r3, #0]
 1002c96:	3b02      	subs	r3, #2
 1002c98:	2b01      	cmp	r3, #1
 1002c9a:	d8a6      	bhi.n	1002bea <USBD_StdDevReq+0x10a>
        USBD_cfg_status = USB_CONFIG_SELF_POWERED;
 1002c9c:	2301      	movs	r3, #1
 1002c9e:	4916      	ldr	r1, [pc, #88]	; (1002cf8 <USBD_StdDevReq+0x218>)
 1002ca0:	600b      	str	r3, [r1, #0]
        if (pdev->dev.DevRemoteWakeup)
 1002ca2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 1002ca4:	2b00      	cmp	r3, #0
 1002ca6:	d001      	beq.n	1002cac <USBD_StdDevReq+0x1cc>
            USBD_cfg_status |= USB_CONFIG_REMOTE_WAKEUP;
 1002ca8:	2303      	movs	r3, #3
 1002caa:	600b      	str	r3, [r1, #0]
        USBD_CtlSendData(pdev,
 1002cac:	2202      	movs	r2, #2
 1002cae:	e749      	b.n	1002b44 <USBD_StdDevReq+0x64>
        pdev->dev.DevRemoteWakeup = 1;
 1002cb0:	2301      	movs	r3, #1
        power.d8 = USB_OTG_READ_REG8(CORE_USB_CONFIG);
 1002cb2:	22f6      	movs	r2, #246	; 0xf6
        power.b.wakeup_enable = 1;
 1002cb4:	2180      	movs	r1, #128	; 0x80
        pdev->dev.DevRemoteWakeup = 1;
 1002cb6:	6423      	str	r3, [r4, #64]	; 0x40
        power.d8 = USB_OTG_READ_REG8(CORE_USB_CONFIG);
 1002cb8:	0312      	lsls	r2, r2, #12
 1002cba:	7813      	ldrb	r3, [r2, #0]
        USB_OTG_WRITE_REG8(CORE_USB_CONFIG, power.d8);
 1002cbc:	430b      	orrs	r3, r1
 1002cbe:	7013      	strb	r3, [r2, #0]
 1002cc0:	e7be      	b.n	1002c40 <USBD_StdDevReq+0x160>
    switch (pdev->dev.device_status)
 1002cc2:	0023      	movs	r3, r4
 1002cc4:	333a      	adds	r3, #58	; 0x3a
 1002cc6:	781b      	ldrb	r3, [r3, #0]
 1002cc8:	3b02      	subs	r3, #2
 1002cca:	2b01      	cmp	r3, #1
 1002ccc:	d900      	bls.n	1002cd0 <USBD_StdDevReq+0x1f0>
 1002cce:	e78c      	b.n	1002bea <USBD_StdDevReq+0x10a>
        if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 1002cd0:	884b      	ldrh	r3, [r1, #2]
 1002cd2:	2b01      	cmp	r3, #1
 1002cd4:	d19a      	bne.n	1002c0c <USBD_StdDevReq+0x12c>
            pdev->dev.DevRemoteWakeup = 0;
 1002cd6:	2300      	movs	r3, #0
 1002cd8:	6423      	str	r3, [r4, #64]	; 0x40
            pdev->dev.class_cb->Setup(pdev, req);
 1002cda:	0023      	movs	r3, r4
 1002cdc:	33fc      	adds	r3, #252	; 0xfc
 1002cde:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 1002ce0:	0020      	movs	r0, r4
 1002ce2:	689b      	ldr	r3, [r3, #8]
 1002ce4:	4798      	blx	r3
 1002ce6:	e7ab      	b.n	1002c40 <USBD_StdDevReq+0x160>
 1002ce8:	00020a4e 	.word	0x00020a4e
 1002cec:	00020a4f 	.word	0x00020a4f
 1002cf0:	00020a60 	.word	0x00020a60
 1002cf4:	00020a58 	.word	0x00020a58
 1002cf8:	00020a5c 	.word	0x00020a5c

01002cfc <USBD_StdItfReq>:
    switch (pdev->dev.device_status)
 1002cfc:	0003      	movs	r3, r0
{
 1002cfe:	b570      	push	{r4, r5, r6, lr}
    switch (pdev->dev.device_status)
 1002d00:	333a      	adds	r3, #58	; 0x3a
 1002d02:	781b      	ldrb	r3, [r3, #0]
{
 1002d04:	0004      	movs	r4, r0
 1002d06:	000d      	movs	r5, r1
    switch (pdev->dev.device_status)
 1002d08:	2b03      	cmp	r3, #3
 1002d0a:	d10f      	bne.n	1002d2c <USBD_StdItfReq+0x30>
        if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM)
 1002d0c:	790b      	ldrb	r3, [r1, #4]
 1002d0e:	2b01      	cmp	r3, #1
 1002d10:	d80c      	bhi.n	1002d2c <USBD_StdItfReq+0x30>
            pdev->dev.class_cb->Setup(pdev, req);
 1002d12:	0003      	movs	r3, r0
 1002d14:	33fc      	adds	r3, #252	; 0xfc
 1002d16:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 1002d18:	689b      	ldr	r3, [r3, #8]
 1002d1a:	4798      	blx	r3
            if ((req->wLength == 0) && (ret == USBD_OK))
 1002d1c:	88eb      	ldrh	r3, [r5, #6]
 1002d1e:	2b00      	cmp	r3, #0
 1002d20:	d102      	bne.n	1002d28 <USBD_StdItfReq+0x2c>
                USBD_CtlSendStatus(pdev);
 1002d22:	0020      	movs	r0, r4
 1002d24:	f7ff febe 	bl	1002aa4 <USBD_CtlSendStatus>
}
 1002d28:	2000      	movs	r0, #0
 1002d2a:	bd70      	pop	{r4, r5, r6, pc}
    DCD_EP_Stall(pdev, 0);
 1002d2c:	2100      	movs	r1, #0
 1002d2e:	0020      	movs	r0, r4
 1002d30:	f7ff fc68 	bl	1002604 <DCD_EP_Stall>
 1002d34:	e7f8      	b.n	1002d28 <USBD_StdItfReq+0x2c>
	...

01002d38 <USBD_StdEPReq>:
{
 1002d38:	b570      	push	{r4, r5, r6, lr}
 1002d3a:	000d      	movs	r5, r1
    ep_addr  = LOBYTE(req->wIndex);
 1002d3c:	888a      	ldrh	r2, [r1, #4]
    switch (req->bRequest)
 1002d3e:	786b      	ldrb	r3, [r5, #1]
{
 1002d40:	0004      	movs	r4, r0
    ep_addr  = LOBYTE(req->wIndex);
 1002d42:	b2d1      	uxtb	r1, r2
    switch (req->bRequest)
 1002d44:	2b01      	cmp	r3, #1
 1002d46:	d01e      	beq.n	1002d86 <USBD_StdEPReq+0x4e>
 1002d48:	2b00      	cmp	r3, #0
 1002d4a:	d02d      	beq.n	1002da8 <USBD_StdEPReq+0x70>
 1002d4c:	2b03      	cmp	r3, #3
 1002d4e:	d129      	bne.n	1002da4 <USBD_StdEPReq+0x6c>
        switch (pdev->dev.device_status)
 1002d50:	0003      	movs	r3, r0
 1002d52:	333a      	adds	r3, #58	; 0x3a
 1002d54:	781b      	ldrb	r3, [r3, #0]
 1002d56:	2b02      	cmp	r3, #2
 1002d58:	d041      	beq.n	1002dde <USBD_StdEPReq+0xa6>
 1002d5a:	2b03      	cmp	r3, #3
 1002d5c:	d004      	beq.n	1002d68 <USBD_StdEPReq+0x30>
    DCD_EP_Stall(pdev, 0);
 1002d5e:	2100      	movs	r1, #0
                DCD_EP_Stall(pdev, ep_addr);
 1002d60:	0020      	movs	r0, r4
 1002d62:	f7ff fc4f 	bl	1002604 <DCD_EP_Stall>
 1002d66:	e01d      	b.n	1002da4 <USBD_StdEPReq+0x6c>
            if (req->wValue == USB_FEATURE_EP_HALT)
 1002d68:	886b      	ldrh	r3, [r5, #2]
 1002d6a:	2b00      	cmp	r3, #0
 1002d6c:	d103      	bne.n	1002d76 <USBD_StdEPReq+0x3e>
                if ((ep_addr != 0x00) && (ep_addr != 0x80))
 1002d6e:	064b      	lsls	r3, r1, #25
 1002d70:	d001      	beq.n	1002d76 <USBD_StdEPReq+0x3e>
                    DCD_EP_Stall(pdev, ep_addr);
 1002d72:	f7ff fc47 	bl	1002604 <DCD_EP_Stall>
                    pdev->dev.class_cb->Setup(pdev, req);
 1002d76:	0023      	movs	r3, r4
 1002d78:	33fc      	adds	r3, #252	; 0xfc
 1002d7a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 1002d7c:	0029      	movs	r1, r5
 1002d7e:	689b      	ldr	r3, [r3, #8]
 1002d80:	0020      	movs	r0, r4
 1002d82:	4798      	blx	r3
 1002d84:	e00b      	b.n	1002d9e <USBD_StdEPReq+0x66>
        switch (pdev->dev.device_status)
 1002d86:	0003      	movs	r3, r0
 1002d88:	333a      	adds	r3, #58	; 0x3a
 1002d8a:	781b      	ldrb	r3, [r3, #0]
 1002d8c:	2b02      	cmp	r3, #2
 1002d8e:	d026      	beq.n	1002dde <USBD_StdEPReq+0xa6>
 1002d90:	2b03      	cmp	r3, #3
 1002d92:	d1e4      	bne.n	1002d5e <USBD_StdEPReq+0x26>
            if (req->wValue == USB_FEATURE_EP_HALT)
 1002d94:	886b      	ldrh	r3, [r5, #2]
 1002d96:	2b00      	cmp	r3, #0
 1002d98:	d104      	bne.n	1002da4 <USBD_StdEPReq+0x6c>
                if ((ep_addr != 0x00) && (ep_addr != 0x80))
 1002d9a:	064b      	lsls	r3, r1, #25
 1002d9c:	d1eb      	bne.n	1002d76 <USBD_StdEPReq+0x3e>
                USBD_CtlSendStatus(pdev);
 1002d9e:	0020      	movs	r0, r4
 1002da0:	f7ff fe80 	bl	1002aa4 <USBD_CtlSendStatus>
}
 1002da4:	2000      	movs	r0, #0
 1002da6:	bd70      	pop	{r4, r5, r6, pc}
        switch (pdev->dev.device_status)
 1002da8:	0003      	movs	r3, r0
 1002daa:	333a      	adds	r3, #58	; 0x3a
 1002dac:	781b      	ldrb	r3, [r3, #0]
 1002dae:	2b02      	cmp	r3, #2
 1002db0:	d015      	beq.n	1002dde <USBD_StdEPReq+0xa6>
 1002db2:	2b03      	cmp	r3, #3
 1002db4:	d1d3      	bne.n	1002d5e <USBD_StdEPReq+0x26>
 1002db6:	2324      	movs	r3, #36	; 0x24
 1002db8:	480d      	ldr	r0, [pc, #52]	; (1002df0 <USBD_StdEPReq+0xb8>)
            if ((ep_addr & 0x80) == 0x80)
 1002dba:	0612      	lsls	r2, r2, #24
 1002dbc:	d514      	bpl.n	1002de8 <USBD_StdEPReq+0xb0>
                if (pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 1002dbe:	227f      	movs	r2, #127	; 0x7f
 1002dc0:	4011      	ands	r1, r2
 1002dc2:	434b      	muls	r3, r1
 1002dc4:	18e3      	adds	r3, r4, r3
 1002dc6:	3346      	adds	r3, #70	; 0x46
 1002dc8:	781b      	ldrb	r3, [r3, #0]
 1002dca:	2b00      	cmp	r3, #0
 1002dcc:	d00a      	beq.n	1002de4 <USBD_StdEPReq+0xac>
                    USBD_ep_status = 0x0001;
 1002dce:	2301      	movs	r3, #1
                    USBD_ep_status = 0x0000;
 1002dd0:	6003      	str	r3, [r0, #0]
            USBD_CtlSendData(pdev,
 1002dd2:	0001      	movs	r1, r0
 1002dd4:	2202      	movs	r2, #2
 1002dd6:	0020      	movs	r0, r4
 1002dd8:	f7ff fe36 	bl	1002a48 <USBD_CtlSendData>
            break;
 1002ddc:	e7e2      	b.n	1002da4 <USBD_StdEPReq+0x6c>
            if ((ep_addr != 0x00) && (ep_addr != 0x80))
 1002dde:	064b      	lsls	r3, r1, #25
 1002de0:	d1be      	bne.n	1002d60 <USBD_StdEPReq+0x28>
 1002de2:	e7df      	b.n	1002da4 <USBD_StdEPReq+0x6c>
                    USBD_ep_status = 0x0000;
 1002de4:	2300      	movs	r3, #0
 1002de6:	e7f3      	b.n	1002dd0 <USBD_StdEPReq+0x98>
                if (pdev->dev.out_ep[ep_addr].is_stall)
 1002de8:	434b      	muls	r3, r1
 1002dea:	18e3      	adds	r3, r4, r3
 1002dec:	33d6      	adds	r3, #214	; 0xd6
 1002dee:	e7eb      	b.n	1002dc8 <USBD_StdEPReq+0x90>
 1002df0:	00020a54 	.word	0x00020a54

01002df4 <USBD_ParseSetupRequest>:
    req->bmRequest     = *(uint8_t *)(pdev->dev.setup_packet);
 1002df4:	23b2      	movs	r3, #178	; 0xb2
 1002df6:	005b      	lsls	r3, r3, #1
 1002df8:	5cc3      	ldrb	r3, [r0, r3]
 1002dfa:	700b      	strb	r3, [r1, #0]
    req->bRequest      = *(uint8_t *)(pdev->dev.setup_packet +  1);
 1002dfc:	2366      	movs	r3, #102	; 0x66
 1002dfe:	33ff      	adds	r3, #255	; 0xff
 1002e00:	5cc3      	ldrb	r3, [r0, r3]
 1002e02:	704b      	strb	r3, [r1, #1]
    req->wValue        = SWAPBYTE(pdev->dev.setup_packet +  2);
 1002e04:	2368      	movs	r3, #104	; 0x68
 1002e06:	33ff      	adds	r3, #255	; 0xff
 1002e08:	5cc2      	ldrb	r2, [r0, r3]
 1002e0a:	3b01      	subs	r3, #1
 1002e0c:	5cc3      	ldrb	r3, [r0, r3]
 1002e0e:	0212      	lsls	r2, r2, #8
 1002e10:	189b      	adds	r3, r3, r2
 1002e12:	804b      	strh	r3, [r1, #2]
    req->wIndex        = SWAPBYTE(pdev->dev.setup_packet +  4);
 1002e14:	236a      	movs	r3, #106	; 0x6a
 1002e16:	33ff      	adds	r3, #255	; 0xff
 1002e18:	5cc2      	ldrb	r2, [r0, r3]
 1002e1a:	3b01      	subs	r3, #1
 1002e1c:	5cc3      	ldrb	r3, [r0, r3]
 1002e1e:	0212      	lsls	r2, r2, #8
 1002e20:	189b      	adds	r3, r3, r2
 1002e22:	808b      	strh	r3, [r1, #4]
    req->wLength       = SWAPBYTE(pdev->dev.setup_packet +  6);
 1002e24:	236c      	movs	r3, #108	; 0x6c
 1002e26:	33ff      	adds	r3, #255	; 0xff
 1002e28:	5cc2      	ldrb	r2, [r0, r3]
 1002e2a:	3b01      	subs	r3, #1
 1002e2c:	5cc3      	ldrb	r3, [r0, r3]
 1002e2e:	0212      	lsls	r2, r2, #8
 1002e30:	189b      	adds	r3, r3, r2
    pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 1002e32:	0002      	movs	r2, r0
    req->wLength       = SWAPBYTE(pdev->dev.setup_packet +  6);
 1002e34:	b29b      	uxth	r3, r3
    pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 1002e36:	3264      	adds	r2, #100	; 0x64
    req->wLength       = SWAPBYTE(pdev->dev.setup_packet +  6);
 1002e38:	80cb      	strh	r3, [r1, #6]
    pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 1002e3a:	7013      	strb	r3, [r2, #0]
    pdev->dev.device_state = USB_OTG_EP0_SETUP;
 1002e3c:	2301      	movs	r3, #1
 1002e3e:	3039      	adds	r0, #57	; 0x39
 1002e40:	7003      	strb	r3, [r0, #0]
}
 1002e42:	4770      	bx	lr

01002e44 <USBD_CtlError>:
{
 1002e44:	b510      	push	{r4, lr}
    DCD_EP_Stall(pdev, 0);
 1002e46:	2100      	movs	r1, #0
 1002e48:	f7ff fbdc 	bl	1002604 <DCD_EP_Stall>
}
 1002e4c:	bd10      	pop	{r4, pc}

01002e4e <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 1002e4e:	2300      	movs	r3, #0
 1002e50:	b530      	push	{r4, r5, lr}
    uint8_t idx = 0;

    if (desc != NULL)
 1002e52:	4298      	cmp	r0, r3
 1002e54:	d101      	bne.n	1002e5a <USBD_GetString+0xc>
        {
            unicode[idx++] = *desc++;
            unicode[idx++] =  0x00;
        }
    }
}
 1002e56:	bd30      	pop	{r4, r5, pc}
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != 0)
 1002e58:	002b      	movs	r3, r5
 1002e5a:	5cc4      	ldrb	r4, [r0, r3]
 1002e5c:	1c5d      	adds	r5, r3, #1
 1002e5e:	2c00      	cmp	r4, #0
 1002e60:	d1fa      	bne.n	1002e58 <USBD_GetString+0xa>
        *len =  USBD_GetLen(desc) * 2 + 2;
 1002e62:	b2db      	uxtb	r3, r3
 1002e64:	3301      	adds	r3, #1
 1002e66:	005b      	lsls	r3, r3, #1
 1002e68:	8013      	strh	r3, [r2, #0]
        unicode[idx++] = *len;
 1002e6a:	700b      	strb	r3, [r1, #0]
        unicode[idx++] =  USB_DESC_TYPE_STRING;
 1002e6c:	2303      	movs	r3, #3
 1002e6e:	704b      	strb	r3, [r1, #1]
 1002e70:	3b01      	subs	r3, #1
        while (*desc != 0)
 1002e72:	7805      	ldrb	r5, [r0, #0]
 1002e74:	2d00      	cmp	r5, #0
 1002e76:	d0ee      	beq.n	1002e56 <USBD_GetString+0x8>
            unicode[idx++] = *desc++;
 1002e78:	1c5a      	adds	r2, r3, #1
 1002e7a:	54cd      	strb	r5, [r1, r3]
 1002e7c:	b2d2      	uxtb	r2, r2
            unicode[idx++] =  0x00;
 1002e7e:	3302      	adds	r3, #2
            unicode[idx++] = *desc++;
 1002e80:	3001      	adds	r0, #1
            unicode[idx++] =  0x00;
 1002e82:	b2db      	uxtb	r3, r3
 1002e84:	548c      	strb	r4, [r1, r2]
 1002e86:	e7f4      	b.n	1002e72 <USBD_GetString+0x24>

01002e88 <PC_to_RDR_IccPowerOn>:
    */
    const uint8_t au8ATR[] = { 0x3B, 0x60, 0x00, 0x00 };
    uint8_t index;
    uint8_t error;

    Ccid_bulkin_data.dwLength = 0;  /* Reset Number of Bytes in abData */
 1002e88:	2300      	movs	r3, #0
{
 1002e8a:	b570      	push	{r4, r5, r6, lr}
    Ccid_bulkin_data.dwLength = 0;  /* Reset Number of Bytes in abData */
 1002e8c:	4c0b      	ldr	r4, [pc, #44]	; (1002ebc <PC_to_RDR_IccPowerOn+0x34>)

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1002e8e:	2037      	movs	r0, #55	; 0x37
    Ccid_bulkin_data.dwLength = 0;  /* Reset Number of Bytes in abData */
 1002e90:	7063      	strb	r3, [r4, #1]
 1002e92:	70a3      	strb	r3, [r4, #2]
 1002e94:	70e3      	strb	r3, [r4, #3]
 1002e96:	7123      	strb	r3, [r4, #4]
    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1002e98:	f000 fa8a 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_DWLENGTH | \
                                    CHK_PARAM_abRFU2 | \
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_ABORT);
    if (error != 0)
 1002e9c:	2800      	cmp	r0, #0
 1002e9e:	d10c      	bne.n	1002eba <PC_to_RDR_IccPowerOn+0x32>
        return error;
    }


    /* ATR is received, No Error Condition Found */
    Ccid_bulkin_data.dwLength = sizeof(au8ATR);
 1002ea0:	2304      	movs	r3, #4
 1002ea2:	7063      	strb	r3, [r4, #1]
    CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);

    for (index = 0; index < sizeof(au8ATR); index++)
    {
        /* Copy the ATR to the Response Buffer */
        Ccid_bulkin_data.abData[index] = au8ATR[index];
 1002ea4:	3337      	adds	r3, #55	; 0x37
 1002ea6:	72a3      	strb	r3, [r4, #10]
 1002ea8:	3325      	adds	r3, #37	; 0x25
    Ccid_bulkin_data.dwLength = sizeof(au8ATR);
 1002eaa:	70a0      	strb	r0, [r4, #2]
 1002eac:	70e0      	strb	r0, [r4, #3]
 1002eae:	7120      	strb	r0, [r4, #4]
    CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 1002eb0:	71e0      	strb	r0, [r4, #7]
        Ccid_bulkin_data.abData[index] = au8ATR[index];
 1002eb2:	7320      	strb	r0, [r4, #12]
 1002eb4:	7360      	strb	r0, [r4, #13]
 1002eb6:	72e3      	strb	r3, [r4, #11]
    }

    return SLOT_NO_ERROR;
 1002eb8:	3081      	adds	r0, #129	; 0x81
}
 1002eba:	bd70      	pop	{r4, r5, r6, pc}
 1002ebc:	00021918 	.word	0x00021918

01002ec0 <PC_to_RDR_IccPowerOff>:
  *         Icc VCC is switched Off
  * @param  None
  * @retval uint8_t error: status of the command execution
  */
uint8_t PC_to_RDR_IccPowerOff(void)
{
 1002ec0:	b510      	push	{r4, lr}
    /*  The response to this command message is the RDR_to_PC_SlotStatus
    response message. */
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1002ec2:	200b      	movs	r0, #11
 1002ec4:	f000 fa74 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_abRFU3 | \
                                    CHK_PARAM_DWLENGTH);
    if (error != 0)
 1002ec8:	2800      	cmp	r0, #0
 1002eca:	d100      	bne.n	1002ece <PC_to_RDR_IccPowerOff+0xe>
    {
        return error;
    }
    /* Command is ok, Check for Card Presence */

    return SLOT_NO_ERROR;
 1002ecc:	3081      	adds	r0, #129	; 0x81
}
 1002ece:	bd10      	pop	{r4, pc}

01002ed0 <PC_to_RDR_GetSlotStatus>:
  *         Provides the Slot status to the host
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_GetSlotStatus(void)
{
 1002ed0:	b510      	push	{r4, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1002ed2:	201b      	movs	r0, #27
 1002ed4:	f000 fa6c 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_DWLENGTH | \
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU3);
    if (error != 0)
 1002ed8:	2800      	cmp	r0, #0
 1002eda:	d102      	bne.n	1002ee2 <PC_to_RDR_GetSlotStatus+0x12>
    {
        return error;
    }

    CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 1002edc:	4b01      	ldr	r3, [pc, #4]	; (1002ee4 <PC_to_RDR_GetSlotStatus+0x14>)
 1002ede:	71d8      	strb	r0, [r3, #7]
    return SLOT_NO_ERROR;
 1002ee0:	3081      	adds	r0, #129	; 0x81
}
 1002ee2:	bd10      	pop	{r4, pc}
 1002ee4:	00021918 	.word	0x00021918

01002ee8 <resp_CCID_CMD>:


uint32_t resp_CCID_CMD(USB_OTG_CORE_HANDLE *pdev)
{
 1002ee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1002eea:	1e05      	subs	r5, r0, #0
    uint8_t error = 0;
    uint16_t expectedLength;
    uint32_t u32Next;

    if (NULL == pdev)
 1002eec:	d04c      	beq.n	1002f88 <resp_CCID_CMD+0xa0>
    {
        return -2;
    }
    if (Q_EMPTY(gu32RecvHead, gu32RecvTail, CCID_RECV_Q_SIZE))
 1002eee:	4b29      	ldr	r3, [pc, #164]	; (1002f94 <resp_CCID_CMD+0xac>)
 1002ef0:	210a      	movs	r1, #10
 1002ef2:	681c      	ldr	r4, [r3, #0]
 1002ef4:	0020      	movs	r0, r4
 1002ef6:	f001 f89f 	bl	1004038 <__aeabi_uidivmod>
 1002efa:	4b27      	ldr	r3, [pc, #156]	; (1002f98 <resp_CCID_CMD+0xb0>)
 1002efc:	000f      	movs	r7, r1
 1002efe:	6818      	ldr	r0, [r3, #0]
 1002f00:	210a      	movs	r1, #10
 1002f02:	f001 f899 	bl	1004038 <__aeabi_uidivmod>
 1002f06:	428f      	cmp	r7, r1
 1002f08:	d041      	beq.n	1002f8e <resp_CCID_CMD+0xa6>
    {
        return -1;
    }
    u32Next = Q_NEXT(gu32RecvHead, CCID_RECV_Q_SIZE);
 1002f0a:	1c60      	adds	r0, r4, #1
 1002f0c:	210a      	movs	r1, #10
 1002f0e:	f001 f893 	bl	1004038 <__aeabi_uidivmod>

    expectedLength = (Ccid_out_cmd[u32Next].bSpecific_2 << 8) | Ccid_out_cmd[u32Next].bSpecific_1;
 1002f12:	2010      	movs	r0, #16
 1002f14:	30ff      	adds	r0, #255	; 0xff
 1002f16:	4348      	muls	r0, r1
 1002f18:	4b20      	ldr	r3, [pc, #128]	; (1002f9c <resp_CCID_CMD+0xb4>)
    u32Next = Q_NEXT(gu32RecvHead, CCID_RECV_Q_SIZE);
 1002f1a:	000f      	movs	r7, r1
    expectedLength = (Ccid_out_cmd[u32Next].bSpecific_2 << 8) | Ccid_out_cmd[u32Next].bSpecific_1;
 1002f1c:	181b      	adds	r3, r3, r0
 1002f1e:	7a5a      	ldrb	r2, [r3, #9]
 1002f20:	7a19      	ldrb	r1, [r3, #8]
 1002f22:	0212      	lsls	r2, r2, #8
 1002f24:	430a      	orrs	r2, r1

    Ccid_bulkin_data.dwLength = (uint16_t)expectedLength;
 1002f26:	4c1e      	ldr	r4, [pc, #120]	; (1002fa0 <resp_CCID_CMD+0xb8>)
 1002f28:	0a16      	lsrs	r6, r2, #8
 1002f2a:	70a6      	strb	r6, [r4, #2]
 1002f2c:	2600      	movs	r6, #0
 1002f2e:	70e6      	strb	r6, [r4, #3]
 1002f30:	0e16      	lsrs	r6, r2, #24
 1002f32:	7126      	strb	r6, [r4, #4]
 1002f34:	7062      	strb	r2, [r4, #1]

    error = SC_XferBlock(&Ccid_out_cmd[u32Next].abData[0], Ccid_out_cmd[u32Next].dwLength, expectedLength);
 1002f36:	7859      	ldrb	r1, [r3, #1]
 1002f38:	300a      	adds	r0, #10
 1002f3a:	468c      	mov	ip, r1
 1002f3c:	4666      	mov	r6, ip
 1002f3e:	7899      	ldrb	r1, [r3, #2]
 1002f40:	0209      	lsls	r1, r1, #8
 1002f42:	430e      	orrs	r6, r1
 1002f44:	78d9      	ldrb	r1, [r3, #3]
 1002f46:	791b      	ldrb	r3, [r3, #4]
 1002f48:	0409      	lsls	r1, r1, #16
 1002f4a:	061b      	lsls	r3, r3, #24
 1002f4c:	4331      	orrs	r1, r6
 1002f4e:	4319      	orrs	r1, r3
 1002f50:	4b12      	ldr	r3, [pc, #72]	; (1002f9c <resp_CCID_CMD+0xb4>)
 1002f52:	18c0      	adds	r0, r0, r3
 1002f54:	f000 fe54 	bl	1003c00 <SC_XferBlock>

    gu32RecvHead = u32Next;
 1002f58:	4b0e      	ldr	r3, [pc, #56]	; (1002f94 <resp_CCID_CMD+0xac>)
 1002f5a:	601f      	str	r7, [r3, #0]
    if (error != SLOT_NO_ERROR)
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1002f5c:	2340      	movs	r3, #64	; 0x40
    if (error != SLOT_NO_ERROR)
 1002f5e:	2881      	cmp	r0, #129	; 0x81
 1002f60:	d100      	bne.n	1002f64 <resp_CCID_CMD+0x7c>
    }
    else
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 1002f62:	2300      	movs	r3, #0
 1002f64:	71e3      	strb	r3, [r4, #7]
        error = SLOT_NO_ERROR;
    }
    RDR_to_PC_DataBlock(error);
 1002f66:	f000 f98b 	bl	1003280 <RDR_to_PC_DataBlock>
    DCD_EP_Tx(pdev, CCID_BULK_IN_EP, (uint8_t *)&Ccid_bulkin_data, Ccid_bulkin_data.u16SizeToSend);
 1002f6a:	0022      	movs	r2, r4
 1002f6c:	32ff      	adds	r2, #255	; 0xff
 1002f6e:	7c53      	ldrb	r3, [r2, #17]
 1002f70:	7c11      	ldrb	r1, [r2, #16]
 1002f72:	021b      	lsls	r3, r3, #8
 1002f74:	430b      	orrs	r3, r1
 1002f76:	0022      	movs	r2, r4
 1002f78:	2181      	movs	r1, #129	; 0x81
 1002f7a:	0028      	movs	r0, r5
 1002f7c:	f7ff fb26 	bl	10025cc <DCD_EP_Tx>
    Ccid_BulkState = CCID_STATE_IDLE;
 1002f80:	2000      	movs	r0, #0
 1002f82:	4b08      	ldr	r3, [pc, #32]	; (1002fa4 <resp_CCID_CMD+0xbc>)
 1002f84:	7018      	strb	r0, [r3, #0]
    return 0;
}
 1002f86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return -2;
 1002f88:	2002      	movs	r0, #2
        return -1;
 1002f8a:	4240      	negs	r0, r0
 1002f8c:	e7fb      	b.n	1002f86 <resp_CCID_CMD+0x9e>
 1002f8e:	2001      	movs	r0, #1
 1002f90:	e7fb      	b.n	1002f8a <resp_CCID_CMD+0xa2>
 1002f92:	46c0      	nop			; (mov r8, r8)
 1002f94:	00020a64 	.word	0x00020a64
 1002f98:	00020a68 	.word	0x00020a68
 1002f9c:	00020af4 	.word	0x00020af4
 1002fa0:	00021918 	.word	0x00021918
 1002fa4:	00021a2b 	.word	0x00021a2b

01002fa8 <PC_to_RDR_XfrBlock>:
  *         Response to this command message is the RDR_to_PC_DataBlock
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_XfrBlock(void)
{
 1002fa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    //uint16_t expectedLength;

    uint8_t error = 0;
    uint32_t u32Next;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1002faa:	2079      	movs	r0, #121	; 0x79
 1002fac:	f000 fa00 	bl	10033b0 <CCID_CheckCommandParams>
 1002fb0:	1e05      	subs	r5, r0, #0
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU3 | \
                                    CHK_PARAM_ABORT | \
                                    CHK_ACTIVE_STATE);

    if (error != 0) return error;
 1002fb2:	d129      	bne.n	1003008 <PC_to_RDR_XfrBlock+0x60>

    if (Ccid_bulkout_data.dwLength > ABDATA_SIZE)
 1002fb4:	4c17      	ldr	r4, [pc, #92]	; (1003014 <PC_to_RDR_XfrBlock+0x6c>)
 1002fb6:	78a2      	ldrb	r2, [r4, #2]
 1002fb8:	7863      	ldrb	r3, [r4, #1]
 1002fba:	0212      	lsls	r2, r2, #8
 1002fbc:	431a      	orrs	r2, r3
 1002fbe:	78e3      	ldrb	r3, [r4, #3]
 1002fc0:	041b      	lsls	r3, r3, #16
 1002fc2:	431a      	orrs	r2, r3
 1002fc4:	7923      	ldrb	r3, [r4, #4]
 1002fc6:	061b      	lsls	r3, r3, #24
 1002fc8:	4313      	orrs	r3, r2
 1002fca:	2206      	movs	r2, #6
 1002fcc:	32ff      	adds	r2, #255	; 0xff
 1002fce:	4293      	cmp	r3, r2
 1002fd0:	d81e      	bhi.n	1003010 <PC_to_RDR_XfrBlock+0x68>
    /*
    error = SC_XferBlock(&Ccid_bulkout_data.abData[0],
                         Ccid_bulkout_data.dwLength,
                         expectedLength);
    */
    if (!Q_IS_FULL(gu32RecvHead, gu32RecvTail, CCID_RECV_Q_SIZE))
 1002fd2:	4f11      	ldr	r7, [pc, #68]	; (1003018 <PC_to_RDR_XfrBlock+0x70>)
 1002fd4:	210a      	movs	r1, #10
 1002fd6:	683b      	ldr	r3, [r7, #0]
 1002fd8:	1c58      	adds	r0, r3, #1
 1002fda:	f001 f82d 	bl	1004038 <__aeabi_uidivmod>
 1002fde:	4b0f      	ldr	r3, [pc, #60]	; (100301c <PC_to_RDR_XfrBlock+0x74>)
 1002fe0:	000e      	movs	r6, r1
 1002fe2:	6818      	ldr	r0, [r3, #0]
 1002fe4:	210a      	movs	r1, #10
 1002fe6:	f001 f827 	bl	1004038 <__aeabi_uidivmod>
 1002fea:	428e      	cmp	r6, r1
 1002fec:	d00e      	beq.n	100300c <PC_to_RDR_XfrBlock+0x64>
    {
        u32Next = Q_NEXT(gu32RecvTail, CCID_RECV_Q_SIZE);

        memcpy((char *)(Ccid_out_cmd + u32Next), (char *)(&Ccid_bulkout_data), (int)sizeof(Ccid_bulkout_data_t));
 1002fee:	2210      	movs	r2, #16
 1002ff0:	32ff      	adds	r2, #255	; 0xff
 1002ff2:	0010      	movs	r0, r2
 1002ff4:	4370      	muls	r0, r6
 1002ff6:	4b0a      	ldr	r3, [pc, #40]	; (1003020 <PC_to_RDR_XfrBlock+0x78>)
 1002ff8:	0021      	movs	r1, r4
 1002ffa:	18c0      	adds	r0, r0, r3
 1002ffc:	f000 fef0 	bl	1003de0 <memcpy>
        gu32RecvTail = u32Next;
 1003000:	603e      	str	r6, [r7, #0]
        error = SLOTERROR_BAD_DWLENGTH;
    }

    if (error != SLOT_NO_ERROR)
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003002:	2240      	movs	r2, #64	; 0x40
 1003004:	4b07      	ldr	r3, [pc, #28]	; (1003024 <PC_to_RDR_XfrBlock+0x7c>)
 1003006:	71da      	strb	r2, [r3, #7]
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
        error = SLOT_NO_ERROR;
    }

    return error;
}
 1003008:	0028      	movs	r0, r5
 100300a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        error = SLOTERROR_BAD_DWLENGTH;
 100300c:	2508      	movs	r5, #8
 100300e:	e7f8      	b.n	1003002 <PC_to_RDR_XfrBlock+0x5a>
        return SLOTERROR_BAD_DWLENGTH;
 1003010:	2508      	movs	r5, #8
 1003012:	e7f9      	b.n	1003008 <PC_to_RDR_XfrBlock+0x60>
 1003014:	00021808 	.word	0x00021808
 1003018:	00020a68 	.word	0x00020a68
 100301c:	00020a64 	.word	0x00020a64
 1003020:	00020af4 	.word	0x00020af4
 1003024:	00021918 	.word	0x00021918

01003028 <PC_to_RDR_GetParameters>:
 1003028:	b510      	push	{r4, lr}
 100302a:	f7ff ff51 	bl	1002ed0 <PC_to_RDR_GetSlotStatus>
 100302e:	bd10      	pop	{r4, pc}

01003030 <PC_to_RDR_ResetParameters>:
  *         Response to this command message is the RDR_to_PC_Parameters
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_ResetParameters(void)
{
 1003030:	b510      	push	{r4, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1003032:	205b      	movs	r0, #91	; 0x5b
 1003034:	f000 f9bc 	bl	10033b0 <CCID_CheckCommandParams>
 1003038:	1e04      	subs	r4, r0, #0
                                    CHK_PARAM_DWLENGTH | \
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU3 | \
                                    CHK_ACTIVE_STATE);
    if (error != 0) return error;
 100303a:	d111      	bne.n	1003060 <PC_to_RDR_ResetParameters+0x30>

    /* This command resets the slot parameters to their default values */
    Ccid_bulkout_data.abData[0] = DEFAULT_FIDI;
 100303c:	2211      	movs	r2, #17
 100303e:	4b0a      	ldr	r3, [pc, #40]	; (1003068 <PC_to_RDR_ResetParameters+0x38>)
 1003040:	729a      	strb	r2, [r3, #10]
    Ccid_bulkout_data.abData[1] = DEFAULT_T01CONVCHECKSUM;
 1003042:	72d8      	strb	r0, [r3, #11]
    Ccid_bulkout_data.abData[2] = DEFAULT_EXTRA_GUARDTIME;
 1003044:	7318      	strb	r0, [r3, #12]
    Ccid_bulkout_data.abData[3] = DEFAULT_WAITINGINTEGER;
    Ccid_bulkout_data.abData[4] = DEFAULT_CLOCKSTOP;
 1003046:	7398      	strb	r0, [r3, #14]
    Ccid_bulkout_data.abData[5] = 0x00;
 1003048:	73d8      	strb	r0, [r3, #15]
    Ccid_bulkout_data.abData[6] = 0x00;
 100304a:	7418      	strb	r0, [r3, #16]
    Ccid_bulkout_data.abData[3] = DEFAULT_WAITINGINTEGER;
 100304c:	3a07      	subs	r2, #7

    error = SC_SetParams((Protocol0_DataStructure_t *)(&(Ccid_bulkout_data.abData[0])));
 100304e:	4807      	ldr	r0, [pc, #28]	; (100306c <PC_to_RDR_ResetParameters+0x3c>)
    Ccid_bulkout_data.abData[3] = DEFAULT_WAITINGINTEGER;
 1003050:	735a      	strb	r2, [r3, #13]
    error = SC_SetParams((Protocol0_DataStructure_t *)(&(Ccid_bulkout_data.abData[0])));
 1003052:	f000 fdb3 	bl	1003bbc <SC_SetParams>
 1003056:	4b06      	ldr	r3, [pc, #24]	; (1003070 <PC_to_RDR_ResetParameters+0x40>)

    if (error != SLOT_NO_ERROR)
 1003058:	2881      	cmp	r0, #129	; 0x81
 100305a:	d002      	beq.n	1003062 <PC_to_RDR_ResetParameters+0x32>
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 100305c:	2240      	movs	r2, #64	; 0x40
 100305e:	71da      	strb	r2, [r3, #7]
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
        error = SLOT_NO_ERROR;
    }

    return error;
}
 1003060:	bd10      	pop	{r4, pc}
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 1003062:	71dc      	strb	r4, [r3, #7]
 1003064:	e7fc      	b.n	1003060 <PC_to_RDR_ResetParameters+0x30>
 1003066:	46c0      	nop			; (mov r8, r8)
 1003068:	00021808 	.word	0x00021808
 100306c:	00021812 	.word	0x00021812
 1003070:	00021918 	.word	0x00021918

01003074 <PC_to_RDR_SetParameters>:
  *         Response to this command message is the RDR_to_PC_Parameters
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_SetParameters(void)
{
 1003074:	b510      	push	{r4, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1003076:	2055      	movs	r0, #85	; 0x55
 1003078:	f000 f99a 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU2 | \
                                    CHK_ACTIVE_STATE);
    if (error != 0) return error;
 100307c:	2800      	cmp	r0, #0
 100307e:	d125      	bne.n	10030cc <PC_to_RDR_SetParameters+0x58>

    error = SLOT_NO_ERROR;

    /* for Protocol T=0 (bProtocolNum=0) (dwLength=00000005h) */
    if ((Ccid_bulkout_data.dwLength == 5) &&
 1003080:	4b16      	ldr	r3, [pc, #88]	; (10030dc <PC_to_RDR_SetParameters+0x68>)
 1003082:	7899      	ldrb	r1, [r3, #2]
 1003084:	785a      	ldrb	r2, [r3, #1]
 1003086:	0209      	lsls	r1, r1, #8
 1003088:	4311      	orrs	r1, r2
 100308a:	78da      	ldrb	r2, [r3, #3]
 100308c:	0412      	lsls	r2, r2, #16
 100308e:	4311      	orrs	r1, r2
 1003090:	791a      	ldrb	r2, [r3, #4]
 1003092:	0612      	lsls	r2, r2, #24
 1003094:	430a      	orrs	r2, r1
 1003096:	2a05      	cmp	r2, #5
 1003098:	d119      	bne.n	10030ce <PC_to_RDR_SetParameters+0x5a>
 100309a:	79da      	ldrb	r2, [r3, #7]
    error = SLOT_NO_ERROR;
 100309c:	3081      	adds	r0, #129	; 0x81
    if ((Ccid_bulkout_data.dwLength == 5) &&
 100309e:	2a00      	cmp	r2, #0
 10030a0:	d000      	beq.n	10030a4 <PC_to_RDR_SetParameters+0x30>
            (Ccid_bulkout_data.bSpecific_0 != 0)) error = SLOTERROR_BAD_PROTOCOLNUM;
 10030a2:	387a      	subs	r0, #122	; 0x7a
    /* for Protocol T=1 (bProtocolNum=1) (dwLength=00000007h) */
    if ((Ccid_bulkout_data.dwLength == 7) &&
            (Ccid_bulkout_data.bSpecific_0 != 1)) error = SLOTERROR_CMD_NOT_SUPPORTED;

    /* For T0, Waiting Integer 0 supported */
    if (Ccid_bulkout_data.abData[3] != 0) error = SLOTERROR_BAD_WAITINGINTEGER;
 10030a4:	7b5a      	ldrb	r2, [r3, #13]
 10030a6:	2a00      	cmp	r2, #0
 10030a8:	d000      	beq.n	10030ac <PC_to_RDR_SetParameters+0x38>
 10030aa:	200d      	movs	r0, #13

    if (Ccid_bulkout_data.abData[4] != DEFAULT_CLOCKSTOP) error = SLOTERROR_BAD_CLOCKSTOP;
 10030ac:	7b9b      	ldrb	r3, [r3, #14]
 10030ae:	4c0c      	ldr	r4, [pc, #48]	; (10030e0 <PC_to_RDR_SetParameters+0x6c>)
 10030b0:	2b00      	cmp	r3, #0
 10030b2:	d101      	bne.n	10030b8 <PC_to_RDR_SetParameters+0x44>

    if (error != SLOT_NO_ERROR)
 10030b4:	2881      	cmp	r0, #129	; 0x81
 10030b6:	d001      	beq.n	10030bc <PC_to_RDR_SetParameters+0x48>
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 10030b8:	2340      	movs	r3, #64	; 0x40
 10030ba:	71e3      	strb	r3, [r4, #7]
    }

    error = SC_SetParams((Protocol0_DataStructure_t *)(&(Ccid_bulkout_data.abData[0])));
 10030bc:	4809      	ldr	r0, [pc, #36]	; (10030e4 <PC_to_RDR_SetParameters+0x70>)
 10030be:	f000 fd7d 	bl	1003bbc <SC_SetParams>

    if (error != SLOT_NO_ERROR)
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 10030c2:	2340      	movs	r3, #64	; 0x40
    if (error != SLOT_NO_ERROR)
 10030c4:	2881      	cmp	r0, #129	; 0x81
 10030c6:	d100      	bne.n	10030ca <PC_to_RDR_SetParameters+0x56>
    }
    else
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 10030c8:	2300      	movs	r3, #0
 10030ca:	71e3      	strb	r3, [r4, #7]
        error = SLOT_NO_ERROR;
    }

    return error;
}
 10030cc:	bd10      	pop	{r4, pc}
    if ((Ccid_bulkout_data.dwLength == 7) &&
 10030ce:	2a07      	cmp	r2, #7
 10030d0:	d102      	bne.n	10030d8 <PC_to_RDR_SetParameters+0x64>
 10030d2:	79da      	ldrb	r2, [r3, #7]
 10030d4:	2a01      	cmp	r2, #1
 10030d6:	d1e5      	bne.n	10030a4 <PC_to_RDR_SetParameters+0x30>
    error = SLOT_NO_ERROR;
 10030d8:	2081      	movs	r0, #129	; 0x81
 10030da:	e7e3      	b.n	10030a4 <PC_to_RDR_SetParameters+0x30>
 10030dc:	00021808 	.word	0x00021808
 10030e0:	00021918 	.word	0x00021918
 10030e4:	00021812 	.word	0x00021812

010030e8 <PC_to_RDR_Escape>:
  *         Response to this command message is the RDR_to_PC_Escape
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_Escape(void)
{
 10030e8:	b510      	push	{r4, lr}
    uint8_t error;
    uint16_t size;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 10030ea:	2079      	movs	r0, #121	; 0x79
 10030ec:	f000 f960 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU3 | \
                                    CHK_PARAM_ABORT | \
                                    CHK_ACTIVE_STATE);

    if (error != 0) return error;
 10030f0:	2800      	cmp	r0, #0
 10030f2:	d10a      	bne.n	100310a <PC_to_RDR_Escape+0x22>
                             Ccid_bulkout_data.dwLength,
                             &Ccid_bulkin_data.abData[0],
                             &size);
    */

    Ccid_bulkin_data.dwLength = size;
 10030f4:	2300      	movs	r3, #0
 10030f6:	24ff      	movs	r4, #255	; 0xff
 10030f8:	4a04      	ldr	r2, [pc, #16]	; (100310c <PC_to_RDR_Escape+0x24>)
 10030fa:	401c      	ands	r4, r3
 10030fc:	7093      	strb	r3, [r2, #2]
 10030fe:	70d3      	strb	r3, [r2, #3]
 1003100:	0e1b      	lsrs	r3, r3, #24
 1003102:	7113      	strb	r3, [r2, #4]

    if (error != SLOT_NO_ERROR)
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003104:	2340      	movs	r3, #64	; 0x40
    Ccid_bulkin_data.dwLength = size;
 1003106:	7054      	strb	r4, [r2, #1]
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003108:	71d3      	strb	r3, [r2, #7]
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
    }

    return error;
}
 100310a:	bd10      	pop	{r4, pc}
 100310c:	00021918 	.word	0x00021918

01003110 <PC_to_RDR_IccClock>:
  *         Response to this command message is the RDR_to_PC_SlotStatus
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_IccClock(void)
{
 1003110:	b570      	push	{r4, r5, r6, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1003112:	2057      	movs	r0, #87	; 0x57
 1003114:	f000 f94c 	bl	10033b0 <CCID_CheckCommandParams>
 1003118:	1e05      	subs	r5, r0, #0
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU2 | \
                                    CHK_PARAM_DWLENGTH | \
                                    CHK_ACTIVE_STATE);
    if (error != 0) return error;
 100311a:	d107      	bne.n	100312c <PC_to_RDR_IccClock+0x1c>

    /* bClockCommand  00h restarts Clock
                      01h Stops Clock in the state shown in the bClockStop
                         field of the PC_to_RDR_SetParameters command
                         and RDR_to_PC_Parameters message.*/
    if (Ccid_bulkout_data.bSpecific_0 > 1)
 100311c:	4b08      	ldr	r3, [pc, #32]	; (1003140 <PC_to_RDR_IccClock+0x30>)
 100311e:	4c09      	ldr	r4, [pc, #36]	; (1003144 <PC_to_RDR_IccClock+0x34>)
 1003120:	79d8      	ldrb	r0, [r3, #7]
 1003122:	2801      	cmp	r0, #1
 1003124:	d903      	bls.n	100312e <PC_to_RDR_IccClock+0x1e>
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003126:	2340      	movs	r3, #64	; 0x40
        return SLOTERROR_BAD_CLOCKCOMMAND;
 1003128:	2007      	movs	r0, #7
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 100312a:	71e3      	strb	r3, [r4, #7]
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
    }

    return error;
}
 100312c:	bd70      	pop	{r4, r5, r6, pc}
    error = SC_SetClock(Ccid_bulkout_data.bSpecific_0);
 100312e:	f000 fd3b 	bl	1003ba8 <SC_SetClock>
    if (error != SLOT_NO_ERROR)
 1003132:	2881      	cmp	r0, #129	; 0x81
 1003134:	d002      	beq.n	100313c <PC_to_RDR_IccClock+0x2c>
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003136:	2340      	movs	r3, #64	; 0x40
 1003138:	71e3      	strb	r3, [r4, #7]
 100313a:	e7f7      	b.n	100312c <PC_to_RDR_IccClock+0x1c>
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 100313c:	71e5      	strb	r5, [r4, #7]
 100313e:	e7f5      	b.n	100312c <PC_to_RDR_IccClock+0x1c>
 1003140:	00021808 	.word	0x00021808
 1003144:	00021918 	.word	0x00021918

01003148 <PC_to_RDR_Abort>:
  *         Response to this command message is the RDR_to_PC_SlotStatus
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_to_RDR_Abort(void)
{
 1003148:	b510      	push	{r4, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 100314a:	200b      	movs	r0, #11
 100314c:	f000 f930 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_abRFU3 | \
                                    CHK_PARAM_DWLENGTH);
    if (error != 0) return error;
 1003150:	2800      	cmp	r0, #0
 1003152:	d102      	bne.n	100315a <PC_to_RDR_Abort+0x12>

    //CCID_CmdAbort(Ccid_bulkout_data.bSlot, Ccid_bulkout_data.bSeq);
    CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
 1003154:	4b01      	ldr	r3, [pc, #4]	; (100315c <PC_to_RDR_Abort+0x14>)
 1003156:	71d8      	strb	r0, [r3, #7]
    return SLOT_NO_ERROR;
 1003158:	3081      	adds	r0, #129	; 0x81
}
 100315a:	bd10      	pop	{r4, pc}
 100315c:	00021918 	.word	0x00021918

01003160 <CCID_CmdAbort>:
  */
uint8_t CCID_CmdAbort(uint8_t slot, uint8_t seq)
{
    /* This function is called for REQUEST_ABORT & PC_to_RDR_Abort */

    if (slot >= CCID_NUMBER_OF_SLOTS)
 1003160:	2800      	cmp	r0, #0
 1003162:	d004      	beq.n	100316e <CCID_CmdAbort+0xe>
    {
        /* This error condition is possible only from CLASS_REQUEST, otherwise
        Slot is already checked in parameters from PC_to_RDR_Abort request */
        /* Slot requested is more than supported by Firmware */
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_NO_ICC_PRESENT);
 1003164:	2242      	movs	r2, #66	; 0x42
        return SLOTERROR_BAD_SLOT;
 1003166:	2005      	movs	r0, #5
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_NO_ICC_PRESENT);
 1003168:	4b09      	ldr	r3, [pc, #36]	; (1003190 <CCID_CmdAbort+0x30>)
 100316a:	71da      	strb	r2, [r3, #7]
        usb_ccid_param.bSeq = seq;
        usb_ccid_param.bSlot = slot;
    }

    return 0;
}
 100316c:	4770      	bx	lr
    if (usb_ccid_param.bAbortRequestFlag == 1)
 100316e:	4b09      	ldr	r3, [pc, #36]	; (1003194 <CCID_CmdAbort+0x34>)
 1003170:	781a      	ldrb	r2, [r3, #0]
 1003172:	2a01      	cmp	r2, #1
 1003174:	d107      	bne.n	1003186 <CCID_CmdAbort+0x26>
        if ((usb_ccid_param.bSeq == seq) && (usb_ccid_param.bSlot == slot))
 1003176:	785a      	ldrb	r2, [r3, #1]
 1003178:	428a      	cmp	r2, r1
 100317a:	d1f7      	bne.n	100316c <CCID_CmdAbort+0xc>
 100317c:	789a      	ldrb	r2, [r3, #2]
 100317e:	2a00      	cmp	r2, #0
 1003180:	d1f4      	bne.n	100316c <CCID_CmdAbort+0xc>
            usb_ccid_param.bAbortRequestFlag = 0;
 1003182:	7018      	strb	r0, [r3, #0]
 1003184:	e7f2      	b.n	100316c <CCID_CmdAbort+0xc>
        usb_ccid_param.bAbortRequestFlag = 1;
 1003186:	2201      	movs	r2, #1
 1003188:	701a      	strb	r2, [r3, #0]
        usb_ccid_param.bSeq = seq;
 100318a:	7059      	strb	r1, [r3, #1]
        usb_ccid_param.bSlot = slot;
 100318c:	7098      	strb	r0, [r3, #2]
 100318e:	e7ed      	b.n	100316c <CCID_CmdAbort+0xc>
 1003190:	00021918 	.word	0x00021918
 1003194:	000216a4 	.word	0x000216a4

01003198 <PC_TO_RDR_T0Apdu>:
  *         Response to this command message is the RDR_to_PC_SlotStatus
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_TO_RDR_T0Apdu(void)
{
 1003198:	b510      	push	{r4, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 100319a:	2033      	movs	r0, #51	; 0x33
 100319c:	f000 f908 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_DWLENGTH |
                                    CHK_PARAM_ABORT);
    if (error != 0) return error;
 10031a0:	2800      	cmp	r0, #0
 10031a2:	d107      	bne.n	10031b4 <PC_TO_RDR_T0Apdu+0x1c>
 10031a4:	2240      	movs	r2, #64	; 0x40

    if (Ccid_bulkout_data.bSpecific_0 > 0x03)
 10031a6:	4b04      	ldr	r3, [pc, #16]	; (10031b8 <PC_TO_RDR_T0Apdu+0x20>)
 10031a8:	79d9      	ldrb	r1, [r3, #7]
 10031aa:	4b04      	ldr	r3, [pc, #16]	; (10031bc <PC_TO_RDR_T0Apdu+0x24>)
    {
        /* Bit 0 is associated with field bClassGetResponse
           Bit 1 is associated with field bClassEnvelope
           Other bits are RFU.*/

        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 10031ac:	71da      	strb	r2, [r3, #7]
    if (Ccid_bulkout_data.bSpecific_0 > 0x03)
 10031ae:	2903      	cmp	r1, #3
 10031b0:	d900      	bls.n	10031b4 <PC_TO_RDR_T0Apdu+0x1c>
        return SLOTERROR_BAD_BMCHANGES;
 10031b2:	3007      	adds	r0, #7
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
    }

    return error;
}
 10031b4:	bd10      	pop	{r4, pc}
 10031b6:	46c0      	nop			; (mov r8, r8)
 10031b8:	00021808 	.word	0x00021808
 10031bc:	00021918 	.word	0x00021918

010031c0 <PC_TO_RDR_Mechanical>:
  *         Response to this command message is the RDR_to_PC_SlotStatus
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_TO_RDR_Mechanical(void)
{
 10031c0:	b510      	push	{r4, lr}
    uint8_t error;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 10031c2:	2017      	movs	r0, #23
 10031c4:	f000 f8f4 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU2 | \
                                    CHK_PARAM_DWLENGTH
                                   );
    if (error != 0) return error;
 10031c8:	2800      	cmp	r0, #0
 10031ca:	d107      	bne.n	10031dc <PC_TO_RDR_Mechanical+0x1c>
 10031cc:	2240      	movs	r2, #64	; 0x40

    if (Ccid_bulkout_data.bSpecific_0 > 0x05)
 10031ce:	4b04      	ldr	r3, [pc, #16]	; (10031e0 <PC_TO_RDR_Mechanical+0x20>)
 10031d0:	79d9      	ldrb	r1, [r3, #7]
 10031d2:	4b04      	ldr	r3, [pc, #16]	; (10031e4 <PC_TO_RDR_Mechanical+0x24>)
           02h  Eject Card
           03h  Capture Card
           04h  Lock Card
           05h  Unlock Card*/

        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 10031d4:	71da      	strb	r2, [r3, #7]
    if (Ccid_bulkout_data.bSpecific_0 > 0x05)
 10031d6:	2905      	cmp	r1, #5
 10031d8:	d900      	bls.n	10031dc <PC_TO_RDR_Mechanical+0x1c>
        return SLOTERROR_BAD_BFUNCTION_MECHANICAL;
 10031da:	3007      	adds	r0, #7
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
    }

    return error;
}
 10031dc:	bd10      	pop	{r4, pc}
 10031de:	46c0      	nop			; (mov r8, r8)
 10031e0:	00021808 	.word	0x00021808
 10031e4:	00021918 	.word	0x00021918

010031e8 <PC_TO_RDR_SetDataRateAndClockFrequency>:
  *           RDR_to_PC_DataRateAndClockFrequency
  * @param  None
  * @retval uint8_t status of the command execution
  */
uint8_t PC_TO_RDR_SetDataRateAndClockFrequency(void)
{
 10031e8:	b510      	push	{r4, lr}
    uint8_t error;
    uint32_t clockFrequency;
    uint32_t dataRate;
    uint32_t temp = 0;

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 10031ea:	2019      	movs	r0, #25
 10031ec:	f000 f8e0 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_abRFU3);
    if (error != 0) return error;
 10031f0:	2800      	cmp	r0, #0
 10031f2:	d110      	bne.n	1003216 <PC_TO_RDR_SetDataRateAndClockFrequency+0x2e>

    if (Ccid_bulkout_data.dwLength != 0x08)
 10031f4:	490c      	ldr	r1, [pc, #48]	; (1003228 <PC_TO_RDR_SetDataRateAndClockFrequency+0x40>)
 10031f6:	788b      	ldrb	r3, [r1, #2]
 10031f8:	784a      	ldrb	r2, [r1, #1]
 10031fa:	021b      	lsls	r3, r3, #8
 10031fc:	4313      	orrs	r3, r2
 10031fe:	78ca      	ldrb	r2, [r1, #3]
 1003200:	0412      	lsls	r2, r2, #16
 1003202:	4313      	orrs	r3, r2
 1003204:	790a      	ldrb	r2, [r1, #4]
 1003206:	0612      	lsls	r2, r2, #24
 1003208:	431a      	orrs	r2, r3
 100320a:	4b08      	ldr	r3, [pc, #32]	; (100322c <PC_TO_RDR_SetDataRateAndClockFrequency+0x44>)
 100320c:	2a08      	cmp	r2, #8
 100320e:	d003      	beq.n	1003218 <PC_TO_RDR_SetDataRateAndClockFrequency+0x30>
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003210:	2240      	movs	r2, #64	; 0x40
        return SLOTERROR_BAD_LENTGH;
 1003212:	3001      	adds	r0, #1
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003214:	71da      	strb	r2, [r3, #7]

        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
    }

    return error;
}
 1003216:	bd10      	pop	{r4, pc}
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003218:	2240      	movs	r2, #64	; 0x40
    Ccid_bulkin_data.bError = error;
 100321a:	7218      	strb	r0, [r3, #8]
        Ccid_bulkin_data.dwLength = 0;
 100321c:	7058      	strb	r0, [r3, #1]
 100321e:	7098      	strb	r0, [r3, #2]
 1003220:	70d8      	strb	r0, [r3, #3]
 1003222:	7118      	strb	r0, [r3, #4]
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003224:	71da      	strb	r2, [r3, #7]
    return error;
 1003226:	e7f6      	b.n	1003216 <PC_TO_RDR_SetDataRateAndClockFrequency+0x2e>
 1003228:	00021808 	.word	0x00021808
 100322c:	00021918 	.word	0x00021918

01003230 <PC_TO_RDR_Secure>:
    uint8_t error;
    uint8_t bBWI;
    uint16_t wLevelParameter;
    uint32_t responseLen;

    Ccid_bulkin_data.dwLength = 0;
 1003230:	2300      	movs	r3, #0
{
 1003232:	b570      	push	{r4, r5, r6, lr}
    Ccid_bulkin_data.dwLength = 0;
 1003234:	4d10      	ldr	r5, [pc, #64]	; (1003278 <PC_TO_RDR_Secure+0x48>)

    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1003236:	2031      	movs	r0, #49	; 0x31
    Ccid_bulkin_data.dwLength = 0;
 1003238:	1c6c      	adds	r4, r5, #1
 100323a:	706b      	strb	r3, [r5, #1]
 100323c:	7063      	strb	r3, [r4, #1]
 100323e:	70a3      	strb	r3, [r4, #2]
 1003240:	70e3      	strb	r3, [r4, #3]
    error = CCID_CheckCommandParams(CHK_PARAM_SLOT | \
 1003242:	f000 f8b5 	bl	10033b0 <CCID_CheckCommandParams>
                                    CHK_PARAM_CARD_PRESENT | \
                                    CHK_PARAM_ABORT);

    if (error != 0) return error;
 1003246:	2800      	cmp	r0, #0
 1003248:	d10a      	bne.n	1003260 <PC_TO_RDR_Secure+0x30>

    bBWI = Ccid_bulkout_data.bSpecific_0;
    wLevelParameter = (Ccid_bulkout_data.bSpecific_1 + ((uint16_t)Ccid_bulkout_data.bSpecific_2 << 8));
 100324a:	490c      	ldr	r1, [pc, #48]	; (100327c <PC_TO_RDR_Secure+0x4c>)
 100324c:	7a4a      	ldrb	r2, [r1, #9]
 100324e:	7a0b      	ldrb	r3, [r1, #8]
 1003250:	0212      	lsls	r2, r2, #8
 1003252:	189b      	adds	r3, r3, r2

    if ((EXCHANGE_LEVEL_FEATURE == TPDU_EXCHANGE) ||
            (EXCHANGE_LEVEL_FEATURE == SHORT_APDU_EXCHANGE))
    {
        /* TPDU level & short APDU level, wLevelParameter is RFU, = 0000h */
        if (wLevelParameter != 0)
 1003254:	b29b      	uxth	r3, r3
 1003256:	2b00      	cmp	r3, #0
 1003258:	d003      	beq.n	1003262 <PC_TO_RDR_Secure+0x32>
        {
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 100325a:	2340      	movs	r3, #64	; 0x40
            error = SLOTERROR_BAD_LEVELPARAMETER;
            return error;
 100325c:	3008      	adds	r0, #8
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 100325e:	71eb      	strb	r3, [r5, #7]
    {
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_NO_ERROR, BM_ICC_PRESENT_ACTIVE);
    }

    return error;
}
 1003260:	bd70      	pop	{r4, r5, r6, pc}
    Ccid_bulkin_data.dwLength = responseLen;
 1003262:	2300      	movs	r3, #0
 1003264:	22ff      	movs	r2, #255	; 0xff
 1003266:	7063      	strb	r3, [r4, #1]
 1003268:	401a      	ands	r2, r3
 100326a:	70a3      	strb	r3, [r4, #2]
 100326c:	0e1b      	lsrs	r3, r3, #24
 100326e:	70e3      	strb	r3, [r4, #3]
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003270:	2340      	movs	r3, #64	; 0x40
    Ccid_bulkin_data.dwLength = responseLen;
 1003272:	706a      	strb	r2, [r5, #1]
        CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003274:	71eb      	strb	r3, [r5, #7]
    return error;
 1003276:	e7f3      	b.n	1003260 <PC_TO_RDR_Secure+0x30>
 1003278:	00021918 	.word	0x00021918
 100327c:	00021808 	.word	0x00021808

01003280 <RDR_to_PC_DataBlock>:
  */
void RDR_to_PC_DataBlock(uint8_t errorCode)
{
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;

    Ccid_bulkin_data.bMessageType = RDR_TO_PC_DATABLOCK;
 1003280:	2280      	movs	r2, #128	; 0x80
 1003282:	4b09      	ldr	r3, [pc, #36]	; (10032a8 <RDR_to_PC_DataBlock+0x28>)
{
 1003284:	b510      	push	{r4, lr}
    Ccid_bulkin_data.bMessageType = RDR_TO_PC_DATABLOCK;
 1003286:	701a      	strb	r2, [r3, #0]
    Ccid_bulkin_data.bError = errorCode;
    Ccid_bulkin_data.bSpecific = 0;    /* bChainParameter */
 1003288:	2200      	movs	r2, #0
    Ccid_bulkin_data.bError = errorCode;
 100328a:	7218      	strb	r0, [r3, #8]
    Ccid_bulkin_data.bSpecific = 0;    /* bChainParameter */
 100328c:	725a      	strb	r2, [r3, #9]
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;
 100328e:	210a      	movs	r1, #10

    if (errorCode == SLOT_NO_ERROR)
 1003290:	2881      	cmp	r0, #129	; 0x81
 1003292:	d105      	bne.n	10032a0 <RDR_to_PC_DataBlock+0x20>
    {
        length += Ccid_bulkin_data.dwLength;   /* Length Specified in Command */
 1003294:	7899      	ldrb	r1, [r3, #2]
 1003296:	785a      	ldrb	r2, [r3, #1]
 1003298:	0209      	lsls	r1, r1, #8
 100329a:	4311      	orrs	r1, r2
 100329c:	310a      	adds	r1, #10
 100329e:	b289      	uxth	r1, r1
    }

    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data), length);
 10032a0:	0018      	movs	r0, r3
 10032a2:	f000 fae1 	bl	1003868 <Transfer_Data_Request>

}
 10032a6:	bd10      	pop	{r4, pc}
 10032a8:	00021918 	.word	0x00021918

010032ac <RDR_to_PC_SlotStatus>:
  * @retval None
  */
void RDR_to_PC_SlotStatus(uint8_t errorCode)
{

    Ccid_bulkin_data.bMessageType = RDR_TO_PC_SLOTSTATUS;
 10032ac:	2281      	movs	r2, #129	; 0x81
 10032ae:	4b07      	ldr	r3, [pc, #28]	; (10032cc <RDR_to_PC_SlotStatus+0x20>)
{
 10032b0:	b510      	push	{r4, lr}
    Ccid_bulkin_data.bMessageType = RDR_TO_PC_SLOTSTATUS;
 10032b2:	701a      	strb	r2, [r3, #0]
    Ccid_bulkin_data.dwLength = 0;
 10032b4:	2200      	movs	r2, #0
    Ccid_bulkin_data.bError = errorCode;
 10032b6:	7218      	strb	r0, [r3, #8]
                                          02h Clock stopped in state H
                                          03h Clock stopped in an unknown state
                                          All other values are RFU. */


    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data),
 10032b8:	210a      	movs	r1, #10
 10032ba:	0018      	movs	r0, r3
    Ccid_bulkin_data.dwLength = 0;
 10032bc:	705a      	strb	r2, [r3, #1]
 10032be:	709a      	strb	r2, [r3, #2]
 10032c0:	70da      	strb	r2, [r3, #3]
 10032c2:	711a      	strb	r2, [r3, #4]
    Ccid_bulkin_data.bSpecific = 0;    /* bClockStatus = 00h Clock running
 10032c4:	725a      	strb	r2, [r3, #9]
    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data),
 10032c6:	f000 facf 	bl	1003868 <Transfer_Data_Request>
                          LEN_RDR_TO_PC_SLOTSTATUS);

}
 10032ca:	bd10      	pop	{r4, pc}
 10032cc:	00021918 	.word	0x00021918

010032d0 <RDR_to_PC_Parameters>:
  */
void RDR_to_PC_Parameters(uint8_t errorCode)
{
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;

    Ccid_bulkin_data.bMessageType = RDR_TO_PC_PARAMETERS;
 10032d0:	2282      	movs	r2, #130	; 0x82
 10032d2:	4b12      	ldr	r3, [pc, #72]	; (100331c <RDR_to_PC_Parameters+0x4c>)
{
 10032d4:	b510      	push	{r4, lr}
 10032d6:	1c59      	adds	r1, r3, #1
    Ccid_bulkin_data.bMessageType = RDR_TO_PC_PARAMETERS;
 10032d8:	701a      	strb	r2, [r3, #0]
    Ccid_bulkin_data.bError = errorCode;
 10032da:	7218      	strb	r0, [r3, #8]
 10032dc:	2200      	movs	r2, #0

    if (errorCode == SLOT_NO_ERROR)
 10032de:	2881      	cmp	r0, #129	; 0x81
 10032e0:	d116      	bne.n	1003310 <RDR_to_PC_Parameters+0x40>
    {
        Ccid_bulkin_data.dwLength = LEN_PROTOCOL_STRUCT_T0;
 10032e2:	704a      	strb	r2, [r1, #1]
 10032e4:	708a      	strb	r2, [r1, #2]
 10032e6:	70ca      	strb	r2, [r1, #3]
        length += LEN_PROTOCOL_STRUCT_T0;
 10032e8:	210f      	movs	r1, #15
        Ccid_bulkin_data.dwLength = LEN_PROTOCOL_STRUCT_T0;
 10032ea:	387c      	subs	r0, #124	; 0x7c
 10032ec:	7058      	strb	r0, [r3, #1]
    else
    {
        Ccid_bulkin_data.dwLength = 0;
    }

    Ccid_bulkin_data.abData[0] = Protocol0_DataStructure.bmFindexDindex;
 10032ee:	4a0c      	ldr	r2, [pc, #48]	; (1003320 <RDR_to_PC_Parameters+0x50>)
 10032f0:	7810      	ldrb	r0, [r2, #0]
 10032f2:	7298      	strb	r0, [r3, #10]
    Ccid_bulkin_data.abData[1] = Protocol0_DataStructure.bmTCCKST0;
 10032f4:	7850      	ldrb	r0, [r2, #1]
 10032f6:	72d8      	strb	r0, [r3, #11]
    Ccid_bulkin_data.abData[2] = Protocol0_DataStructure.bGuardTimeT0;
 10032f8:	7890      	ldrb	r0, [r2, #2]
 10032fa:	7318      	strb	r0, [r3, #12]
    Ccid_bulkin_data.abData[3] = Protocol0_DataStructure.bWaitingIntegerT0;
 10032fc:	78d0      	ldrb	r0, [r2, #3]
 10032fe:	7358      	strb	r0, [r3, #13]
    Ccid_bulkin_data.abData[4] = Protocol0_DataStructure.bClockStop;
 1003300:	7912      	ldrb	r2, [r2, #4]

    /* bProtocolNum */
    Ccid_bulkin_data.bSpecific = BPROTOCOL_NUM_T0;

    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data), length);
 1003302:	0018      	movs	r0, r3
    Ccid_bulkin_data.abData[4] = Protocol0_DataStructure.bClockStop;
 1003304:	739a      	strb	r2, [r3, #14]
    Ccid_bulkin_data.bSpecific = BPROTOCOL_NUM_T0;
 1003306:	2200      	movs	r2, #0
 1003308:	725a      	strb	r2, [r3, #9]
    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data), length);
 100330a:	f000 faad 	bl	1003868 <Transfer_Data_Request>
}
 100330e:	bd10      	pop	{r4, pc}
        Ccid_bulkin_data.dwLength = 0;
 1003310:	704a      	strb	r2, [r1, #1]
 1003312:	708a      	strb	r2, [r1, #2]
 1003314:	70ca      	strb	r2, [r1, #3]
 1003316:	705a      	strb	r2, [r3, #1]
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;
 1003318:	210a      	movs	r1, #10
 100331a:	e7e8      	b.n	10032ee <RDR_to_PC_Parameters+0x1e>
 100331c:	00021918 	.word	0x00021918
 1003320:	00021be6 	.word	0x00021be6

01003324 <RDR_to_PC_Escape>:
  */
void RDR_to_PC_Escape(uint8_t errorCode)
{
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;

    Ccid_bulkin_data.bMessageType = RDR_TO_PC_ESCAPE;
 1003324:	2283      	movs	r2, #131	; 0x83
 1003326:	4b09      	ldr	r3, [pc, #36]	; (100334c <RDR_to_PC_Escape+0x28>)
{
 1003328:	b510      	push	{r4, lr}
    Ccid_bulkin_data.bMessageType = RDR_TO_PC_ESCAPE;
 100332a:	701a      	strb	r2, [r3, #0]

    Ccid_bulkin_data.bSpecific = 0;    /* Reserved for Future Use */
 100332c:	2200      	movs	r2, #0
    Ccid_bulkin_data.bError = errorCode;
 100332e:	7218      	strb	r0, [r3, #8]
    Ccid_bulkin_data.bSpecific = 0;    /* Reserved for Future Use */
 1003330:	725a      	strb	r2, [r3, #9]
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;
 1003332:	210a      	movs	r1, #10

    if (errorCode == SLOT_NO_ERROR)
 1003334:	2881      	cmp	r0, #129	; 0x81
 1003336:	d105      	bne.n	1003344 <RDR_to_PC_Escape+0x20>
    {
        length += Ccid_bulkin_data.dwLength;   /* Length Specified in Command */
 1003338:	7899      	ldrb	r1, [r3, #2]
 100333a:	785a      	ldrb	r2, [r3, #1]
 100333c:	0209      	lsls	r1, r1, #8
 100333e:	4311      	orrs	r1, r2
 1003340:	310a      	adds	r1, #10
 1003342:	b289      	uxth	r1, r1
    }

    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data), length);
 1003344:	0018      	movs	r0, r3
 1003346:	f000 fa8f 	bl	1003868 <Transfer_Data_Request>
}
 100334a:	bd10      	pop	{r4, pc}
 100334c:	00021918 	.word	0x00021918

01003350 <RDR_to_PC_DataRateAndClockFrequency>:
  */
void RDR_to_PC_DataRateAndClockFrequency(uint8_t errorCode)
{
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;

    Ccid_bulkin_data.bMessageType = RDR_TO_PC_DATARATEANDCLOCKFREQUENCY;
 1003350:	2284      	movs	r2, #132	; 0x84
 1003352:	4b09      	ldr	r3, [pc, #36]	; (1003378 <RDR_to_PC_DataRateAndClockFrequency+0x28>)
{
 1003354:	b510      	push	{r4, lr}
    Ccid_bulkin_data.bMessageType = RDR_TO_PC_DATARATEANDCLOCKFREQUENCY;
 1003356:	701a      	strb	r2, [r3, #0]
    Ccid_bulkin_data.bError = errorCode;
    Ccid_bulkin_data.bSpecific = 0;    /* Reserved for Future Use */
 1003358:	2200      	movs	r2, #0
    Ccid_bulkin_data.bError = errorCode;
 100335a:	7218      	strb	r0, [r3, #8]
    Ccid_bulkin_data.bSpecific = 0;    /* Reserved for Future Use */
 100335c:	725a      	strb	r2, [r3, #9]
    uint16_t length = CCID_RESPONSE_HEADER_SIZE;
 100335e:	210a      	movs	r1, #10

    if (errorCode == SLOT_NO_ERROR)
 1003360:	2881      	cmp	r0, #129	; 0x81
 1003362:	d105      	bne.n	1003370 <RDR_to_PC_DataRateAndClockFrequency+0x20>
    {
        length += Ccid_bulkin_data.dwLength;   /* Length Specified in Command */
 1003364:	7899      	ldrb	r1, [r3, #2]
 1003366:	785a      	ldrb	r2, [r3, #1]
 1003368:	0209      	lsls	r1, r1, #8
 100336a:	4311      	orrs	r1, r2
 100336c:	310a      	adds	r1, #10
 100336e:	b289      	uxth	r1, r1
    }

    Transfer_Data_Request((uint8_t *)(&Ccid_bulkin_data), length);
 1003370:	0018      	movs	r0, r3
 1003372:	f000 fa79 	bl	1003868 <Transfer_Data_Request>
}
 1003376:	bd10      	pop	{r4, pc}
 1003378:	00021918 	.word	0x00021918

0100337c <RDR_to_PC_NotifySlotChange>:
  * @param  None
  * @retval None
  */
void RDR_to_PC_NotifySlotChange(void)
{
    UsbIntMessageBuffer[OFFSET_INT_BMESSAGETYPE] = RDR_TO_PC_NOTIFYSLOTCHANGE;
 100337c:	2250      	movs	r2, #80	; 0x50
 100337e:	4b02      	ldr	r3, [pc, #8]	; (1003388 <RDR_to_PC_NotifySlotChange+0xc>)
 1003380:	701a      	strb	r2, [r3, #0]

    /*
    SLOT_ICC_PRESENT 0x01 : LSb : (0b = no ICC present, 1b = ICC present)
    SLOT_ICC_CHANGE 0x02 : MSb : (0b = no change, 1b = change).
    */
    UsbIntMessageBuffer[OFFSET_INT_BMSLOTICCSTATE] = SLOT_ICC_PRESENT |
 1003382:	3a4d      	subs	r2, #77	; 0x4d
 1003384:	705a      	strb	r2, [r3, #1]
            SLOT_ICC_CHANGE;
}
 1003386:	4770      	bx	lr
 1003388:	0002169c 	.word	0x0002169c

0100338c <CCID_UpdSlotStatus>:
  * @param  uint8_t slotStatus : slot status from the calling function
  * @retval None
  */
void CCID_UpdSlotStatus(uint8_t slotStatus)
{
    Ccid_SlotStatus.SlotStatus = slotStatus;
 100338c:	4b01      	ldr	r3, [pc, #4]	; (1003394 <CCID_UpdSlotStatus+0x8>)
 100338e:	7018      	strb	r0, [r3, #0]
}
 1003390:	4770      	bx	lr
 1003392:	46c0      	nop			; (mov r8, r8)
 1003394:	00021a29 	.word	0x00021a29

01003398 <CCID_UpdSlotChange>:
  * @param  uint8_t changeStatus : slot change status from the calling function
  * @retval None
  */
void CCID_UpdSlotChange(uint8_t changeStatus)
{
    Ccid_SlotStatus.SlotStatusChange = changeStatus;
 1003398:	4b01      	ldr	r3, [pc, #4]	; (10033a0 <CCID_UpdSlotChange+0x8>)
 100339a:	7058      	strb	r0, [r3, #1]
}
 100339c:	4770      	bx	lr
 100339e:	46c0      	nop			; (mov r8, r8)
 10033a0:	00021a29 	.word	0x00021a29

010033a4 <CCID_IsSlotStatusChange>:
  * @param  None
  * @retval uint8_t slot change status
  */
uint8_t CCID_IsSlotStatusChange(void)
{
    return Ccid_SlotStatus.SlotStatusChange;
 10033a4:	4b01      	ldr	r3, [pc, #4]	; (10033ac <CCID_IsSlotStatusChange+0x8>)
 10033a6:	7858      	ldrb	r0, [r3, #1]
 10033a8:	b2c0      	uxtb	r0, r0
}
 10033aa:	4770      	bx	lr
 10033ac:	00021a29 	.word	0x00021a29

010033b0 <CCID_CheckCommandParams>:
  */
static uint8_t CCID_CheckCommandParams(uint32_t param_type)
{
    uint32_t parameter;

    Ccid_bulkin_data.bStatus = BM_ICC_PRESENT_ACTIVE | BM_COMMAND_STATUS_NO_ERROR;
 10033b0:	2300      	movs	r3, #0
 10033b2:	4a24      	ldr	r2, [pc, #144]	; (1003444 <CCID_CheckCommandParams+0x94>)
{
 10033b4:	b510      	push	{r4, lr}
    Ccid_bulkin_data.bStatus = BM_ICC_PRESENT_ACTIVE | BM_COMMAND_STATUS_NO_ERROR;
 10033b6:	71d3      	strb	r3, [r2, #7]

    parameter = (uint32_t)param_type;

    if (parameter & CHK_PARAM_SLOT)
 10033b8:	07c3      	lsls	r3, r0, #31
 10033ba:	d508      	bpl.n	10033ce <CCID_CheckCommandParams+0x1e>
        The slot number is zero-relative, and is in the range of zero to FFh.
        */

        /* SLOT Number is 0 onwards, so always < CCID_NUMBER_OF_SLOTs */
        /* Error Condition !!! */
        if (Ccid_bulkout_data.bSlot >= CCID_NUMBER_OF_SLOTS)
 10033bc:	4b22      	ldr	r3, [pc, #136]	; (1003448 <CCID_CheckCommandParams+0x98>)
 10033be:	795b      	ldrb	r3, [r3, #5]
 10033c0:	2b00      	cmp	r3, #0
 10033c2:	d004      	beq.n	10033ce <CCID_CheckCommandParams+0x1e>
        {
            /* Slot requested is more than supported by Firmware */
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_NO_ICC_PRESENT);
 10033c4:	2342      	movs	r3, #66	; 0x42
 10033c6:	71d3      	strb	r3, [r2, #7]
            return SLOTERROR_BAD_SLOT;
 10033c8:	3b3d      	subs	r3, #61	; 0x3d
        //Card always active T0/T1 doesn't matter.

    }

    return 0;
}
 10033ca:	0018      	movs	r0, r3
 10033cc:	bd10      	pop	{r4, pc}
    if (parameter & CHK_PARAM_DWLENGTH)
 10033ce:	0783      	lsls	r3, r0, #30
 10033d0:	d50f      	bpl.n	10033f2 <CCID_CheckCommandParams+0x42>
        if (Ccid_bulkout_data.dwLength != 0)
 10033d2:	4c1d      	ldr	r4, [pc, #116]	; (1003448 <CCID_CheckCommandParams+0x98>)
 10033d4:	78a1      	ldrb	r1, [r4, #2]
 10033d6:	7863      	ldrb	r3, [r4, #1]
 10033d8:	0209      	lsls	r1, r1, #8
 10033da:	4319      	orrs	r1, r3
 10033dc:	78e3      	ldrb	r3, [r4, #3]
 10033de:	041b      	lsls	r3, r3, #16
 10033e0:	4319      	orrs	r1, r3
 10033e2:	7923      	ldrb	r3, [r4, #4]
 10033e4:	061b      	lsls	r3, r3, #24
 10033e6:	430b      	orrs	r3, r1
 10033e8:	d003      	beq.n	10033f2 <CCID_CheckCommandParams+0x42>
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 10033ea:	2340      	movs	r3, #64	; 0x40
 10033ec:	71d3      	strb	r3, [r2, #7]
            return SLOTERROR_BAD_LENTGH;
 10033ee:	3b3f      	subs	r3, #63	; 0x3f
 10033f0:	e7eb      	b.n	10033ca <CCID_CheckCommandParams+0x1a>
    if (parameter & CHK_PARAM_abRFU2)
 10033f2:	0743      	lsls	r3, r0, #29
 10033f4:	d50a      	bpl.n	100340c <CCID_CheckCommandParams+0x5c>
        if ((Ccid_bulkout_data.bSpecific_1 != 0) ||
 10033f6:	4b14      	ldr	r3, [pc, #80]	; (1003448 <CCID_CheckCommandParams+0x98>)
 10033f8:	7a19      	ldrb	r1, [r3, #8]
 10033fa:	2900      	cmp	r1, #0
 10033fc:	d102      	bne.n	1003404 <CCID_CheckCommandParams+0x54>
 10033fe:	7a5b      	ldrb	r3, [r3, #9]
 1003400:	2b00      	cmp	r3, #0
 1003402:	d003      	beq.n	100340c <CCID_CheckCommandParams+0x5c>
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003404:	2340      	movs	r3, #64	; 0x40
 1003406:	71d3      	strb	r3, [r2, #7]
            return SLOTERROR_BAD_ABRFU_2B;        /* bSpecific_1 */
 1003408:	3b38      	subs	r3, #56	; 0x38
 100340a:	e7de      	b.n	10033ca <CCID_CheckCommandParams+0x1a>
    if (parameter & CHK_PARAM_abRFU3)
 100340c:	0703      	lsls	r3, r0, #28
 100340e:	d50d      	bpl.n	100342c <CCID_CheckCommandParams+0x7c>
        if ((Ccid_bulkout_data.bSpecific_0 != 0) ||
 1003410:	4b0d      	ldr	r3, [pc, #52]	; (1003448 <CCID_CheckCommandParams+0x98>)
 1003412:	79d9      	ldrb	r1, [r3, #7]
 1003414:	2900      	cmp	r1, #0
 1003416:	d105      	bne.n	1003424 <CCID_CheckCommandParams+0x74>
 1003418:	7a19      	ldrb	r1, [r3, #8]
 100341a:	2900      	cmp	r1, #0
 100341c:	d102      	bne.n	1003424 <CCID_CheckCommandParams+0x74>
                (Ccid_bulkout_data.bSpecific_1 != 0) ||
 100341e:	7a5b      	ldrb	r3, [r3, #9]
 1003420:	2b00      	cmp	r3, #0
 1003422:	d003      	beq.n	100342c <CCID_CheckCommandParams+0x7c>
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_ACTIVE);
 1003424:	2340      	movs	r3, #64	; 0x40
 1003426:	71d3      	strb	r3, [r2, #7]
            return SLOTERROR_BAD_ABRFU_3B;
 1003428:	3b39      	subs	r3, #57	; 0x39
 100342a:	e7ce      	b.n	10033ca <CCID_CheckCommandParams+0x1a>
    return 0;
 100342c:	2300      	movs	r3, #0
    if (parameter & CHK_PARAM_ABORT)
 100342e:	0681      	lsls	r1, r0, #26
 1003430:	d5cb      	bpl.n	10033ca <CCID_CheckCommandParams+0x1a>
        if (usb_ccid_param.bAbortRequestFlag)
 1003432:	4906      	ldr	r1, [pc, #24]	; (100344c <CCID_CheckCommandParams+0x9c>)
 1003434:	7809      	ldrb	r1, [r1, #0]
 1003436:	4299      	cmp	r1, r3
 1003438:	d0c7      	beq.n	10033ca <CCID_CheckCommandParams+0x1a>
            CCID_UpdateCommandStatus(BM_COMMAND_STATUS_FAILED, BM_ICC_PRESENT_INACTIVE);
 100343a:	3341      	adds	r3, #65	; 0x41
 100343c:	71d3      	strb	r3, [r2, #7]
            return SLOTERROR_CMD_ABORTED;
 100343e:	33be      	adds	r3, #190	; 0xbe
 1003440:	e7c3      	b.n	10033ca <CCID_CheckCommandParams+0x1a>
 1003442:	46c0      	nop			; (mov r8, r8)
 1003444:	00021918 	.word	0x00021918
 1003448:	00021808 	.word	0x00021808
 100344c:	000216a4 	.word	0x000216a4

01003450 <USBD_CCID_Init>:
  * @param  cfgidx: configuration index
  * @retval status
  */
static uint8_t USBD_CCID_Init(void *pdev,
                              uint8_t cfgidx)
{
 1003450:	b510      	push	{r4, lr}
 1003452:	0004      	movs	r4, r0

    /* Open EP IN */
    DCD_EP_Open(pdev,
 1003454:	2302      	movs	r3, #2
 1003456:	2240      	movs	r2, #64	; 0x40
 1003458:	2181      	movs	r1, #129	; 0x81
 100345a:	f7ff f825 	bl	10024a8 <DCD_EP_Open>
                CCID_BULK_IN_EP,
                CCID_BULK_EPIN_SIZE,
                USB_OTG_EP_BULK);

    /* Open EP OUT */
    DCD_EP_Open(pdev,
 100345e:	2302      	movs	r3, #2
 1003460:	2240      	movs	r2, #64	; 0x40
 1003462:	2101      	movs	r1, #1
 1003464:	0020      	movs	r0, r4
 1003466:	f7ff f81f 	bl	10024a8 <DCD_EP_Open>
                CCID_BULK_OUT_EP,
                CCID_BULK_EPOUT_SIZE,
                USB_OTG_EP_BULK);

    /* Open INTR EP IN */
    DCD_EP_Open(pdev,
 100346a:	2303      	movs	r3, #3
 100346c:	2208      	movs	r2, #8
 100346e:	2182      	movs	r1, #130	; 0x82
 1003470:	0020      	movs	r0, r4
 1003472:	f7ff f819 	bl	10024a8 <DCD_EP_Open>
                CCID_INTR_IN_EP,
                CCID_INTR_EPIN_SIZE,
                USB_OTG_EP_INT);

    /* Init the CCID  layer */
    CCID_Init(pdev);
 1003476:	0020      	movs	r0, r4
 1003478:	f000 f874 	bl	1003564 <CCID_Init>

    return USBD_OK;
}
 100347c:	2000      	movs	r0, #0
 100347e:	bd10      	pop	{r4, pc}

01003480 <USBD_CCID_DeInit>:
  * @param  cfgidx: configuration index
  * @retval status
  */
static uint8_t USBD_CCID_DeInit(void *pdev,
                                uint8_t cfgidx)
{
 1003480:	b510      	push	{r4, lr}
 1003482:	0004      	movs	r4, r0
    /* Close CCID EPs */
    DCD_EP_Close(pdev, CCID_BULK_IN_EP);
 1003484:	2181      	movs	r1, #129	; 0x81
 1003486:	f7ff f82d 	bl	10024e4 <DCD_EP_Close>
    DCD_EP_Close(pdev, CCID_BULK_OUT_EP);
 100348a:	2101      	movs	r1, #1
 100348c:	0020      	movs	r0, r4
 100348e:	f7ff f829 	bl	10024e4 <DCD_EP_Close>
    DCD_EP_Close(pdev, CCID_INTR_IN_EP);
 1003492:	2182      	movs	r1, #130	; 0x82
 1003494:	0020      	movs	r0, r4
 1003496:	f7ff f825 	bl	10024e4 <DCD_EP_Close>

    /* Un Init the CCID layer */
    CCID_DeInit(pdev);
 100349a:	0020      	movs	r0, r4
 100349c:	f000 f86c 	bl	1003578 <CCID_DeInit>
    return USBD_OK;
}
 10034a0:	2000      	movs	r0, #0
 10034a2:	bd10      	pop	{r4, pc}

010034a4 <USBD_CCID_Setup>:
  * @param  pdev: device instance
  * @param  req: USB request
  * @retval status
  */
static uint8_t USBD_CCID_Setup(void *pdev, USB_SETUP_REQ *req)
{
 10034a4:	b570      	push	{r4, r5, r6, lr}
    uint8_t slot_nb;
    uint8_t seq_nb;
    uint16_t len;

    switch (req->bmRequest & USB_REQ_TYPE_MASK)
 10034a6:	2460      	movs	r4, #96	; 0x60
 10034a8:	780b      	ldrb	r3, [r1, #0]
{
 10034aa:	0006      	movs	r6, r0
 10034ac:	000d      	movs	r5, r1
    switch (req->bmRequest & USB_REQ_TYPE_MASK)
 10034ae:	401c      	ands	r4, r3
 10034b0:	d02b      	beq.n	100350a <USBD_CCID_Setup+0x66>
 10034b2:	2c20      	cmp	r4, #32
 10034b4:	d127      	bne.n	1003506 <USBD_CCID_Setup+0x62>
    {
    /* Class request */
    case USB_REQ_TYPE_CLASS :
        switch (req->bRequest)
 10034b6:	784a      	ldrb	r2, [r1, #1]
 10034b8:	2a02      	cmp	r2, #2
 10034ba:	d016      	beq.n	10034ea <USBD_CCID_Setup+0x46>
 10034bc:	2a03      	cmp	r2, #3
 10034be:	d014      	beq.n	10034ea <USBD_CCID_Setup+0x46>
 10034c0:	2a01      	cmp	r2, #1
 10034c2:	d10c      	bne.n	10034de <USBD_CCID_Setup+0x3a>
        {
        case REQUEST_ABORT :

            if ((req->wLength == 0) &&
 10034c4:	88ca      	ldrh	r2, [r1, #6]
 10034c6:	2a00      	cmp	r2, #0
 10034c8:	d109      	bne.n	10034de <USBD_CCID_Setup+0x3a>
 10034ca:	b25b      	sxtb	r3, r3
 10034cc:	2b00      	cmp	r3, #0
 10034ce:	db06      	blt.n	10034de <USBD_CCID_Setup+0x3a>
            {
                /* Check bmRequest : No Data-In stage. 0x80 is Data Direction */

                /* The wValue field contains the slot number (bSlot) in the low byte
                and the sequence number (bSeq) in the high byte.*/
                slot_nb = (uint8_t)((req->wValue) & 0x00ff);
 10034d0:	8848      	ldrh	r0, [r1, #2]
                seq_nb = (uint8_t)(((req->wValue) & 0xff00) >> 8);

                if (CCID_CmdAbort(slot_nb, seq_nb) != 0)
 10034d2:	0a01      	lsrs	r1, r0, #8
 10034d4:	b2c0      	uxtb	r0, r0
 10034d6:	f7ff fe43 	bl	1003160 <CCID_CmdAbort>
 10034da:	2800      	cmp	r0, #0
 10034dc:	d004      	beq.n	10034e8 <USBD_CCID_Setup+0x44>
                return USBD_FAIL;
            }
            break;

        default:
            USBD_CtlError(pdev, req);
 10034de:	0030      	movs	r0, r6
 10034e0:	0029      	movs	r1, r5
 10034e2:	f7ff fcaf 	bl	1002e44 <USBD_CtlError>
            return USBD_FAIL;
 10034e6:	2002      	movs	r0, #2

    default:
        break;
    }
    return USBD_OK;
}
 10034e8:	bd70      	pop	{r4, r5, r6, pc}
            if ((req->wValue == 0) &&
 10034ea:	886a      	ldrh	r2, [r5, #2]
 10034ec:	2a00      	cmp	r2, #0
 10034ee:	d1f6      	bne.n	10034de <USBD_CCID_Setup+0x3a>
 10034f0:	88ea      	ldrh	r2, [r5, #6]
 10034f2:	2a00      	cmp	r2, #0
 10034f4:	d0f3      	beq.n	10034de <USBD_CCID_Setup+0x3a>
                    (req->wLength != 0) &&
 10034f6:	b25b      	sxtb	r3, r3
 10034f8:	2b00      	cmp	r3, #0
 10034fa:	daf0      	bge.n	10034de <USBD_CCID_Setup+0x3a>
                USBD_CtlSendData(pdev,
 10034fc:	2200      	movs	r2, #0
 10034fe:	490a      	ldr	r1, [pc, #40]	; (1003528 <USBD_CCID_Setup+0x84>)
 1003500:	0030      	movs	r0, r6
 1003502:	f7ff faa1 	bl	1002a48 <USBD_CtlSendData>
    return USBD_OK;
 1003506:	2000      	movs	r0, #0
 1003508:	e7ee      	b.n	10034e8 <USBD_CCID_Setup+0x44>
        switch (req->bRequest)
 100350a:	784b      	ldrb	r3, [r1, #1]
 100350c:	2b01      	cmp	r3, #1
 100350e:	d108      	bne.n	1003522 <USBD_CCID_Setup+0x7e>
            DCD_EP_Close(pdev, (uint8_t)req->wIndex);
 1003510:	7909      	ldrb	r1, [r1, #4]
 1003512:	f7fe ffe7 	bl	10024e4 <DCD_EP_Close>
                DCD_EP_Open(pdev,
 1003516:	7929      	ldrb	r1, [r5, #4]
 1003518:	2302      	movs	r3, #2
 100351a:	2240      	movs	r2, #64	; 0x40
 100351c:	0030      	movs	r0, r6
 100351e:	f7fe ffc3 	bl	10024a8 <DCD_EP_Open>
    return USBD_OK;
 1003522:	0020      	movs	r0, r4
 1003524:	e7e0      	b.n	10034e8 <USBD_CCID_Setup+0x44>
 1003526:	46c0      	nop			; (mov r8, r8)
 1003528:	00020a6c 	.word	0x00020a6c

0100352c <USBD_CCID_DataIn>:
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t USBD_CCID_DataIn(void *pdev,
                                uint8_t epnum)
{
 100352c:	b510      	push	{r4, lr}
    CCID_BulkMessage_In(pdev, epnum);
 100352e:	f000 f829 	bl	1003584 <CCID_BulkMessage_In>
    return USBD_OK;
}
 1003532:	2000      	movs	r0, #0
 1003534:	bd10      	pop	{r4, pc}
	...

01003538 <USBD_CCID_DataOut>:
  * @param  epnum: endpoint index
  * @retval status
  */
uint8_t USBD_CCID_DataOut(void *pdev,
                          uint8_t epnum)
{
 1003538:	b570      	push	{r4, r5, r6, lr}
 100353a:	000d      	movs	r5, r1
 100353c:	0004      	movs	r4, r0

    DCD_EP_PrepareRx(pdev,
 100353e:	2340      	movs	r3, #64	; 0x40
 1003540:	4a04      	ldr	r2, [pc, #16]	; (1003554 <USBD_CCID_DataOut+0x1c>)
 1003542:	2101      	movs	r1, #1
 1003544:	f7fe ffe4 	bl	1002510 <DCD_EP_PrepareRx>
                     CCID_BULK_OUT_EP,
                     (uint8_t *)&BulkOut_Data_Buff[0],
                     CCID_BULK_EPOUT_SIZE);
    CCID_BulkMessage_Out(pdev, epnum);
 1003548:	0029      	movs	r1, r5
 100354a:	0020      	movs	r0, r4
 100354c:	f000 f858 	bl	1003600 <CCID_BulkMessage_Out>
    return USBD_OK;
}
 1003550:	2000      	movs	r0, #0
 1003552:	bd70      	pop	{r4, r5, r6, pc}
 1003554:	000216ac 	.word	0x000216ac

01003558 <USBD_CCID_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CCID_GetCfgDesc(uint8_t speed, uint16_t *length)
{
    *length = sizeof(USBD_CCID_CfgDesc);
 1003558:	235d      	movs	r3, #93	; 0x5d
    return (uint8_t *)USBD_CCID_CfgDesc;
}
 100355a:	4801      	ldr	r0, [pc, #4]	; (1003560 <USBD_CCID_GetCfgDesc+0x8>)
    *length = sizeof(USBD_CCID_CfgDesc);
 100355c:	800b      	strh	r3, [r1, #0]
}
 100355e:	4770      	bx	lr
 1003560:	010056f4 	.word	0x010056f4

01003564 <CCID_Init>:
  * @param  uint8_t xfer_Status: Value of the Interrupt transfer status to set
  * @retval None
  */
void CCID_SetIntrTransferStatus(uint8_t xfer_Status)
{
    PrevXferComplete_IntrIn = xfer_Status;
 1003564:	2001      	movs	r0, #1
{
 1003566:	b510      	push	{r4, lr}
    PrevXferComplete_IntrIn = xfer_Status;
 1003568:	4b02      	ldr	r3, [pc, #8]	; (1003574 <CCID_Init+0x10>)
 100356a:	7018      	strb	r0, [r3, #0]
    CCID_UpdSlotChange(1);
 100356c:	f7ff ff14 	bl	1003398 <CCID_UpdSlotChange>
}
 1003570:	bd10      	pop	{r4, pc}
 1003572:	46c0      	nop			; (mov r8, r8)
 1003574:	00021917 	.word	0x00021917

01003578 <CCID_DeInit>:
    Ccid_BulkState = CCID_STATE_IDLE;
 1003578:	2200      	movs	r2, #0
 100357a:	4b01      	ldr	r3, [pc, #4]	; (1003580 <CCID_DeInit+0x8>)
 100357c:	701a      	strb	r2, [r3, #0]
}
 100357e:	4770      	bx	lr
 1003580:	00021a2b 	.word	0x00021a2b

01003584 <CCID_BulkMessage_In>:
    else if (epnum == (CCID_INTR_IN_EP & 0x7F))
 1003584:	2902      	cmp	r1, #2
 1003586:	d102      	bne.n	100358e <CCID_BulkMessage_In+0xa>
    PrevXferComplete_IntrIn = xfer_Status;
 1003588:	2201      	movs	r2, #1
 100358a:	4b01      	ldr	r3, [pc, #4]	; (1003590 <CCID_BulkMessage_In+0xc>)
 100358c:	701a      	strb	r2, [r3, #0]
}
 100358e:	4770      	bx	lr
 1003590:	00021917 	.word	0x00021917

01003594 <CCID_wait_next_packet>:
{
 1003594:	b570      	push	{r4, r5, r6, lr}
    ccid_wait_data_time = 0;
 1003596:	2300      	movs	r3, #0
{
 1003598:	0005      	movs	r5, r0
 100359a:	000e      	movs	r6, r1
    ccid_wait_data_time = 0;
 100359c:	4c13      	ldr	r4, [pc, #76]	; (10035ec <CCID_wait_next_packet+0x58>)
        ccid_wait_data_time++;
 100359e:	6023      	str	r3, [r4, #0]
    while (ccid_wait_data_time < CCID_DATA_TIMEOUT)
 10035a0:	6823      	ldr	r3, [r4, #0]
 10035a2:	2b13      	cmp	r3, #19
 10035a4:	d900      	bls.n	10035a8 <CCID_wait_next_packet+0x14>
}
 10035a6:	bd70      	pop	{r4, r5, r6, pc}
        ccid_wait_data_len = USB_OTG_READ_REG8(pdev->regs.LENREGS[epnum]);
 10035a8:	0033      	movs	r3, r6
 10035aa:	3308      	adds	r3, #8
 10035ac:	009b      	lsls	r3, r3, #2
 10035ae:	18eb      	adds	r3, r5, r3
 10035b0:	685b      	ldr	r3, [r3, #4]
 10035b2:	781a      	ldrb	r2, [r3, #0]
 10035b4:	4b0e      	ldr	r3, [pc, #56]	; (10035f0 <CCID_wait_next_packet+0x5c>)
 10035b6:	b2d2      	uxtb	r2, r2
 10035b8:	601a      	str	r2, [r3, #0]
        if (ccid_wait_data_len >= CCID_BULK_EPOUT_SIZE || \
 10035ba:	2a3f      	cmp	r2, #63	; 0x3f
 10035bc:	d8f3      	bhi.n	10035a6 <CCID_wait_next_packet+0x12>
                ((UsbMessageLength + ccid_wait_data_len) == (Ccid_bulkout_data.dwLength + CCID_CMD_HEADER_SIZE)))
 10035be:	4b0d      	ldr	r3, [pc, #52]	; (10035f4 <CCID_wait_next_packet+0x60>)
 10035c0:	480d      	ldr	r0, [pc, #52]	; (10035f8 <CCID_wait_next_packet+0x64>)
 10035c2:	681b      	ldr	r3, [r3, #0]
 10035c4:	7881      	ldrb	r1, [r0, #2]
 10035c6:	18d2      	adds	r2, r2, r3
 10035c8:	7843      	ldrb	r3, [r0, #1]
 10035ca:	0209      	lsls	r1, r1, #8
 10035cc:	4319      	orrs	r1, r3
 10035ce:	78c3      	ldrb	r3, [r0, #3]
 10035d0:	041b      	lsls	r3, r3, #16
 10035d2:	4319      	orrs	r1, r3
 10035d4:	7903      	ldrb	r3, [r0, #4]
 10035d6:	061b      	lsls	r3, r3, #24
 10035d8:	430b      	orrs	r3, r1
 10035da:	330a      	adds	r3, #10
        if (ccid_wait_data_len >= CCID_BULK_EPOUT_SIZE || \
 10035dc:	429a      	cmp	r2, r3
 10035de:	d0e2      	beq.n	10035a6 <CCID_wait_next_packet+0x12>
        ((void(*)(int))(FUNC_DELAY_US_ADDR))(50);
 10035e0:	4b06      	ldr	r3, [pc, #24]	; (10035fc <CCID_wait_next_packet+0x68>)
 10035e2:	2032      	movs	r0, #50	; 0x32
 10035e4:	4798      	blx	r3
        ccid_wait_data_time++;
 10035e6:	6823      	ldr	r3, [r4, #0]
 10035e8:	3301      	adds	r3, #1
 10035ea:	e7d8      	b.n	100359e <CCID_wait_next_packet+0xa>
 10035ec:	00021804 	.word	0x00021804
 10035f0:	00021800 	.word	0x00021800
 10035f4:	00020aac 	.word	0x00020aac
 10035f8:	00021808 	.word	0x00021808
 10035fc:	00004239 	.word	0x00004239

01003600 <CCID_BulkMessage_Out>:
{
 1003600:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1003602:	9101      	str	r1, [sp, #4]
    dataLen = USBD_GetRxCount(pdev, CCID_BULK_OUT_EP);
 1003604:	2101      	movs	r1, #1
{
 1003606:	0005      	movs	r5, r0
    dataLen = USBD_GetRxCount(pdev, CCID_BULK_OUT_EP);
 1003608:	f7ff fa62 	bl	1002ad0 <USBD_GetRxCount>
    switch (Ccid_BulkState)
 100360c:	4b3b      	ldr	r3, [pc, #236]	; (10036fc <CCID_BulkMessage_Out+0xfc>)
    dataLen = USBD_GetRxCount(pdev, CCID_BULK_OUT_EP);
 100360e:	0004      	movs	r4, r0
    switch (Ccid_BulkState)
 1003610:	7818      	ldrb	r0, [r3, #0]
 1003612:	2805      	cmp	r0, #5
 1003614:	d808      	bhi.n	1003628 <CCID_BulkMessage_Out+0x28>
 1003616:	f000 fc75 	bl	1003f04 <__gnu_thumb1_case_uqi>
 100361a:	0703      	.short	0x0703
 100361c:	4d07033f 	.word	0x4d07033f
        if (dataLen == 0x00)
 1003620:	2c00      	cmp	r4, #0
 1003622:	d102      	bne.n	100362a <CCID_BulkMessage_Out+0x2a>
            Ccid_BulkState = CCID_STATE_IDLE;
 1003624:	4b35      	ldr	r3, [pc, #212]	; (10036fc <CCID_BulkMessage_Out+0xfc>)
 1003626:	701c      	strb	r4, [r3, #0]
}
 1003628:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        else if (dataLen >= CCID_MESSAGE_HEADER_SIZE)
 100362a:	2c09      	cmp	r4, #9
 100362c:	d9fc      	bls.n	1003628 <CCID_BulkMessage_Out+0x28>
            pUsbMessageBuffer = (uint8_t *)&Ccid_bulkout_data;
 100362e:	4e34      	ldr	r6, [pc, #208]	; (1003700 <CCID_BulkMessage_Out+0x100>)
            UsbMessageLength = dataLen;   /* Store for future use */
 1003630:	4b34      	ldr	r3, [pc, #208]	; (1003704 <CCID_BulkMessage_Out+0x104>)
            pUsbMessageBuffer = (uint8_t *)&Ccid_bulkout_data;
 1003632:	4f35      	ldr	r7, [pc, #212]	; (1003708 <CCID_BulkMessage_Out+0x108>)
            CCID_ReceiveCmdHeader(pUsbMessageBuffer, dataLen);
 1003634:	b2e1      	uxtb	r1, r4
 1003636:	0030      	movs	r0, r6
            UsbMessageLength = dataLen;   /* Store for future use */
 1003638:	601c      	str	r4, [r3, #0]
            pUsbMessageBuffer = (uint8_t *)&Ccid_bulkout_data;
 100363a:	603e      	str	r6, [r7, #0]
            CCID_ReceiveCmdHeader(pUsbMessageBuffer, dataLen);
 100363c:	f000 f940 	bl	10038c0 <CCID_ReceiveCmdHeader>
            Ccid_bulkin_data.bSlot = Ccid_bulkout_data.bSlot;
 1003640:	7972      	ldrb	r2, [r6, #5]
 1003642:	4b32      	ldr	r3, [pc, #200]	; (100370c <CCID_BulkMessage_Out+0x10c>)
 1003644:	715a      	strb	r2, [r3, #5]
            Ccid_bulkin_data.bSeq = Ccid_bulkout_data.bSeq;
 1003646:	79b2      	ldrb	r2, [r6, #6]
 1003648:	719a      	strb	r2, [r3, #6]
            if (dataLen < CCID_BULK_EPOUT_SIZE)
 100364a:	2c3f      	cmp	r4, #63	; 0x3f
 100364c:	d803      	bhi.n	1003656 <CCID_BulkMessage_Out+0x56>
                CCID_CmdDecode(pdev);
 100364e:	0028      	movs	r0, r5
 1003650:	f000 f85e 	bl	1003710 <CCID_CmdDecode>
 1003654:	e7e8      	b.n	1003628 <CCID_BulkMessage_Out+0x28>
                if (Ccid_bulkout_data.dwLength > ABDATA_SIZE)
 1003656:	78b2      	ldrb	r2, [r6, #2]
 1003658:	7873      	ldrb	r3, [r6, #1]
 100365a:	0212      	lsls	r2, r2, #8
 100365c:	431a      	orrs	r2, r3
 100365e:	78f3      	ldrb	r3, [r6, #3]
 1003660:	041b      	lsls	r3, r3, #16
 1003662:	431a      	orrs	r2, r3
 1003664:	7933      	ldrb	r3, [r6, #4]
 1003666:	061b      	lsls	r3, r3, #24
 1003668:	4313      	orrs	r3, r2
 100366a:	2206      	movs	r2, #6
 100366c:	32ff      	adds	r2, #255	; 0xff
 100366e:	4293      	cmp	r3, r2
 1003670:	d903      	bls.n	100367a <CCID_BulkMessage_Out+0x7a>
                    Ccid_BulkState = CCID_STATE_UNCORRECT_LENGTH;
 1003672:	2305      	movs	r3, #5
        Ccid_BulkState = CCID_STATE_IDLE;
 1003674:	4a21      	ldr	r2, [pc, #132]	; (10036fc <CCID_BulkMessage_Out+0xfc>)
 1003676:	7013      	strb	r3, [r2, #0]
}
 1003678:	e7d6      	b.n	1003628 <CCID_BulkMessage_Out+0x28>
                    Ccid_BulkState = CCID_STATE_RECEIVE_DATA;
 100367a:	2302      	movs	r3, #2
 100367c:	4a1f      	ldr	r2, [pc, #124]	; (10036fc <CCID_BulkMessage_Out+0xfc>)
 100367e:	7013      	strb	r3, [r2, #0]
                    pUsbMessageBuffer += dataLen;  /* Point to new offset */
 1003680:	683b      	ldr	r3, [r7, #0]
 1003682:	191c      	adds	r4, r3, r4
 1003684:	603c      	str	r4, [r7, #0]
                CCID_wait_next_packet(pdev, CCID_BULK_OUT_EP);
 1003686:	0028      	movs	r0, r5
 1003688:	2101      	movs	r1, #1
 100368a:	f7ff ff83 	bl	1003594 <CCID_wait_next_packet>
                USBD_CCID_DataOut(pdev, epnum);
 100368e:	9901      	ldr	r1, [sp, #4]
 1003690:	0028      	movs	r0, r5
 1003692:	f7ff ff51 	bl	1003538 <USBD_CCID_DataOut>
 1003696:	e7c7      	b.n	1003628 <CCID_BulkMessage_Out+0x28>
        UsbMessageLength += dataLen;
 1003698:	4b1a      	ldr	r3, [pc, #104]	; (1003704 <CCID_BulkMessage_Out+0x104>)
 100369a:	681a      	ldr	r2, [r3, #0]
 100369c:	18a2      	adds	r2, r4, r2
 100369e:	601a      	str	r2, [r3, #0]
        if (dataLen < CCID_BULK_EPOUT_SIZE)
 10036a0:	2c3f      	cmp	r4, #63	; 0x3f
 10036a2:	d809      	bhi.n	10036b8 <CCID_BulkMessage_Out+0xb8>
            CCID_ReceiveCmdHeader(pUsbMessageBuffer, dataLen);
 10036a4:	4b18      	ldr	r3, [pc, #96]	; (1003708 <CCID_BulkMessage_Out+0x108>)
 10036a6:	b2e1      	uxtb	r1, r4
 10036a8:	6818      	ldr	r0, [r3, #0]
 10036aa:	f000 f909 	bl	10038c0 <CCID_ReceiveCmdHeader>
            CCID_CmdDecode(pdev);
 10036ae:	0028      	movs	r0, r5
 10036b0:	f000 f82e 	bl	1003710 <CCID_CmdDecode>
        Ccid_BulkState = CCID_STATE_IDLE;
 10036b4:	2300      	movs	r3, #0
 10036b6:	e7dd      	b.n	1003674 <CCID_BulkMessage_Out+0x74>
        else if (dataLen == CCID_BULK_EPOUT_SIZE)
 10036b8:	2c40      	cmp	r4, #64	; 0x40
 10036ba:	d1b5      	bne.n	1003628 <CCID_BulkMessage_Out+0x28>
            if (UsbMessageLength < (Ccid_bulkout_data.dwLength + CCID_CMD_HEADER_SIZE))
 10036bc:	4810      	ldr	r0, [pc, #64]	; (1003700 <CCID_BulkMessage_Out+0x100>)
 10036be:	7881      	ldrb	r1, [r0, #2]
 10036c0:	7843      	ldrb	r3, [r0, #1]
 10036c2:	0209      	lsls	r1, r1, #8
 10036c4:	4319      	orrs	r1, r3
 10036c6:	78c3      	ldrb	r3, [r0, #3]
 10036c8:	041b      	lsls	r3, r3, #16
 10036ca:	4319      	orrs	r1, r3
 10036cc:	7903      	ldrb	r3, [r0, #4]
 10036ce:	061b      	lsls	r3, r3, #24
 10036d0:	430b      	orrs	r3, r1
 10036d2:	330a      	adds	r3, #10
 10036d4:	429a      	cmp	r2, r3
 10036d6:	d208      	bcs.n	10036ea <CCID_BulkMessage_Out+0xea>
                CCID_ReceiveCmdHeader(pUsbMessageBuffer, dataLen); /* Copy data */
 10036d8:	4e0b      	ldr	r6, [pc, #44]	; (1003708 <CCID_BulkMessage_Out+0x108>)
 10036da:	0021      	movs	r1, r4
 10036dc:	6830      	ldr	r0, [r6, #0]
 10036de:	f000 f8ef 	bl	10038c0 <CCID_ReceiveCmdHeader>
                pUsbMessageBuffer += dataLen;
 10036e2:	6833      	ldr	r3, [r6, #0]
 10036e4:	3340      	adds	r3, #64	; 0x40
 10036e6:	6033      	str	r3, [r6, #0]
 10036e8:	e7cd      	b.n	1003686 <CCID_BulkMessage_Out+0x86>
            else if (UsbMessageLength == (Ccid_bulkout_data.dwLength + CCID_CMD_HEADER_SIZE))
 10036ea:	429a      	cmp	r2, r3
 10036ec:	d1c1      	bne.n	1003672 <CCID_BulkMessage_Out+0x72>
                CCID_ReceiveCmdHeader(pUsbMessageBuffer, dataLen);
 10036ee:	4b06      	ldr	r3, [pc, #24]	; (1003708 <CCID_BulkMessage_Out+0x108>)
 10036f0:	0021      	movs	r1, r4
 10036f2:	6818      	ldr	r0, [r3, #0]
 10036f4:	f000 f8e4 	bl	10038c0 <CCID_ReceiveCmdHeader>
 10036f8:	e7a9      	b.n	100364e <CCID_BulkMessage_Out+0x4e>
 10036fa:	46c0      	nop			; (mov r8, r8)
 10036fc:	00021a2b 	.word	0x00021a2b
 1003700:	00021808 	.word	0x00021808
 1003704:	00020aac 	.word	0x00020aac
 1003708:	000216a8 	.word	0x000216a8
 100370c:	00021918 	.word	0x00021918

01003710 <CCID_CmdDecode>:
    switch (Ccid_bulkout_data.bMessageType)
 1003710:	4b43      	ldr	r3, [pc, #268]	; (1003820 <CCID_CmdDecode+0x110>)
{
 1003712:	b570      	push	{r4, r5, r6, lr}
 1003714:	0005      	movs	r5, r0
    switch (Ccid_bulkout_data.bMessageType)
 1003716:	7818      	ldrb	r0, [r3, #0]
 1003718:	3861      	subs	r0, #97	; 0x61
 100371a:	2812      	cmp	r0, #18
 100371c:	d900      	bls.n	1003720 <CCID_CmdDecode+0x10>
 100371e:	e07a      	b.n	1003816 <CCID_CmdDecode+0x106>
 1003720:	f000 fbf0 	bl	1003f04 <__gnu_thumb1_case_uqi>
 1003724:	79120a45 	.word	0x79120a45
 1003728:	7979791a 	.word	0x7979791a
 100372c:	374b5f73 	.word	0x374b5f73
 1003730:	7920533f 	.word	0x7920533f
 1003734:	5965      	.short	0x5965
 1003736:	6b          	.byte	0x6b
 1003737:	00          	.byte	0x00
        MyPrintf("On\r\n");
 1003738:	483a      	ldr	r0, [pc, #232]	; (1003824 <CCID_CmdDecode+0x114>)
 100373a:	f7fc fe43 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_IccPowerOn();
 100373e:	f7ff fba3 	bl	1002e88 <PC_to_RDR_IccPowerOn>
        RDR_to_PC_DataBlock(errorCode);
 1003742:	f7ff fd9d 	bl	1003280 <RDR_to_PC_DataBlock>
        break;
 1003746:	e012      	b.n	100376e <CCID_CmdDecode+0x5e>
        MyPrintf("Off\r\n");
 1003748:	4837      	ldr	r0, [pc, #220]	; (1003828 <CCID_CmdDecode+0x118>)
 100374a:	f7fc fe3b 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_IccPowerOff();
 100374e:	f7ff fbb7 	bl	1002ec0 <PC_to_RDR_IccPowerOff>
        RDR_to_PC_SlotStatus(SLOTERROR_CMD_NOT_SUPPORTED);
 1003752:	f7ff fdab 	bl	10032ac <RDR_to_PC_SlotStatus>
        break;
 1003756:	e00a      	b.n	100376e <CCID_CmdDecode+0x5e>
        MyPrintf("St\r\n");
 1003758:	4834      	ldr	r0, [pc, #208]	; (100382c <CCID_CmdDecode+0x11c>)
 100375a:	f7fc fe33 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_GetSlotStatus();
 100375e:	f7ff fbb7 	bl	1002ed0 <PC_to_RDR_GetSlotStatus>
 1003762:	e7f6      	b.n	1003752 <CCID_CmdDecode+0x42>
        MyPrintf("Sd\r\n");
 1003764:	4832      	ldr	r0, [pc, #200]	; (1003830 <CCID_CmdDecode+0x120>)
 1003766:	f7fc fe2d 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_XfrBlock();
 100376a:	f7ff fc1d 	bl	1002fa8 <PC_to_RDR_XfrBlock>
    if (Ccid_BulkState == CCID_STATE_SEND_RESP)
 100376e:	4c31      	ldr	r4, [pc, #196]	; (1003834 <CCID_CmdDecode+0x124>)
 1003770:	7823      	ldrb	r3, [r4, #0]
 1003772:	2b03      	cmp	r3, #3
 1003774:	d10c      	bne.n	1003790 <CCID_CmdDecode+0x80>
        CCID_Response_SendData(pdev, (uint8_t *)&Ccid_bulkin_data,
 1003776:	4a30      	ldr	r2, [pc, #192]	; (1003838 <CCID_CmdDecode+0x128>)
 1003778:	0011      	movs	r1, r2
 100377a:	31ff      	adds	r1, #255	; 0xff
 100377c:	7c4b      	ldrb	r3, [r1, #17]
 100377e:	7c08      	ldrb	r0, [r1, #16]
 1003780:	021b      	lsls	r3, r3, #8
    DCD_EP_Tx(pdev, CCID_BULK_IN_EP, buf, len);
 1003782:	4303      	orrs	r3, r0
 1003784:	2181      	movs	r1, #129	; 0x81
 1003786:	0028      	movs	r0, r5
 1003788:	f7fe ff20 	bl	10025cc <DCD_EP_Tx>
        Ccid_BulkState = CCID_STATE_IDLE;
 100378c:	2300      	movs	r3, #0
 100378e:	7023      	strb	r3, [r4, #0]
}
 1003790:	bd70      	pop	{r4, r5, r6, pc}
        MyPrintf("GP\r\n");
 1003792:	482a      	ldr	r0, [pc, #168]	; (100383c <CCID_CmdDecode+0x12c>)
 1003794:	f7fc fe16 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_GetParameters();
 1003798:	f7ff fc46 	bl	1003028 <PC_to_RDR_GetParameters>
        RDR_to_PC_Parameters(errorCode);
 100379c:	f7ff fd98 	bl	10032d0 <RDR_to_PC_Parameters>
        break;
 10037a0:	e7e5      	b.n	100376e <CCID_CmdDecode+0x5e>
        MyPrintf("RP\r\n");
 10037a2:	4827      	ldr	r0, [pc, #156]	; (1003840 <CCID_CmdDecode+0x130>)
 10037a4:	f7fc fe0e 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_ResetParameters();
 10037a8:	f7ff fc42 	bl	1003030 <PC_to_RDR_ResetParameters>
 10037ac:	e7f6      	b.n	100379c <CCID_CmdDecode+0x8c>
        MyPrintf("SP\r\n");
 10037ae:	4825      	ldr	r0, [pc, #148]	; (1003844 <CCID_CmdDecode+0x134>)
 10037b0:	f7fc fe08 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_SetParameters();
 10037b4:	f7ff fc5e 	bl	1003074 <PC_to_RDR_SetParameters>
 10037b8:	e7f0      	b.n	100379c <CCID_CmdDecode+0x8c>
        MyPrintf("ES\r\n");
 10037ba:	4823      	ldr	r0, [pc, #140]	; (1003848 <CCID_CmdDecode+0x138>)
 10037bc:	f7fc fe02 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_Escape();
 10037c0:	f7ff fc92 	bl	10030e8 <PC_to_RDR_Escape>
        RDR_to_PC_Escape(errorCode);
 10037c4:	f7ff fdae 	bl	1003324 <RDR_to_PC_Escape>
        break;
 10037c8:	e7d1      	b.n	100376e <CCID_CmdDecode+0x5e>
        MyPrintf("IC\r\n");
 10037ca:	4820      	ldr	r0, [pc, #128]	; (100384c <CCID_CmdDecode+0x13c>)
 10037cc:	f7fc fdfa 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_IccClock();
 10037d0:	f7ff fc9e 	bl	1003110 <PC_to_RDR_IccClock>
 10037d4:	e7bd      	b.n	1003752 <CCID_CmdDecode+0x42>
        MyPrintf("> Enter PC_TO_RDR_ABORT\r\n");
 10037d6:	481e      	ldr	r0, [pc, #120]	; (1003850 <CCID_CmdDecode+0x140>)
 10037d8:	f7fc fdf4 	bl	10003c4 <MyPrintf>
        errorCode = PC_to_RDR_Abort();
 10037dc:	f7ff fcb4 	bl	1003148 <PC_to_RDR_Abort>
 10037e0:	e7b7      	b.n	1003752 <CCID_CmdDecode+0x42>
        MyPrintf("T0\r\n");
 10037e2:	481c      	ldr	r0, [pc, #112]	; (1003854 <CCID_CmdDecode+0x144>)
 10037e4:	f7fc fdee 	bl	10003c4 <MyPrintf>
        errorCode = PC_TO_RDR_T0Apdu();
 10037e8:	f7ff fcd6 	bl	1003198 <PC_TO_RDR_T0Apdu>
 10037ec:	e7b1      	b.n	1003752 <CCID_CmdDecode+0x42>
        MyPrintf("ME\r\n");
 10037ee:	481a      	ldr	r0, [pc, #104]	; (1003858 <CCID_CmdDecode+0x148>)
 10037f0:	f7fc fde8 	bl	10003c4 <MyPrintf>
        errorCode = PC_TO_RDR_Mechanical();
 10037f4:	f7ff fce4 	bl	10031c0 <PC_TO_RDR_Mechanical>
 10037f8:	e7ab      	b.n	1003752 <CCID_CmdDecode+0x42>
        MyPrintf("FR\r\n");
 10037fa:	4818      	ldr	r0, [pc, #96]	; (100385c <CCID_CmdDecode+0x14c>)
 10037fc:	f7fc fde2 	bl	10003c4 <MyPrintf>
        errorCode = PC_TO_RDR_SetDataRateAndClockFrequency();
 1003800:	f7ff fcf2 	bl	10031e8 <PC_TO_RDR_SetDataRateAndClockFrequency>
        RDR_to_PC_DataRateAndClockFrequency(errorCode);
 1003804:	f7ff fda4 	bl	1003350 <RDR_to_PC_DataRateAndClockFrequency>
        break;
 1003808:	e7b1      	b.n	100376e <CCID_CmdDecode+0x5e>
        MyPrintf("SE\r\n");
 100380a:	4815      	ldr	r0, [pc, #84]	; (1003860 <CCID_CmdDecode+0x150>)
 100380c:	f7fc fdda 	bl	10003c4 <MyPrintf>
        errorCode = PC_TO_RDR_Secure();
 1003810:	f7ff fd0e 	bl	1003230 <PC_TO_RDR_Secure>
 1003814:	e795      	b.n	1003742 <CCID_CmdDecode+0x32>
        MyPrintf("> Enter default\r\n");
 1003816:	4813      	ldr	r0, [pc, #76]	; (1003864 <CCID_CmdDecode+0x154>)
 1003818:	f7fc fdd4 	bl	10003c4 <MyPrintf>
        RDR_to_PC_SlotStatus(SLOTERROR_CMD_NOT_SUPPORTED);
 100381c:	2000      	movs	r0, #0
 100381e:	e798      	b.n	1003752 <CCID_CmdDecode+0x42>
 1003820:	00021808 	.word	0x00021808
 1003824:	01005751 	.word	0x01005751
 1003828:	01005756 	.word	0x01005756
 100382c:	0100575c 	.word	0x0100575c
 1003830:	01005761 	.word	0x01005761
 1003834:	00021a2b 	.word	0x00021a2b
 1003838:	00021918 	.word	0x00021918
 100383c:	01005766 	.word	0x01005766
 1003840:	0100576b 	.word	0x0100576b
 1003844:	01005770 	.word	0x01005770
 1003848:	01005775 	.word	0x01005775
 100384c:	0100577a 	.word	0x0100577a
 1003850:	0100577f 	.word	0x0100577f
 1003854:	01005799 	.word	0x01005799
 1003858:	0100579e 	.word	0x0100579e
 100385c:	010057a3 	.word	0x010057a3
 1003860:	010057a8 	.word	0x010057a8
 1003864:	010057ad 	.word	0x010057ad

01003868 <Transfer_Data_Request>:
    Ccid_BulkState = CCID_STATE_SEND_RESP;
 1003868:	2203      	movs	r2, #3
    Ccid_bulkin_data.u16SizeToSend = dataLen;
 100386a:	4b04      	ldr	r3, [pc, #16]	; (100387c <Transfer_Data_Request+0x14>)
 100386c:	3310      	adds	r3, #16
 100386e:	33ff      	adds	r3, #255	; 0xff
 1003870:	7019      	strb	r1, [r3, #0]
 1003872:	0a09      	lsrs	r1, r1, #8
 1003874:	7059      	strb	r1, [r3, #1]
    Ccid_BulkState = CCID_STATE_SEND_RESP;
 1003876:	4b02      	ldr	r3, [pc, #8]	; (1003880 <Transfer_Data_Request+0x18>)
 1003878:	701a      	strb	r2, [r3, #0]
}
 100387a:	4770      	bx	lr
 100387c:	00021918 	.word	0x00021918
 1003880:	00021a2b 	.word	0x00021a2b

01003884 <CCID_IntMessage>:
{
 1003884:	b570      	push	{r4, r5, r6, lr}
 1003886:	0005      	movs	r5, r0
    if (CCID_IsSlotStatusChange() && CCID_IsIntrTransferComplete())
 1003888:	f7ff fd8c 	bl	10033a4 <CCID_IsSlotStatusChange>
 100388c:	2800      	cmp	r0, #0
 100388e:	d012      	beq.n	10038b6 <CCID_IntMessage+0x32>
    return PrevXferComplete_IntrIn;
 1003890:	4c09      	ldr	r4, [pc, #36]	; (10038b8 <CCID_IntMessage+0x34>)
 1003892:	7823      	ldrb	r3, [r4, #0]
    if (CCID_IsSlotStatusChange() && CCID_IsIntrTransferComplete())
 1003894:	2b00      	cmp	r3, #0
 1003896:	d00e      	beq.n	10038b6 <CCID_IntMessage+0x32>
        RDR_to_PC_NotifySlotChange();
 1003898:	f7ff fd70 	bl	100337c <RDR_to_PC_NotifySlotChange>
    PrevXferComplete_IntrIn = xfer_Status;
 100389c:	2000      	movs	r0, #0
 100389e:	7020      	strb	r0, [r4, #0]
        CCID_UpdSlotChange(0);    /* Reset the Status of Slot Change */
 10038a0:	f7ff fd7a 	bl	1003398 <CCID_UpdSlotChange>
        my_delay_ms(10);
 10038a4:	200a      	movs	r0, #10
 10038a6:	f000 f94b 	bl	1003b40 <my_delay_ms>
        DCD_EP_Tx(pdev, CCID_INTR_IN_EP, UsbIntMessageBuffer, 2);
 10038aa:	2302      	movs	r3, #2
 10038ac:	4a03      	ldr	r2, [pc, #12]	; (10038bc <CCID_IntMessage+0x38>)
 10038ae:	2182      	movs	r1, #130	; 0x82
 10038b0:	0028      	movs	r0, r5
 10038b2:	f7fe fe8b 	bl	10025cc <DCD_EP_Tx>
}
 10038b6:	bd70      	pop	{r4, r5, r6, pc}
 10038b8:	00021917 	.word	0x00021917
 10038bc:	0002169c 	.word	0x0002169c

010038c0 <CCID_ReceiveCmdHeader>:
    for (Counter = 0; Counter < u8length; Counter++)
 10038c0:	2300      	movs	r3, #0
{
 10038c2:	b510      	push	{r4, lr}
        *pDst++ = BulkOut_Data_Buff[Counter];
 10038c4:	4a03      	ldr	r2, [pc, #12]	; (10038d4 <CCID_ReceiveCmdHeader+0x14>)
    for (Counter = 0; Counter < u8length; Counter++)
 10038c6:	4299      	cmp	r1, r3
 10038c8:	d800      	bhi.n	10038cc <CCID_ReceiveCmdHeader+0xc>
}
 10038ca:	bd10      	pop	{r4, pc}
        *pDst++ = BulkOut_Data_Buff[Counter];
 10038cc:	5cd4      	ldrb	r4, [r2, r3]
 10038ce:	54c4      	strb	r4, [r0, r3]
    for (Counter = 0; Counter < u8length; Counter++)
 10038d0:	3301      	adds	r3, #1
 10038d2:	e7f8      	b.n	10038c6 <CCID_ReceiveCmdHeader+0x6>
 10038d4:	000216ac 	.word	0x000216ac

010038d8 <CCID_IsIntrTransferComplete>:
    return PrevXferComplete_IntrIn;
 10038d8:	4b01      	ldr	r3, [pc, #4]	; (10038e0 <CCID_IsIntrTransferComplete+0x8>)
 10038da:	7818      	ldrb	r0, [r3, #0]
 10038dc:	b2c0      	uxtb	r0, r0
}
 10038de:	4770      	bx	lr
 10038e0:	00021917 	.word	0x00021917

010038e4 <CCID_SetIntrTransferStatus>:
    PrevXferComplete_IntrIn = xfer_Status;
 10038e4:	4b01      	ldr	r3, [pc, #4]	; (10038ec <CCID_SetIntrTransferStatus+0x8>)
 10038e6:	7018      	strb	r0, [r3, #0]
}
 10038e8:	4770      	bx	lr
 10038ea:	46c0      	nop			; (mov r8, r8)
 10038ec:	00021917 	.word	0x00021917

010038f0 <usb_reg_init>:
#ifdef USB_CCID_DEMO

USB_OTG_CORE_HANDLE  USB_OTG_dev;

void usb_reg_init()
{
 10038f0:	b570      	push	{r4, r5, r6, lr}
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, 0x00);
 10038f2:	25f6      	movs	r5, #246	; 0xf6
 10038f4:	2400      	movs	r4, #0
 10038f6:	032d      	lsls	r5, r5, #12
 10038f8:	702c      	strb	r4, [r5, #0]
    my_delay_ms(1);
 10038fa:	2001      	movs	r0, #1
 10038fc:	f000 f920 	bl	1003b40 <my_delay_ms>
    USB_OTG_WRITE_REG8(CORE_USB_TRIG, 0xc0);
 1003900:	22c0      	movs	r2, #192	; 0xc0
 1003902:	4b0a      	ldr	r3, [pc, #40]	; (100392c <usb_reg_init+0x3c>)
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, 0x3c);
    USB_OTG_WRITE_REG8(CORE_USB_STATUS, 0xFF);
    USB_OTG_WRITE_REG8(CORE_USB_FIFO_EMPTY, 0xFF);
    USB_OTG_WRITE_REG8(CORE_USB_ADDR, 0x00);
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(0), 0x70);
 1003904:	2170      	movs	r1, #112	; 0x70
    USB_OTG_WRITE_REG8(CORE_USB_TRIG, 0xc0);
 1003906:	701a      	strb	r2, [r3, #0]
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, 0x3c);
 1003908:	233c      	movs	r3, #60	; 0x3c
    USB_OTG_WRITE_REG8(CORE_USB_STATUS, 0xFF);
 100390a:	4a09      	ldr	r2, [pc, #36]	; (1003930 <usb_reg_init+0x40>)
    USB_OTG_WRITE_REG8(CORE_USB_CONFIG, 0x3c);
 100390c:	702b      	strb	r3, [r5, #0]
    USB_OTG_WRITE_REG8(CORE_USB_STATUS, 0xFF);
 100390e:	33c3      	adds	r3, #195	; 0xc3
 1003910:	7013      	strb	r3, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_FIFO_EMPTY, 0xFF);
 1003912:	4a08      	ldr	r2, [pc, #32]	; (1003934 <usb_reg_init+0x44>)
 1003914:	7013      	strb	r3, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_ADDR, 0x00);
 1003916:	4a08      	ldr	r2, [pc, #32]	; (1003938 <usb_reg_init+0x48>)
 1003918:	7014      	strb	r4, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(0), 0x70);
 100391a:	4a08      	ldr	r2, [pc, #32]	; (100393c <usb_reg_init+0x4c>)
 100391c:	7011      	strb	r1, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(1), 0xf0);
 100391e:	4a08      	ldr	r2, [pc, #32]	; (1003940 <usb_reg_init+0x50>)
 1003920:	3180      	adds	r1, #128	; 0x80
 1003922:	7011      	strb	r1, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(2), 0xff);
 1003924:	4a07      	ldr	r2, [pc, #28]	; (1003944 <usb_reg_init+0x54>)
 1003926:	7013      	strb	r3, [r2, #0]


}
 1003928:	bd70      	pop	{r4, r5, r6, pc}
 100392a:	46c0      	nop			; (mov r8, r8)
 100392c:	000f6010 	.word	0x000f6010
 1003930:	000f6026 	.word	0x000f6026
 1003934:	000f6027 	.word	0x000f6027
 1003938:	000f6004 	.word	0x000f6004
 100393c:	000f6001 	.word	0x000f6001
 1003940:	000f6002 	.word	0x000f6002
 1003944:	000f6003 	.word	0x000f6003

01003948 <usb_main>:
 1003948:	4b1b      	ldr	r3, [pc, #108]	; (10039b8 <usb_main+0x70>)

void usb_main(void)
{
 100394a:	b513      	push	{r0, r1, r4, lr}
 100394c:	681a      	ldr	r2, [r3, #0]
 100394e:	491b      	ldr	r1, [pc, #108]	; (10039bc <usb_main+0x74>)
 1003950:	400a      	ands	r2, r1
#if ((VERSIONS == EXIST_BT) || (VERSIONS == NO_BT))
    enable_clock(CLKCLS_BT);
    BT_CLKPLL_EN = 0xff;
 1003952:	21ff      	movs	r1, #255	; 0xff
 1003954:	601a      	str	r2, [r3, #0]
 1003956:	4a1a      	ldr	r2, [pc, #104]	; (10039c0 <usb_main+0x78>)
 1003958:	7011      	strb	r1, [r2, #0]
    SYSCTRL_HCLK_CON |= 1 << 11;
 100395a:	2280      	movs	r2, #128	; 0x80
 100395c:	4919      	ldr	r1, [pc, #100]	; (10039c4 <usb_main+0x7c>)
 100395e:	0112      	lsls	r2, r2, #4
 1003960:	6808      	ldr	r0, [r1, #0]
 1003962:	4302      	orrs	r2, r0
 1003964:	600a      	str	r2, [r1, #0]
 1003966:	2140      	movs	r1, #64	; 0x40
 1003968:	681a      	ldr	r2, [r3, #0]
 100396a:	438a      	bics	r2, r1
 100396c:	601a      	str	r2, [r3, #0]
#elif (VERSIONS == NO_XTAL)

#endif
    enable_clock(CLKCLS_USB);
    usb_reg_init();
 100396e:	f7ff ffbf 	bl	10038f0 <usb_reg_init>

    MyPrintf("YICHIP SCPU USB CCID Demo V1.0.\n");
 1003972:	4815      	ldr	r0, [pc, #84]	; (10039c8 <usb_main+0x80>)
 1003974:	f7fc fd26 	bl	10003c4 <MyPrintf>
    memset(&USB_OTG_dev, 0, sizeof(USB_OTG_dev));
 1003978:	22c0      	movs	r2, #192	; 0xc0
 100397a:	4c14      	ldr	r4, [pc, #80]	; (10039cc <usb_main+0x84>)
 100397c:	0052      	lsls	r2, r2, #1
 100397e:	2100      	movs	r1, #0
 1003980:	0020      	movs	r0, r4
 1003982:	f000 fa71 	bl	1003e68 <memset>

    USBD_Init(&USB_OTG_dev,
 1003986:	4b12      	ldr	r3, [pc, #72]	; (10039d0 <usb_main+0x88>)
 1003988:	4a12      	ldr	r2, [pc, #72]	; (10039d4 <usb_main+0x8c>)
 100398a:	9300      	str	r3, [sp, #0]
 100398c:	2101      	movs	r1, #1
 100398e:	4b12      	ldr	r3, [pc, #72]	; (10039d8 <usb_main+0x90>)
 1003990:	0020      	movs	r0, r4
 1003992:	f7fe ffd1 	bl	1002938 <USBD_Init>
    NVIC_ISER |= 1 << intid;
 1003996:	2301      	movs	r3, #1
 1003998:	4a10      	ldr	r2, [pc, #64]	; (10039dc <usb_main+0x94>)
 100399a:	6811      	ldr	r1, [r2, #0]
 100399c:	430b      	orrs	r3, r1
 100399e:	6013      	str	r3, [r2, #0]
    enable_intr(INTR_USB);


    while (1)
    {
        if (USB_OTG_dev.dev.device_status_new == USB_OTG_END)
 10039a0:	0023      	movs	r3, r4
 10039a2:	333b      	adds	r3, #59	; 0x3b
 10039a4:	781b      	ldrb	r3, [r3, #0]
 10039a6:	2b05      	cmp	r3, #5
 10039a8:	d102      	bne.n	10039b0 <usb_main+0x68>
        {
            CCID_IntMessage(&USB_OTG_dev);
 10039aa:	0020      	movs	r0, r4
 10039ac:	f7ff ff6a 	bl	1003884 <CCID_IntMessage>
        }
        resp_CCID_CMD(&USB_OTG_dev);
 10039b0:	0020      	movs	r0, r4
 10039b2:	f7ff fa99 	bl	1002ee8 <resp_CCID_CMD>
        if (USB_OTG_dev.dev.device_status_new == USB_OTG_END)
 10039b6:	e7f3      	b.n	10039a0 <usb_main+0x58>
 10039b8:	000f856c 	.word	0x000f856c
 10039bc:	ffffdfff 	.word	0xffffdfff
 10039c0:	000c8905 	.word	0x000c8905
 10039c4:	000f8560 	.word	0x000f8560
 10039c8:	010057bf 	.word	0x010057bf
 10039cc:	00021a2c 	.word	0x00021a2c
 10039d0:	000200a8 	.word	0x000200a8
 10039d4:	00020068 	.word	0x00020068
 10039d8:	00020038 	.word	0x00020038
 10039dc:	e000e100 	.word	0xe000e100

010039e0 <USB_IRQHandler>:




void USB_IRQHandler(void)
{
 10039e0:	b510      	push	{r4, lr}
    USBD_OTG_ISR_Handler(&USB_OTG_dev);
 10039e2:	4802      	ldr	r0, [pc, #8]	; (10039ec <USB_IRQHandler+0xc>)
 10039e4:	f7fe fe2a 	bl	100263c <USBD_OTG_ISR_Handler>
//   NVIC_ClearPendingIRQ(USB_IRQn);
//   MyPrintf("YICHIP SCPU USB CCID handler startV1.0.\n");
}
 10039e8:	bd10      	pop	{r4, pc}
 10039ea:	46c0      	nop			; (mov r8, r8)
 10039ec:	00021a2c 	.word	0x00021a2c

010039f0 <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_DeviceDescriptor(uint8_t speed, uint16_t *length)
{
    *length = sizeof(USBD_DeviceDesc);
 10039f0:	2312      	movs	r3, #18
    return USBD_DeviceDesc;
}
 10039f2:	4801      	ldr	r0, [pc, #4]	; (10039f8 <USBD_USR_DeviceDescriptor+0x8>)
    *length = sizeof(USBD_DeviceDesc);
 10039f4:	800b      	strh	r3, [r1, #0]
}
 10039f6:	4770      	bx	lr
 10039f8:	00020084 	.word	0x00020084

010039fc <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_LangIDStrDescriptor(uint8_t speed, uint16_t *length)
{
    *length =  sizeof(USBD_LangIDDesc);
 10039fc:	2304      	movs	r3, #4
    return USBD_LangIDDesc;
}
 10039fe:	4801      	ldr	r0, [pc, #4]	; (1003a04 <USBD_USR_LangIDStrDescriptor+0x8>)
    *length =  sizeof(USBD_LangIDDesc);
 1003a00:	800b      	strh	r3, [r1, #0]
}
 1003a02:	4770      	bx	lr
 1003a04:	000200a4 	.word	0x000200a4

01003a08 <USBD_USR_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_ProductStrDescriptor(uint8_t speed, uint16_t *length)
{
 1003a08:	b510      	push	{r4, lr}
 1003a0a:	000a      	movs	r2, r1
 1003a0c:	4c04      	ldr	r4, [pc, #16]	; (1003a20 <USBD_USR_ProductStrDescriptor+0x18>)


    if (speed == 0)
 1003a0e:	2800      	cmp	r0, #0
 1003a10:	d003      	beq.n	1003a1a <USBD_USR_ProductStrDescriptor+0x12>
    {
//    USBD_GetString (USBD_PRODUCT_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString(USBD_PRODUCT_FS_STRING, USBD_StrDesc, length);
 1003a12:	0021      	movs	r1, r4
 1003a14:	4803      	ldr	r0, [pc, #12]	; (1003a24 <USBD_USR_ProductStrDescriptor+0x1c>)
 1003a16:	f7ff fa1a 	bl	1002e4e <USBD_GetString>
    }
    return USBD_StrDesc;
}
 1003a1a:	0020      	movs	r0, r4
 1003a1c:	bd10      	pop	{r4, pc}
 1003a1e:	46c0      	nop			; (mov r8, r8)
 1003a20:	00020ab4 	.word	0x00020ab4
 1003a24:	010057e0 	.word	0x010057e0

01003a28 <USBD_USR_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_ManufacturerStrDescriptor(uint8_t speed, uint16_t *length)
{
 1003a28:	b510      	push	{r4, lr}
    USBD_GetString(USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 1003a2a:	4c04      	ldr	r4, [pc, #16]	; (1003a3c <USBD_USR_ManufacturerStrDescriptor+0x14>)
{
 1003a2c:	000a      	movs	r2, r1
    USBD_GetString(USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 1003a2e:	4804      	ldr	r0, [pc, #16]	; (1003a40 <USBD_USR_ManufacturerStrDescriptor+0x18>)
 1003a30:	0021      	movs	r1, r4
 1003a32:	f7ff fa0c 	bl	1002e4e <USBD_GetString>
    return USBD_StrDesc;
}
 1003a36:	0020      	movs	r0, r4
 1003a38:	bd10      	pop	{r4, pc}
 1003a3a:	46c0      	nop			; (mov r8, r8)
 1003a3c:	00020ab4 	.word	0x00020ab4
 1003a40:	010057f1 	.word	0x010057f1

01003a44 <USBD_USR_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_SerialStrDescriptor(uint8_t speed, uint16_t *length)
{
 1003a44:	b510      	push	{r4, lr}
 1003a46:	000a      	movs	r2, r1
 1003a48:	4c04      	ldr	r4, [pc, #16]	; (1003a5c <USBD_USR_SerialStrDescriptor+0x18>)
    if (speed  == USB_OTG_SPEED_HIGH)
 1003a4a:	2800      	cmp	r0, #0
 1003a4c:	d003      	beq.n	1003a56 <USBD_USR_SerialStrDescriptor+0x12>
    {
//    USBD_GetString (USBD_SERIALNUMBER_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString(USBD_SERIALNUMBER_FS_STRING, USBD_StrDesc, length);
 1003a4e:	0021      	movs	r1, r4
 1003a50:	4803      	ldr	r0, [pc, #12]	; (1003a60 <USBD_USR_SerialStrDescriptor+0x1c>)
 1003a52:	f7ff f9fc 	bl	1002e4e <USBD_GetString>
    }
    return USBD_StrDesc;
}
 1003a56:	0020      	movs	r0, r4
 1003a58:	bd10      	pop	{r4, pc}
 1003a5a:	46c0      	nop			; (mov r8, r8)
 1003a5c:	00020ab4 	.word	0x00020ab4
 1003a60:	010057f8 	.word	0x010057f8

01003a64 <USBD_USR_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_ConfigStrDescriptor(uint8_t speed, uint16_t *length)
{
 1003a64:	b510      	push	{r4, lr}
 1003a66:	000a      	movs	r2, r1
 1003a68:	4c04      	ldr	r4, [pc, #16]	; (1003a7c <USBD_USR_ConfigStrDescriptor+0x18>)
    if (speed  == USB_OTG_SPEED_HIGH)
 1003a6a:	2800      	cmp	r0, #0
 1003a6c:	d003      	beq.n	1003a76 <USBD_USR_ConfigStrDescriptor+0x12>
    {
//    USBD_GetString (USBD_CONFIGURATION_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString(USBD_CONFIGURATION_FS_STRING, USBD_StrDesc, length);
 1003a6e:	0021      	movs	r1, r4
 1003a70:	4803      	ldr	r0, [pc, #12]	; (1003a80 <USBD_USR_ConfigStrDescriptor+0x1c>)
 1003a72:	f7ff f9ec 	bl	1002e4e <USBD_GetString>
    }
    return USBD_StrDesc;
}
 1003a76:	0020      	movs	r0, r4
 1003a78:	bd10      	pop	{r4, pc}
 1003a7a:	46c0      	nop			; (mov r8, r8)
 1003a7c:	00020ab4 	.word	0x00020ab4
 1003a80:	01005805 	.word	0x01005805

01003a84 <USBD_USR_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t   *USBD_USR_InterfaceStrDescriptor(uint8_t speed, uint16_t *length)
{
 1003a84:	b510      	push	{r4, lr}
 1003a86:	000a      	movs	r2, r1
 1003a88:	4c04      	ldr	r4, [pc, #16]	; (1003a9c <USBD_USR_InterfaceStrDescriptor+0x18>)
    if (speed == 0)
 1003a8a:	2800      	cmp	r0, #0
 1003a8c:	d003      	beq.n	1003a96 <USBD_USR_InterfaceStrDescriptor+0x12>
    {
//    USBD_GetString (USBD_INTERFACE_HS_STRING, USBD_StrDesc, length);
    }
    else
    {
        USBD_GetString(USBD_INTERFACE_FS_STRING, USBD_StrDesc, length);
 1003a8e:	0021      	movs	r1, r4
 1003a90:	4803      	ldr	r0, [pc, #12]	; (1003aa0 <USBD_USR_InterfaceStrDescriptor+0x1c>)
 1003a92:	f7ff f9dc 	bl	1002e4e <USBD_GetString>
    }
    return USBD_StrDesc;
}
 1003a96:	0020      	movs	r0, r4
 1003a98:	bd10      	pop	{r4, pc}
 1003a9a:	46c0      	nop			; (mov r8, r8)
 1003a9c:	00020ab4 	.word	0x00020ab4
 1003aa0:	01005813 	.word	0x01005813

01003aa4 <USBD_USR_Init>:
* @retval None
*/
void USBD_USR_Init(void)
{

}
 1003aa4:	4770      	bx	lr
	...

01003aa8 <USBD_USR_DeviceReset>:
extern USBD_Class_cb_TypeDef  USBD_CCID_cb;
void USBD_USR_DeviceReset(uint8_t speed)
{

    USB_OTG_dev.dev.zero_replay_flag = 0;
    memset((uint8_t *)&USB_OTG_dev, 0, sizeof(USB_OTG_dev));
 1003aa8:	22c0      	movs	r2, #192	; 0xc0
{
 1003aaa:	b513      	push	{r0, r1, r4, lr}
    memset((uint8_t *)&USB_OTG_dev, 0, sizeof(USB_OTG_dev));
 1003aac:	4c14      	ldr	r4, [pc, #80]	; (1003b00 <USBD_USR_DeviceReset+0x58>)
 1003aae:	0052      	lsls	r2, r2, #1
 1003ab0:	2100      	movs	r1, #0
 1003ab2:	0020      	movs	r0, r4
 1003ab4:	f000 f9d8 	bl	1003e68 <memset>
    USB_OTG_dev.dev.device_status = USB_OTG_DEFAULT;
 1003ab8:	0023      	movs	r3, r4
 1003aba:	2101      	movs	r1, #1
 1003abc:	333a      	adds	r3, #58	; 0x3a
 1003abe:	7019      	strb	r1, [r3, #0]

    USBD_Init(&USB_OTG_dev,
 1003ac0:	4b10      	ldr	r3, [pc, #64]	; (1003b04 <USBD_USR_DeviceReset+0x5c>)
 1003ac2:	4a11      	ldr	r2, [pc, #68]	; (1003b08 <USBD_USR_DeviceReset+0x60>)
 1003ac4:	9300      	str	r3, [sp, #0]
 1003ac6:	0020      	movs	r0, r4
 1003ac8:	4b10      	ldr	r3, [pc, #64]	; (1003b0c <USBD_USR_DeviceReset+0x64>)
 1003aca:	f7fe ff35 	bl	1002938 <USBD_Init>
#endif
              &USR_desc,
              &USBD_CCID_cb,
              &USRD_cb);

    USB_OTG_WRITE_REG8(CORE_USB_CLEAR, 0x40);
 1003ace:	2240      	movs	r2, #64	; 0x40
 1003ad0:	4b0f      	ldr	r3, [pc, #60]	; (1003b10 <USBD_USR_DeviceReset+0x68>)
    USB_OTG_WRITE_REG8(USB_SOFCNT, 0);
    USB_OTG_WRITE_REG8(USB_SOFCNTHI, 0);

    USB_OTG_WRITE_REG8(CORE_USB_STATUS, 0xFF);
 1003ad2:	4910      	ldr	r1, [pc, #64]	; (1003b14 <USBD_USR_DeviceReset+0x6c>)
    USB_OTG_WRITE_REG8(CORE_USB_CLEAR, 0x40);
 1003ad4:	701a      	strb	r2, [r3, #0]
    USB_OTG_WRITE_REG8(USB_SOFCNT, 0);
 1003ad6:	2200      	movs	r2, #0
 1003ad8:	4b0f      	ldr	r3, [pc, #60]	; (1003b18 <USBD_USR_DeviceReset+0x70>)
 1003ada:	701a      	strb	r2, [r3, #0]
    USB_OTG_WRITE_REG8(USB_SOFCNTHI, 0);
 1003adc:	4b0f      	ldr	r3, [pc, #60]	; (1003b1c <USBD_USR_DeviceReset+0x74>)
 1003ade:	701a      	strb	r2, [r3, #0]
    USB_OTG_WRITE_REG8(CORE_USB_STATUS, 0xFF);
 1003ae0:	23ff      	movs	r3, #255	; 0xff
 1003ae2:	700b      	strb	r3, [r1, #0]
    USB_OTG_WRITE_REG8(CORE_USB_FIFO_EMPTY, 0xFF);
 1003ae4:	490e      	ldr	r1, [pc, #56]	; (1003b20 <USBD_USR_DeviceReset+0x78>)
 1003ae6:	700b      	strb	r3, [r1, #0]
    USB_OTG_WRITE_REG8(CORE_USB_ADDR, 0x00);
 1003ae8:	490e      	ldr	r1, [pc, #56]	; (1003b24 <USBD_USR_DeviceReset+0x7c>)
 1003aea:	700a      	strb	r2, [r1, #0]
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(0), 0x70);
 1003aec:	2170      	movs	r1, #112	; 0x70
 1003aee:	4a0e      	ldr	r2, [pc, #56]	; (1003b28 <USBD_USR_DeviceReset+0x80>)
 1003af0:	7011      	strb	r1, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(1), 0xf0);
 1003af2:	4a0e      	ldr	r2, [pc, #56]	; (1003b2c <USBD_USR_DeviceReset+0x84>)
 1003af4:	3180      	adds	r1, #128	; 0x80
 1003af6:	7011      	strb	r1, [r2, #0]
    USB_OTG_WRITE_REG8(CORE_USB_INT_MASK(2), 0xff);
 1003af8:	4a0d      	ldr	r2, [pc, #52]	; (1003b30 <USBD_USR_DeviceReset+0x88>)
 1003afa:	7013      	strb	r3, [r2, #0]
}
 1003afc:	bd13      	pop	{r0, r1, r4, pc}
 1003afe:	46c0      	nop			; (mov r8, r8)
 1003b00:	00021a2c 	.word	0x00021a2c
 1003b04:	000200a8 	.word	0x000200a8
 1003b08:	00020068 	.word	0x00020068
 1003b0c:	00020038 	.word	0x00020038
 1003b10:	000f6012 	.word	0x000f6012
 1003b14:	000f6026 	.word	0x000f6026
 1003b18:	000f6029 	.word	0x000f6029
 1003b1c:	000f602a 	.word	0x000f602a
 1003b20:	000f6027 	.word	0x000f6027
 1003b24:	000f6004 	.word	0x000f6004
 1003b28:	000f6001 	.word	0x000f6001
 1003b2c:	000f6002 	.word	0x000f6002
 1003b30:	000f6003 	.word	0x000f6003

01003b34 <USBD_USR_DeviceConfigured>:
 1003b34:	4770      	bx	lr

01003b36 <USBD_USR_DeviceConnected>:
 1003b36:	4770      	bx	lr

01003b38 <USBD_USR_DeviceDisconnected>:
 1003b38:	4770      	bx	lr

01003b3a <USBD_USR_DeviceSuspended>:
 1003b3a:	4770      	bx	lr

01003b3c <USBD_USR_DeviceResumed>:
 1003b3c:	4770      	bx	lr
	...

01003b40 <my_delay_ms>:
    /* Users can do their application actions here for the USB-Reset */
}


void my_delay_ms(int ms)
{
 1003b40:	b570      	push	{r4, r5, r6, lr}
 1003b42:	0004      	movs	r4, r0
    int delay_num;
    while (ms-- > 0)
    {
        delay_num = (CPU_MHZ / 1000) / 8 + 400;
 1003b44:	260f      	movs	r6, #15
 1003b46:	4d09      	ldr	r5, [pc, #36]	; (1003b6c <my_delay_ms+0x2c>)
    while (ms-- > 0)
 1003b48:	2c00      	cmp	r4, #0
 1003b4a:	dc00      	bgt.n	1003b4e <my_delay_ms+0xe>
        while (delay_num-- > 0)
        {
            __asm__("nop");
        }
    }
}
 1003b4c:	bd70      	pop	{r4, r5, r6, pc}
        delay_num = (CPU_MHZ / 1000) / 8 + 400;
 1003b4e:	6829      	ldr	r1, [r5, #0]
 1003b50:	4807      	ldr	r0, [pc, #28]	; (1003b70 <my_delay_ms+0x30>)
 1003b52:	4031      	ands	r1, r6
 1003b54:	3102      	adds	r1, #2
 1003b56:	f000 fa73 	bl	1004040 <__divsi3>
 1003b5a:	3091      	adds	r0, #145	; 0x91
 1003b5c:	30ff      	adds	r0, #255	; 0xff
        while (delay_num-- > 0)
 1003b5e:	3801      	subs	r0, #1
 1003b60:	d201      	bcs.n	1003b66 <my_delay_ms+0x26>
 1003b62:	3c01      	subs	r4, #1
 1003b64:	e7f0      	b.n	1003b48 <my_delay_ms+0x8>
            __asm__("nop");
 1003b66:	46c0      	nop			; (mov r8, r8)
 1003b68:	e7f9      	b.n	1003b5e <my_delay_ms+0x1e>
 1003b6a:	46c0      	nop			; (mov r8, r8)
 1003b6c:	000f8560 	.word	0x000f8560
 1003b70:	00005dc0 	.word	0x00005dc0

01003b74 <SC_GetDTableValue>:
                               0
                              };

uint32_t SC_GetDTableValue(uint8_t idx)
{
    return D_Table[idx];
 1003b74:	4b01      	ldr	r3, [pc, #4]	; (1003b7c <SC_GetDTableValue+0x8>)
 1003b76:	0080      	lsls	r0, r0, #2
 1003b78:	58c0      	ldr	r0, [r0, r3]
}
 1003b7a:	4770      	bx	lr
 1003b7c:	00020104 	.word	0x00020104

01003b80 <SC_InitParams>:
    over the bits b8 to b5
    - DI, the reference to a baud rate adjustment factor
    over the bits b4 to bl
    */

    SC_Param.SC_A2R_FiDi = DEFAULT_FIDI;
 1003b80:	4b06      	ldr	r3, [pc, #24]	; (1003b9c <SC_InitParams+0x1c>)
 1003b82:	4a07      	ldr	r2, [pc, #28]	; (1003ba0 <SC_InitParams+0x20>)
    /* 0 = Direct, first byte of the ICCs ATR data. */
    Protocol0_DataStructure.bmTCCKST0 = DEFAULT_T01CONVCHECKSUM;

    /* Extra GuardTime = 0 etu */
    Protocol0_DataStructure.bGuardTimeT0 = DEFAULT_EXTRA_GUARDTIME;
    Protocol0_DataStructure.bWaitingIntegerT0 = DEFAULT_WAITINGINTEGER;
 1003b84:	210a      	movs	r1, #10
    SC_Param.SC_A2R_FiDi = DEFAULT_FIDI;
 1003b86:	805a      	strh	r2, [r3, #2]
    Protocol0_DataStructure.bmFindexDindex = DEFAULT_FIDI;
 1003b88:	2211      	movs	r2, #17
 1003b8a:	4b06      	ldr	r3, [pc, #24]	; (1003ba4 <SC_InitParams+0x24>)
 1003b8c:	701a      	strb	r2, [r3, #0]
    Protocol0_DataStructure.bmTCCKST0 = DEFAULT_T01CONVCHECKSUM;
 1003b8e:	2200      	movs	r2, #0
    Protocol0_DataStructure.bWaitingIntegerT0 = DEFAULT_WAITINGINTEGER;
 1003b90:	70d9      	strb	r1, [r3, #3]
    Protocol0_DataStructure.bmTCCKST0 = DEFAULT_T01CONVCHECKSUM;
 1003b92:	705a      	strb	r2, [r3, #1]
    Protocol0_DataStructure.bGuardTimeT0 = DEFAULT_EXTRA_GUARDTIME;
 1003b94:	709a      	strb	r2, [r3, #2]
    Protocol0_DataStructure.bClockStop = 0; /* Stopping the Clock is not allowed */
 1003b96:	711a      	strb	r2, [r3, #4]
}
 1003b98:	4770      	bx	lr
 1003b9a:	46c0      	nop			; (mov r8, r8)
 1003b9c:	00021bec 	.word	0x00021bec
 1003ba0:	00001111 	.word	0x00001111
 1003ba4:	00021be6 	.word	0x00021be6

01003ba8 <SC_SetClock>:
                       and RDR_to_PC_Parameters message.*/

    if (bClockCommand == 0)
    {
        /* 00h restarts Clock : Since Clock is always running, PASS this command */
        return SLOT_NO_ERROR;
 1003ba8:	2381      	movs	r3, #129	; 0x81
    if (bClockCommand == 0)
 1003baa:	2800      	cmp	r0, #0
 1003bac:	d003      	beq.n	1003bb6 <SC_SetClock+0xe>
    }
    else if (bClockCommand == 1)
    {
        return SLOTERROR_BAD_CLOCKCOMMAND;
 1003bae:	3b7a      	subs	r3, #122	; 0x7a
    else if (bClockCommand == 1)
 1003bb0:	2801      	cmp	r0, #1
 1003bb2:	d000      	beq.n	1003bb6 <SC_SetClock+0xe>
    }

    return SLOTERROR_CMD_NOT_SUPPORTED;
 1003bb4:	2300      	movs	r3, #0
}
 1003bb6:	0018      	movs	r0, r3
 1003bb8:	4770      	bx	lr
	...

01003bbc <SC_SetParams>:
    return D_Table[idx];
 1003bbc:	230f      	movs	r3, #15
    if (guardTime > MAX_EXTRA_GUARD_TIME)
    {
        return SLOTERROR_BAD_GUARDTIME;
    }

    fi_new = pPtr->bmFindexDindex;
 1003bbe:	7802      	ldrb	r2, [r0, #0]
{
 1003bc0:	b510      	push	{r4, lr}
    return D_Table[idx];
 1003bc2:	4013      	ands	r3, r2
 1003bc4:	4c0b      	ldr	r4, [pc, #44]	; (1003bf4 <SC_SetParams+0x38>)
 1003bc6:	009b      	lsls	r3, r3, #2
    di_new = pPtr->bmFindexDindex;

    /* Check for the FIDI Value set by Host */
    di_new &= (uint8_t)0x0F;
    if (SC_GetDTableValue(di_new) == 0)
 1003bc8:	591b      	ldr	r3, [r3, r4]
{
 1003bca:	0001      	movs	r1, r0
    {
        return SLOTERROR_BAD_FIDI;
 1003bcc:	200a      	movs	r0, #10
    if (SC_GetDTableValue(di_new) == 0)
 1003bce:	2b00      	cmp	r3, #0
 1003bd0:	d00f      	beq.n	1003bf2 <SC_SetParams+0x36>
    }

    fi_new >>= 4;
 1003bd2:	0913      	lsrs	r3, r2, #4
    return D_Table[idx];
 1003bd4:	009b      	lsls	r3, r3, #2
    fi_new &= (uint8_t)0x0F;

    if (SC_GetDTableValue(fi_new) == 0)
 1003bd6:	591b      	ldr	r3, [r3, r4]
 1003bd8:	2b00      	cmp	r3, #0
 1003bda:	d00a      	beq.n	1003bf2 <SC_SetParams+0x36>
    guardTime = pPtr->bGuardTimeT0;
 1003bdc:	7888      	ldrb	r0, [r1, #2]

//  /* Put Total GuardTime in USART Settings */


    /* Save Extra GuardTime Value */
    Protocol0_DataStructure.bGuardTimeT0 = guardTime;
 1003bde:	4b06      	ldr	r3, [pc, #24]	; (1003bf8 <SC_SetParams+0x3c>)
 1003be0:	7098      	strb	r0, [r3, #2]

    Protocol0_DataStructure.bmTCCKST0 = pPtr->bmTCCKST0;
 1003be2:	7848      	ldrb	r0, [r1, #1]
 1003be4:	7058      	strb	r0, [r3, #1]
    /* Save New bmFindexDindex */
    SC_Param.SC_hostFiDi = pPtr->bmFindexDindex;

    Protocol0_DataStructure.bmFindexDindex = pPtr->bmFindexDindex;

    return SLOT_NO_ERROR;
 1003be6:	2081      	movs	r0, #129	; 0x81
    Protocol0_DataStructure.bClockStop = pPtr->bClockStop;
 1003be8:	7909      	ldrb	r1, [r1, #4]
    Protocol0_DataStructure.bmFindexDindex = pPtr->bmFindexDindex;
 1003bea:	701a      	strb	r2, [r3, #0]
    Protocol0_DataStructure.bClockStop = pPtr->bClockStop;
 1003bec:	7119      	strb	r1, [r3, #4]
    SC_Param.SC_hostFiDi = pPtr->bmFindexDindex;
 1003bee:	4903      	ldr	r1, [pc, #12]	; (1003bfc <SC_SetParams+0x40>)
 1003bf0:	70ca      	strb	r2, [r1, #3]
}
 1003bf2:	bd10      	pop	{r4, pc}
 1003bf4:	00020104 	.word	0x00020104
 1003bf8:	00021be6 	.word	0x00021be6
 1003bfc:	00021bec 	.word	0x00021bec

01003c00 <SC_XferBlock>:

uint8_t SC_XferBlock(uint8_t *ptrBlock, uint32_t blockLen, uint16_t expectedLen)
{
 1003c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    uint32_t index, i = 0;
    uint32_t cmdType = 1;
    if ((ptrBlock[0] == 0x00) && (ptrBlock[1] == 0x80))
 1003c02:	7807      	ldrb	r7, [r0, #0]
{
 1003c04:	0006      	movs	r6, r0
 1003c06:	000d      	movs	r5, r1
 1003c08:	7843      	ldrb	r3, [r0, #1]
    if ((ptrBlock[0] == 0x00) && (ptrBlock[1] == 0x80))
 1003c0a:	2f00      	cmp	r7, #0
 1003c0c:	d117      	bne.n	1003c3e <SC_XferBlock+0x3e>
 1003c0e:	2b80      	cmp	r3, #128	; 0x80
 1003c10:	d115      	bne.n	1003c3e <SC_XferBlock+0x3e>
    {
        memcpy(Ccid_bulkin_data.abData, ptrBlock + 5, blockLen - 5);
 1003c12:	1f4c      	subs	r4, r1, #5
 1003c14:	0022      	movs	r2, r4
 1003c16:	1d41      	adds	r1, r0, #5
 1003c18:	4853      	ldr	r0, [pc, #332]	; (1003d68 <SC_XferBlock+0x168>)
 1003c1a:	f000 f8e1 	bl	1003de0 <memcpy>
        Ccid_bulkin_data.dwLength = blockLen - 5;
        //memcpy(Ccid_bulkin_data.abData,COMMDATA,Ccid_bulkin_data.dwLength);
        Ccid_bulkin_data.abData[Ccid_bulkin_data.dwLength++] = 0x90;
 1003c1e:	2290      	movs	r2, #144	; 0x90
 1003c20:	4b52      	ldr	r3, [pc, #328]	; (1003d6c <SC_XferBlock+0x16c>)
 1003c22:	191c      	adds	r4, r3, r4
 1003c24:	72a2      	strb	r2, [r4, #10]
        Ccid_bulkin_data.abData[Ccid_bulkin_data.dwLength++] = 0x00;
 1003c26:	1eea      	subs	r2, r5, #3
 1003c28:	0a10      	lsrs	r0, r2, #8
 1003c2a:	705a      	strb	r2, [r3, #1]
 1003c2c:	7098      	strb	r0, [r3, #2]
 1003c2e:	195d      	adds	r5, r3, r5
 1003c30:	0c10      	lsrs	r0, r2, #16
 1003c32:	0e12      	lsrs	r2, r2, #24
 1003c34:	70d8      	strb	r0, [r3, #3]
 1003c36:	711a      	strb	r2, [r3, #4]
 1003c38:	71af      	strb	r7, [r5, #6]
            SC_Response.SW1 = 0x90;
            SC_Response.SW2 = 0x00;
            Ccid_bulkin_data.dwLength = 2;
        }
    }
    return SLOT_NO_ERROR;
 1003c3a:	2081      	movs	r0, #129	; 0x81
            Ccid_bulkin_data.dwLength = (SC_ADPU.Body.LE) + 2;
 1003c3c:	e047      	b.n	1003cce <SC_XferBlock+0xce>
        SC_ADPU.Header.CLA = ptrBlock[i++];
 1003c3e:	4c4c      	ldr	r4, [pc, #304]	; (1003d70 <SC_XferBlock+0x170>)
        SC_ADPU.Header.INS = ptrBlock[i++];
 1003c40:	7063      	strb	r3, [r4, #1]
        SC_ADPU.Header.P1 = ptrBlock[i++];
 1003c42:	78b3      	ldrb	r3, [r6, #2]
        SC_ADPU.Header.CLA = ptrBlock[i++];
 1003c44:	7027      	strb	r7, [r4, #0]
        SC_ADPU.Header.P1 = ptrBlock[i++];
 1003c46:	70a3      	strb	r3, [r4, #2]
        SC_ADPU.Header.P2 = ptrBlock[i++];
 1003c48:	78f3      	ldrb	r3, [r6, #3]
 1003c4a:	70e3      	strb	r3, [r4, #3]
        if (blockLen == 0x04)
 1003c4c:	2d04      	cmp	r5, #4
 1003c4e:	d12f      	bne.n	1003cb0 <SC_XferBlock+0xb0>
            SC_ADPU.Body.LC = 0;
 1003c50:	2300      	movs	r3, #0
 1003c52:	7123      	strb	r3, [r4, #4]
                SC_ADPU.Body.LE = ptrBlock[i];
 1003c54:	83e3      	strh	r3, [r4, #30]
            cmdType = 0x02;
 1003c56:	3d03      	subs	r5, #3
        MyPrintf("case %d\r\n", cmdType);
 1003c58:	0029      	movs	r1, r5
 1003c5a:	4846      	ldr	r0, [pc, #280]	; (1003d74 <SC_XferBlock+0x174>)
 1003c5c:	f7fc fbb2 	bl	10003c4 <MyPrintf>
        MyPrintf("lc %d\r\n", SC_ADPU.Body.LC);
 1003c60:	7921      	ldrb	r1, [r4, #4]
 1003c62:	4845      	ldr	r0, [pc, #276]	; (1003d78 <SC_XferBlock+0x178>)
 1003c64:	f7fc fbae 	bl	10003c4 <MyPrintf>
        MyPrintf("le %d\r\n", SC_ADPU.Body.LE);
 1003c68:	8be1      	ldrh	r1, [r4, #30]
 1003c6a:	4844      	ldr	r0, [pc, #272]	; (1003d7c <SC_XferBlock+0x17c>)
 1003c6c:	f7fc fbaa 	bl	10003c4 <MyPrintf>
        if (3 == cmdType || 4 == cmdType)
 1003c70:	1eeb      	subs	r3, r5, #3
 1003c72:	2b01      	cmp	r3, #1
 1003c74:	d84e      	bhi.n	1003d14 <SC_XferBlock+0x114>
            MyPrintf("Recv:\n");
 1003c76:	4842      	ldr	r0, [pc, #264]	; (1003d80 <SC_XferBlock+0x180>)
 1003c78:	f7fc fba4 	bl	10003c4 <MyPrintf>
            for (index = 5; index < SC_ADPU.Body.LC + 5; index++)
 1003c7c:	2705      	movs	r7, #5
 1003c7e:	7923      	ldrb	r3, [r4, #4]
 1003c80:	3305      	adds	r3, #5
 1003c82:	42bb      	cmp	r3, r7
 1003c84:	d83e      	bhi.n	1003d04 <SC_XferBlock+0x104>
            MyPrintf("End:\n");
 1003c86:	483f      	ldr	r0, [pc, #252]	; (1003d84 <SC_XferBlock+0x184>)
 1003c88:	f7fc fb9c 	bl	10003c4 <MyPrintf>
        if (2 == cmdType || 4 == cmdType)
 1003c8c:	2d04      	cmp	r5, #4
 1003c8e:	d043      	beq.n	1003d18 <SC_XferBlock+0x118>
        else if (1 == cmdType || 3 == cmdType)
 1003c90:	2402      	movs	r4, #2
    return SLOT_NO_ERROR;
 1003c92:	2081      	movs	r0, #129	; 0x81
        else if (1 == cmdType || 3 == cmdType)
 1003c94:	43a5      	bics	r5, r4
 1003c96:	2d01      	cmp	r5, #1
 1003c98:	d119      	bne.n	1003cce <SC_XferBlock+0xce>
            SC_Response.SW1 = 0x90;
 1003c9a:	2390      	movs	r3, #144	; 0x90
 1003c9c:	4a3a      	ldr	r2, [pc, #232]	; (1003d88 <SC_XferBlock+0x188>)
            Ccid_bulkin_data.dwLength = 2;
 1003c9e:	4933      	ldr	r1, [pc, #204]	; (1003d6c <SC_XferBlock+0x16c>)
            SC_Response.SW1 = 0x90;
 1003ca0:	7613      	strb	r3, [r2, #24]
            SC_Response.SW2 = 0x00;
 1003ca2:	2300      	movs	r3, #0
            Ccid_bulkin_data.dwLength = 2;
 1003ca4:	704c      	strb	r4, [r1, #1]
            SC_Response.SW2 = 0x00;
 1003ca6:	7653      	strb	r3, [r2, #25]
            Ccid_bulkin_data.dwLength = 2;
 1003ca8:	708b      	strb	r3, [r1, #2]
 1003caa:	70cb      	strb	r3, [r1, #3]
 1003cac:	710b      	strb	r3, [r1, #4]
 1003cae:	e00e      	b.n	1003cce <SC_XferBlock+0xce>
        else if (0x05 == blockLen)
 1003cb0:	2d05      	cmp	r5, #5
 1003cb2:	d109      	bne.n	1003cc8 <SC_XferBlock+0xc8>
            SC_ADPU.Body.LC = 0;
 1003cb4:	2300      	movs	r3, #0
 1003cb6:	7123      	strb	r3, [r4, #4]
            if (0 != ptrBlock[i])
 1003cb8:	7933      	ldrb	r3, [r6, #4]
 1003cba:	2b00      	cmp	r3, #0
 1003cbc:	d1ca      	bne.n	1003c54 <SC_XferBlock+0x54>
                SC_ADPU.Body.LE = 0x100;
 1003cbe:	2380      	movs	r3, #128	; 0x80
 1003cc0:	005b      	lsls	r3, r3, #1
 1003cc2:	83e3      	strh	r3, [r4, #30]
            cmdType = 0x02;
 1003cc4:	2502      	movs	r5, #2
 1003cc6:	e7c7      	b.n	1003c58 <SC_XferBlock+0x58>
        else if (0x05 < blockLen)
 1003cc8:	2d05      	cmp	r5, #5
 1003cca:	d801      	bhi.n	1003cd0 <SC_XferBlock+0xd0>
            return SLOTERROR_BAD_DWLENGTH;
 1003ccc:	2008      	movs	r0, #8

}
 1003cce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            SC_ADPU.Body.LC = ptrBlock[i++];
 1003cd0:	7937      	ldrb	r7, [r6, #4]
            memcpy(SC_ADPU.Body.Data, ptrBlock + i, SC_ADPU.Body.LC);
 1003cd2:	1d71      	adds	r1, r6, #5
 1003cd4:	003a      	movs	r2, r7
 1003cd6:	482d      	ldr	r0, [pc, #180]	; (1003d8c <SC_XferBlock+0x18c>)
            SC_ADPU.Body.LC = ptrBlock[i++];
 1003cd8:	7127      	strb	r7, [r4, #4]
            memcpy(SC_ADPU.Body.Data, ptrBlock + i, SC_ADPU.Body.LC);
 1003cda:	f000 f881 	bl	1003de0 <memcpy>
            i += SC_ADPU.Body.LC;
 1003cde:	1d7b      	adds	r3, r7, #5
            if (i == blockLen)
 1003ce0:	429d      	cmp	r5, r3
 1003ce2:	d103      	bne.n	1003cec <SC_XferBlock+0xec>
                SC_ADPU.Body.LE = 0;
 1003ce4:	2300      	movs	r3, #0
                cmdType = 0x03;
 1003ce6:	2503      	movs	r5, #3
                SC_ADPU.Body.LE = 0;
 1003ce8:	83e3      	strh	r3, [r4, #30]
 1003cea:	e7b5      	b.n	1003c58 <SC_XferBlock+0x58>
            else if ((i + 1) == blockLen)
 1003cec:	3706      	adds	r7, #6
 1003cee:	42af      	cmp	r7, r5
 1003cf0:	d1ec      	bne.n	1003ccc <SC_XferBlock+0xcc>
                if (0 != ptrBlock[i])
 1003cf2:	5cf3      	ldrb	r3, [r6, r3]
 1003cf4:	2b00      	cmp	r3, #0
 1003cf6:	d002      	beq.n	1003cfe <SC_XferBlock+0xfe>
                    SC_ADPU.Body.LE = 0x100;
 1003cf8:	83e3      	strh	r3, [r4, #30]
                cmdType = 0x04;
 1003cfa:	2504      	movs	r5, #4
 1003cfc:	e7ac      	b.n	1003c58 <SC_XferBlock+0x58>
                    SC_ADPU.Body.LE = 0x100;
 1003cfe:	2380      	movs	r3, #128	; 0x80
 1003d00:	005b      	lsls	r3, r3, #1
 1003d02:	e7f9      	b.n	1003cf8 <SC_XferBlock+0xf8>
                SC_ADPU.Body.Data[index] = ptrBlock[index];
 1003d04:	5df1      	ldrb	r1, [r6, r7]
 1003d06:	19e3      	adds	r3, r4, r7
 1003d08:	7159      	strb	r1, [r3, #5]
                MyPrintf("%02x ", SC_ADPU.Body.Data[index]);
 1003d0a:	4821      	ldr	r0, [pc, #132]	; (1003d90 <SC_XferBlock+0x190>)
 1003d0c:	f7fc fb5a 	bl	10003c4 <MyPrintf>
            for (index = 5; index < SC_ADPU.Body.LC + 5; index++)
 1003d10:	3701      	adds	r7, #1
 1003d12:	e7b4      	b.n	1003c7e <SC_XferBlock+0x7e>
        if (2 == cmdType || 4 == cmdType)
 1003d14:	2d02      	cmp	r5, #2
 1003d16:	d1bb      	bne.n	1003c90 <SC_XferBlock+0x90>
            SC_Response.SW1 = 0x90;
 1003d18:	2390      	movs	r3, #144	; 0x90
 1003d1a:	491b      	ldr	r1, [pc, #108]	; (1003d88 <SC_XferBlock+0x188>)
            SC_ADPU.Body.LE = 10;
 1003d1c:	220a      	movs	r2, #10
            SC_Response.SW1 = 0x90;
 1003d1e:	760b      	strb	r3, [r1, #24]
            SC_Response.SW2 = 0x00;
 1003d20:	2300      	movs	r3, #0
            SC_ADPU.Body.LE = 10;
 1003d22:	83e2      	strh	r2, [r4, #30]
            SC_Response.SW2 = 0x00;
 1003d24:	764b      	strb	r3, [r1, #25]
                SC_Response.Data[index] = index;
 1003d26:	54cb      	strb	r3, [r1, r3]
            for (index = 0; index < SC_ADPU.Body.LE; index++)
 1003d28:	3301      	adds	r3, #1
 1003d2a:	2b0a      	cmp	r3, #10
 1003d2c:	d1fb      	bne.n	1003d26 <SC_XferBlock+0x126>
            if (0x84 == SC_ADPU.Header.INS)
 1003d2e:	7860      	ldrb	r0, [r4, #1]
 1003d30:	4a0e      	ldr	r2, [pc, #56]	; (1003d6c <SC_XferBlock+0x16c>)
 1003d32:	2300      	movs	r3, #0
 1003d34:	2884      	cmp	r0, #132	; 0x84
 1003d36:	d114      	bne.n	1003d62 <SC_XferBlock+0x162>
                    Ccid_bulkin_data.abData[index] = SC_Response.Data[index];
 1003d38:	5ccd      	ldrb	r5, [r1, r3]
 1003d3a:	18d0      	adds	r0, r2, r3
                for (index = 0; index < SC_ADPU.Body.LE; index++)
 1003d3c:	3301      	adds	r3, #1
                    Ccid_bulkin_data.abData[index] = SC_Response.Data[index];
 1003d3e:	7285      	strb	r5, [r0, #10]
                for (index = 0; index < SC_ADPU.Body.LE; index++)
 1003d40:	2b0a      	cmp	r3, #10
 1003d42:	d1f9      	bne.n	1003d38 <SC_XferBlock+0x138>
            Ccid_bulkin_data.abData[index++] = SC_Response.SW1;
 1003d44:	2390      	movs	r3, #144	; 0x90
 1003d46:	7513      	strb	r3, [r2, #20]
            Ccid_bulkin_data.abData[index] = SC_Response.SW2;
 1003d48:	2300      	movs	r3, #0
 1003d4a:	7553      	strb	r3, [r2, #21]
            Ccid_bulkin_data.dwLength = (SC_ADPU.Body.LE) + 2;
 1003d4c:	8be3      	ldrh	r3, [r4, #30]
 1003d4e:	1c51      	adds	r1, r2, #1
 1003d50:	3302      	adds	r3, #2
 1003d52:	7053      	strb	r3, [r2, #1]
 1003d54:	0a1a      	lsrs	r2, r3, #8
 1003d56:	704a      	strb	r2, [r1, #1]
 1003d58:	0c1a      	lsrs	r2, r3, #16
 1003d5a:	0e1b      	lsrs	r3, r3, #24
 1003d5c:	708a      	strb	r2, [r1, #2]
 1003d5e:	70cb      	strb	r3, [r1, #3]
 1003d60:	e76b      	b.n	1003c3a <SC_XferBlock+0x3a>
                SC_ADPU.Body.LE = 0;
 1003d62:	83e3      	strh	r3, [r4, #30]
 1003d64:	e7ee      	b.n	1003d44 <SC_XferBlock+0x144>
 1003d66:	46c0      	nop			; (mov r8, r8)
 1003d68:	00021922 	.word	0x00021922
 1003d6c:	00021918 	.word	0x00021918
 1003d70:	00021bc6 	.word	0x00021bc6
 1003d74:	01005821 	.word	0x01005821
 1003d78:	0100582b 	.word	0x0100582b
 1003d7c:	01005833 	.word	0x01005833
 1003d80:	0100583b 	.word	0x0100583b
 1003d84:	01005842 	.word	0x01005842
 1003d88:	00021bac 	.word	0x00021bac
 1003d8c:	00021bcb 	.word	0x00021bcb
 1003d90:	01004259 	.word	0x01004259

01003d94 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 1003d94:	b510      	push	{r4, lr}
  UART_Configuration();
 1003d96:	f000 f80b 	bl	1003db0 <UART_Configuration>

  IpcInit();
 1003d9a:	f7fd fbbb 	bl	1001514 <IpcInit>

  MyPrintf("USB CCID Demo !\n\n");
 1003d9e:	4803      	ldr	r0, [pc, #12]	; (1003dac <main+0x18>)
 1003da0:	f7fc fb10 	bl	10003c4 <MyPrintf>

  usb_main();
 1003da4:	f7ff fdd0 	bl	1003948 <usb_main>
 1003da8:	e7fe      	b.n	1003da8 <main+0x14>
 1003daa:	46c0      	nop			; (mov r8, r8)
 1003dac:	01005848 	.word	0x01005848

01003db0 <UART_Configuration>:
  * @brief  Serial port 0 initialization function.
  * @param  None
  * @retval None
  */
void UART_Configuration(void)
{
 1003db0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  UART_InitTypeDef UART_InitStruct;

	/* Configure serial ports 0 RX and TX for IO. */
	GPIO_Config(UART0_TX_PORT, UART0_TX_PIN, UART0_TXD);
 1003db2:	2208      	movs	r2, #8
 1003db4:	2102      	movs	r1, #2
 1003db6:	2000      	movs	r0, #0
 1003db8:	f7fc fc80 	bl	10006bc <GPIO_Config>
	GPIO_Config(UART0_RX_PORT, UART0_RX_PIN, UART0_RXD);
 1003dbc:	2209      	movs	r2, #9
 1003dbe:	2101      	movs	r1, #1
 1003dc0:	2000      	movs	r0, #0
 1003dc2:	f7fc fc7b 	bl	10006bc <GPIO_Config>
  - Stop Bit = 1 Stop Bit
  - Parity = No Parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
	UART_InitStruct.BaudRate = UARTBAUD;			//Configure serial port baud rate, the baud rate defaults to 128000.
 1003dc6:	23e1      	movs	r3, #225	; 0xe1
 1003dc8:	031b      	lsls	r3, r3, #12
 1003dca:	2000      	movs	r0, #0
 1003dcc:	9301      	str	r3, [sp, #4]
	UART_InitStruct.DataBits = Databits_8b;
	UART_InitStruct.StopBits = StopBits_1;
	UART_InitStruct.Parity = Parity_None;
	UART_InitStruct.FlowCtrl = FlowCtrl_None;
	UART_InitStruct.Mode = Mode_duplex;
 1003dce:	466b      	mov	r3, sp
	
	UART_Init(UART0, &UART_InitStruct);
 1003dd0:	4669      	mov	r1, sp
	UART_InitStruct.BaudRate = UARTBAUD;			//Configure serial port baud rate, the baud rate defaults to 128000.
 1003dd2:	9002      	str	r0, [sp, #8]
	UART_InitStruct.Mode = Mode_duplex;
 1003dd4:	7018      	strb	r0, [r3, #0]
	UART_Init(UART0, &UART_InitStruct);
 1003dd6:	f7fd fcf3 	bl	10017c0 <UART_Init>
}
 1003dda:	b005      	add	sp, #20
 1003ddc:	bd00      	pop	{pc}
	...

01003de0 <memcpy>:
 1003de0:	b5f0      	push	{r4, r5, r6, r7, lr}
 1003de2:	2a0f      	cmp	r2, #15
 1003de4:	d937      	bls.n	1003e56 <memcpy+0x76>
 1003de6:	000d      	movs	r5, r1
 1003de8:	4305      	orrs	r5, r0
 1003dea:	000c      	movs	r4, r1
 1003dec:	0003      	movs	r3, r0
 1003dee:	07ad      	lsls	r5, r5, #30
 1003df0:	d135      	bne.n	1003e5e <memcpy+0x7e>
 1003df2:	0015      	movs	r5, r2
 1003df4:	3d10      	subs	r5, #16
 1003df6:	092d      	lsrs	r5, r5, #4
 1003df8:	012e      	lsls	r6, r5, #4
 1003dfa:	1836      	adds	r6, r6, r0
 1003dfc:	3610      	adds	r6, #16
 1003dfe:	6827      	ldr	r7, [r4, #0]
 1003e00:	601f      	str	r7, [r3, #0]
 1003e02:	6867      	ldr	r7, [r4, #4]
 1003e04:	605f      	str	r7, [r3, #4]
 1003e06:	68a7      	ldr	r7, [r4, #8]
 1003e08:	609f      	str	r7, [r3, #8]
 1003e0a:	68e7      	ldr	r7, [r4, #12]
 1003e0c:	3410      	adds	r4, #16
 1003e0e:	60df      	str	r7, [r3, #12]
 1003e10:	3310      	adds	r3, #16
 1003e12:	42b3      	cmp	r3, r6
 1003e14:	d1f3      	bne.n	1003dfe <memcpy+0x1e>
 1003e16:	240f      	movs	r4, #15
 1003e18:	3501      	adds	r5, #1
 1003e1a:	012d      	lsls	r5, r5, #4
 1003e1c:	1949      	adds	r1, r1, r5
 1003e1e:	4014      	ands	r4, r2
 1003e20:	1945      	adds	r5, r0, r5
 1003e22:	2c03      	cmp	r4, #3
 1003e24:	d91d      	bls.n	1003e62 <memcpy+0x82>
 1003e26:	2300      	movs	r3, #0
 1003e28:	58ce      	ldr	r6, [r1, r3]
 1003e2a:	50ee      	str	r6, [r5, r3]
 1003e2c:	3304      	adds	r3, #4
 1003e2e:	1ae6      	subs	r6, r4, r3
 1003e30:	2e03      	cmp	r6, #3
 1003e32:	d8f9      	bhi.n	1003e28 <memcpy+0x48>
 1003e34:	2303      	movs	r3, #3
 1003e36:	3c04      	subs	r4, #4
 1003e38:	08a4      	lsrs	r4, r4, #2
 1003e3a:	3401      	adds	r4, #1
 1003e3c:	00a4      	lsls	r4, r4, #2
 1003e3e:	401a      	ands	r2, r3
 1003e40:	192d      	adds	r5, r5, r4
 1003e42:	1909      	adds	r1, r1, r4
 1003e44:	2a00      	cmp	r2, #0
 1003e46:	d005      	beq.n	1003e54 <memcpy+0x74>
 1003e48:	2300      	movs	r3, #0
 1003e4a:	5ccc      	ldrb	r4, [r1, r3]
 1003e4c:	54ec      	strb	r4, [r5, r3]
 1003e4e:	3301      	adds	r3, #1
 1003e50:	4293      	cmp	r3, r2
 1003e52:	d1fa      	bne.n	1003e4a <memcpy+0x6a>
 1003e54:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1003e56:	0005      	movs	r5, r0
 1003e58:	2a00      	cmp	r2, #0
 1003e5a:	d1f5      	bne.n	1003e48 <memcpy+0x68>
 1003e5c:	e7fa      	b.n	1003e54 <memcpy+0x74>
 1003e5e:	0005      	movs	r5, r0
 1003e60:	e7f2      	b.n	1003e48 <memcpy+0x68>
 1003e62:	0022      	movs	r2, r4
 1003e64:	e7f8      	b.n	1003e58 <memcpy+0x78>
 1003e66:	46c0      	nop			; (mov r8, r8)

01003e68 <memset>:
 1003e68:	b5f0      	push	{r4, r5, r6, r7, lr}
 1003e6a:	0783      	lsls	r3, r0, #30
 1003e6c:	d046      	beq.n	1003efc <memset+0x94>
 1003e6e:	1e54      	subs	r4, r2, #1
 1003e70:	2a00      	cmp	r2, #0
 1003e72:	d042      	beq.n	1003efa <memset+0x92>
 1003e74:	b2ce      	uxtb	r6, r1
 1003e76:	0002      	movs	r2, r0
 1003e78:	2503      	movs	r5, #3
 1003e7a:	e002      	b.n	1003e82 <memset+0x1a>
 1003e7c:	001a      	movs	r2, r3
 1003e7e:	3c01      	subs	r4, #1
 1003e80:	d33b      	bcc.n	1003efa <memset+0x92>
 1003e82:	1c53      	adds	r3, r2, #1
 1003e84:	7016      	strb	r6, [r2, #0]
 1003e86:	422b      	tst	r3, r5
 1003e88:	d1f8      	bne.n	1003e7c <memset+0x14>
 1003e8a:	2c03      	cmp	r4, #3
 1003e8c:	d92d      	bls.n	1003eea <memset+0x82>
 1003e8e:	22ff      	movs	r2, #255	; 0xff
 1003e90:	400a      	ands	r2, r1
 1003e92:	0215      	lsls	r5, r2, #8
 1003e94:	4315      	orrs	r5, r2
 1003e96:	042a      	lsls	r2, r5, #16
 1003e98:	4315      	orrs	r5, r2
 1003e9a:	2c0f      	cmp	r4, #15
 1003e9c:	d916      	bls.n	1003ecc <memset+0x64>
 1003e9e:	0027      	movs	r7, r4
 1003ea0:	3f10      	subs	r7, #16
 1003ea2:	093f      	lsrs	r7, r7, #4
 1003ea4:	013e      	lsls	r6, r7, #4
 1003ea6:	46b4      	mov	ip, r6
 1003ea8:	001e      	movs	r6, r3
 1003eaa:	001a      	movs	r2, r3
 1003eac:	3610      	adds	r6, #16
 1003eae:	4466      	add	r6, ip
 1003eb0:	6015      	str	r5, [r2, #0]
 1003eb2:	6055      	str	r5, [r2, #4]
 1003eb4:	6095      	str	r5, [r2, #8]
 1003eb6:	60d5      	str	r5, [r2, #12]
 1003eb8:	3210      	adds	r2, #16
 1003eba:	42b2      	cmp	r2, r6
 1003ebc:	d1f8      	bne.n	1003eb0 <memset+0x48>
 1003ebe:	220f      	movs	r2, #15
 1003ec0:	3701      	adds	r7, #1
 1003ec2:	013f      	lsls	r7, r7, #4
 1003ec4:	19db      	adds	r3, r3, r7
 1003ec6:	4014      	ands	r4, r2
 1003ec8:	2c03      	cmp	r4, #3
 1003eca:	d90e      	bls.n	1003eea <memset+0x82>
 1003ecc:	1f26      	subs	r6, r4, #4
 1003ece:	08b6      	lsrs	r6, r6, #2
 1003ed0:	00b7      	lsls	r7, r6, #2
 1003ed2:	46bc      	mov	ip, r7
 1003ed4:	001a      	movs	r2, r3
 1003ed6:	1d1f      	adds	r7, r3, #4
 1003ed8:	4467      	add	r7, ip
 1003eda:	c220      	stmia	r2!, {r5}
 1003edc:	42ba      	cmp	r2, r7
 1003ede:	d1fc      	bne.n	1003eda <memset+0x72>
 1003ee0:	2203      	movs	r2, #3
 1003ee2:	3601      	adds	r6, #1
 1003ee4:	00b6      	lsls	r6, r6, #2
 1003ee6:	199b      	adds	r3, r3, r6
 1003ee8:	4014      	ands	r4, r2
 1003eea:	2c00      	cmp	r4, #0
 1003eec:	d005      	beq.n	1003efa <memset+0x92>
 1003eee:	b2c9      	uxtb	r1, r1
 1003ef0:	191c      	adds	r4, r3, r4
 1003ef2:	7019      	strb	r1, [r3, #0]
 1003ef4:	3301      	adds	r3, #1
 1003ef6:	429c      	cmp	r4, r3
 1003ef8:	d1fb      	bne.n	1003ef2 <memset+0x8a>
 1003efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1003efc:	0014      	movs	r4, r2
 1003efe:	0003      	movs	r3, r0
 1003f00:	e7c3      	b.n	1003e8a <memset+0x22>
 1003f02:	46c0      	nop			; (mov r8, r8)

01003f04 <__gnu_thumb1_case_uqi>:
 1003f04:	b402      	push	{r1}
 1003f06:	4671      	mov	r1, lr
 1003f08:	0849      	lsrs	r1, r1, #1
 1003f0a:	0049      	lsls	r1, r1, #1
 1003f0c:	5c09      	ldrb	r1, [r1, r0]
 1003f0e:	0049      	lsls	r1, r1, #1
 1003f10:	448e      	add	lr, r1
 1003f12:	bc02      	pop	{r1}
 1003f14:	4770      	bx	lr
 1003f16:	46c0      	nop			; (mov r8, r8)

01003f18 <__gnu_thumb1_case_uhi>:
 1003f18:	b403      	push	{r0, r1}
 1003f1a:	4671      	mov	r1, lr
 1003f1c:	0849      	lsrs	r1, r1, #1
 1003f1e:	0040      	lsls	r0, r0, #1
 1003f20:	0049      	lsls	r1, r1, #1
 1003f22:	5a09      	ldrh	r1, [r1, r0]
 1003f24:	0049      	lsls	r1, r1, #1
 1003f26:	448e      	add	lr, r1
 1003f28:	bc03      	pop	{r0, r1}
 1003f2a:	4770      	bx	lr

01003f2c <__udivsi3>:
 1003f2c:	2200      	movs	r2, #0
 1003f2e:	0843      	lsrs	r3, r0, #1
 1003f30:	428b      	cmp	r3, r1
 1003f32:	d374      	bcc.n	100401e <__udivsi3+0xf2>
 1003f34:	0903      	lsrs	r3, r0, #4
 1003f36:	428b      	cmp	r3, r1
 1003f38:	d35f      	bcc.n	1003ffa <__udivsi3+0xce>
 1003f3a:	0a03      	lsrs	r3, r0, #8
 1003f3c:	428b      	cmp	r3, r1
 1003f3e:	d344      	bcc.n	1003fca <__udivsi3+0x9e>
 1003f40:	0b03      	lsrs	r3, r0, #12
 1003f42:	428b      	cmp	r3, r1
 1003f44:	d328      	bcc.n	1003f98 <__udivsi3+0x6c>
 1003f46:	0c03      	lsrs	r3, r0, #16
 1003f48:	428b      	cmp	r3, r1
 1003f4a:	d30d      	bcc.n	1003f68 <__udivsi3+0x3c>
 1003f4c:	22ff      	movs	r2, #255	; 0xff
 1003f4e:	0209      	lsls	r1, r1, #8
 1003f50:	ba12      	rev	r2, r2
 1003f52:	0c03      	lsrs	r3, r0, #16
 1003f54:	428b      	cmp	r3, r1
 1003f56:	d302      	bcc.n	1003f5e <__udivsi3+0x32>
 1003f58:	1212      	asrs	r2, r2, #8
 1003f5a:	0209      	lsls	r1, r1, #8
 1003f5c:	d065      	beq.n	100402a <__udivsi3+0xfe>
 1003f5e:	0b03      	lsrs	r3, r0, #12
 1003f60:	428b      	cmp	r3, r1
 1003f62:	d319      	bcc.n	1003f98 <__udivsi3+0x6c>
 1003f64:	e000      	b.n	1003f68 <__udivsi3+0x3c>
 1003f66:	0a09      	lsrs	r1, r1, #8
 1003f68:	0bc3      	lsrs	r3, r0, #15
 1003f6a:	428b      	cmp	r3, r1
 1003f6c:	d301      	bcc.n	1003f72 <__udivsi3+0x46>
 1003f6e:	03cb      	lsls	r3, r1, #15
 1003f70:	1ac0      	subs	r0, r0, r3
 1003f72:	4152      	adcs	r2, r2
 1003f74:	0b83      	lsrs	r3, r0, #14
 1003f76:	428b      	cmp	r3, r1
 1003f78:	d301      	bcc.n	1003f7e <__udivsi3+0x52>
 1003f7a:	038b      	lsls	r3, r1, #14
 1003f7c:	1ac0      	subs	r0, r0, r3
 1003f7e:	4152      	adcs	r2, r2
 1003f80:	0b43      	lsrs	r3, r0, #13
 1003f82:	428b      	cmp	r3, r1
 1003f84:	d301      	bcc.n	1003f8a <__udivsi3+0x5e>
 1003f86:	034b      	lsls	r3, r1, #13
 1003f88:	1ac0      	subs	r0, r0, r3
 1003f8a:	4152      	adcs	r2, r2
 1003f8c:	0b03      	lsrs	r3, r0, #12
 1003f8e:	428b      	cmp	r3, r1
 1003f90:	d301      	bcc.n	1003f96 <__udivsi3+0x6a>
 1003f92:	030b      	lsls	r3, r1, #12
 1003f94:	1ac0      	subs	r0, r0, r3
 1003f96:	4152      	adcs	r2, r2
 1003f98:	0ac3      	lsrs	r3, r0, #11
 1003f9a:	428b      	cmp	r3, r1
 1003f9c:	d301      	bcc.n	1003fa2 <__udivsi3+0x76>
 1003f9e:	02cb      	lsls	r3, r1, #11
 1003fa0:	1ac0      	subs	r0, r0, r3
 1003fa2:	4152      	adcs	r2, r2
 1003fa4:	0a83      	lsrs	r3, r0, #10
 1003fa6:	428b      	cmp	r3, r1
 1003fa8:	d301      	bcc.n	1003fae <__udivsi3+0x82>
 1003faa:	028b      	lsls	r3, r1, #10
 1003fac:	1ac0      	subs	r0, r0, r3
 1003fae:	4152      	adcs	r2, r2
 1003fb0:	0a43      	lsrs	r3, r0, #9
 1003fb2:	428b      	cmp	r3, r1
 1003fb4:	d301      	bcc.n	1003fba <__udivsi3+0x8e>
 1003fb6:	024b      	lsls	r3, r1, #9
 1003fb8:	1ac0      	subs	r0, r0, r3
 1003fba:	4152      	adcs	r2, r2
 1003fbc:	0a03      	lsrs	r3, r0, #8
 1003fbe:	428b      	cmp	r3, r1
 1003fc0:	d301      	bcc.n	1003fc6 <__udivsi3+0x9a>
 1003fc2:	020b      	lsls	r3, r1, #8
 1003fc4:	1ac0      	subs	r0, r0, r3
 1003fc6:	4152      	adcs	r2, r2
 1003fc8:	d2cd      	bcs.n	1003f66 <__udivsi3+0x3a>
 1003fca:	09c3      	lsrs	r3, r0, #7
 1003fcc:	428b      	cmp	r3, r1
 1003fce:	d301      	bcc.n	1003fd4 <__udivsi3+0xa8>
 1003fd0:	01cb      	lsls	r3, r1, #7
 1003fd2:	1ac0      	subs	r0, r0, r3
 1003fd4:	4152      	adcs	r2, r2
 1003fd6:	0983      	lsrs	r3, r0, #6
 1003fd8:	428b      	cmp	r3, r1
 1003fda:	d301      	bcc.n	1003fe0 <__udivsi3+0xb4>
 1003fdc:	018b      	lsls	r3, r1, #6
 1003fde:	1ac0      	subs	r0, r0, r3
 1003fe0:	4152      	adcs	r2, r2
 1003fe2:	0943      	lsrs	r3, r0, #5
 1003fe4:	428b      	cmp	r3, r1
 1003fe6:	d301      	bcc.n	1003fec <__udivsi3+0xc0>
 1003fe8:	014b      	lsls	r3, r1, #5
 1003fea:	1ac0      	subs	r0, r0, r3
 1003fec:	4152      	adcs	r2, r2
 1003fee:	0903      	lsrs	r3, r0, #4
 1003ff0:	428b      	cmp	r3, r1
 1003ff2:	d301      	bcc.n	1003ff8 <__udivsi3+0xcc>
 1003ff4:	010b      	lsls	r3, r1, #4
 1003ff6:	1ac0      	subs	r0, r0, r3
 1003ff8:	4152      	adcs	r2, r2
 1003ffa:	08c3      	lsrs	r3, r0, #3
 1003ffc:	428b      	cmp	r3, r1
 1003ffe:	d301      	bcc.n	1004004 <__udivsi3+0xd8>
 1004000:	00cb      	lsls	r3, r1, #3
 1004002:	1ac0      	subs	r0, r0, r3
 1004004:	4152      	adcs	r2, r2
 1004006:	0883      	lsrs	r3, r0, #2
 1004008:	428b      	cmp	r3, r1
 100400a:	d301      	bcc.n	1004010 <__udivsi3+0xe4>
 100400c:	008b      	lsls	r3, r1, #2
 100400e:	1ac0      	subs	r0, r0, r3
 1004010:	4152      	adcs	r2, r2
 1004012:	0843      	lsrs	r3, r0, #1
 1004014:	428b      	cmp	r3, r1
 1004016:	d301      	bcc.n	100401c <__udivsi3+0xf0>
 1004018:	004b      	lsls	r3, r1, #1
 100401a:	1ac0      	subs	r0, r0, r3
 100401c:	4152      	adcs	r2, r2
 100401e:	1a41      	subs	r1, r0, r1
 1004020:	d200      	bcs.n	1004024 <__udivsi3+0xf8>
 1004022:	4601      	mov	r1, r0
 1004024:	4152      	adcs	r2, r2
 1004026:	4610      	mov	r0, r2
 1004028:	4770      	bx	lr
 100402a:	e7ff      	b.n	100402c <__udivsi3+0x100>
 100402c:	b501      	push	{r0, lr}
 100402e:	2000      	movs	r0, #0
 1004030:	f000 f8f0 	bl	1004214 <__aeabi_idiv0>
 1004034:	bd02      	pop	{r1, pc}
 1004036:	46c0      	nop			; (mov r8, r8)

01004038 <__aeabi_uidivmod>:
 1004038:	2900      	cmp	r1, #0
 100403a:	d0f7      	beq.n	100402c <__udivsi3+0x100>
 100403c:	e776      	b.n	1003f2c <__udivsi3>
 100403e:	4770      	bx	lr

01004040 <__divsi3>:
 1004040:	4603      	mov	r3, r0
 1004042:	430b      	orrs	r3, r1
 1004044:	d47f      	bmi.n	1004146 <__divsi3+0x106>
 1004046:	2200      	movs	r2, #0
 1004048:	0843      	lsrs	r3, r0, #1
 100404a:	428b      	cmp	r3, r1
 100404c:	d374      	bcc.n	1004138 <__divsi3+0xf8>
 100404e:	0903      	lsrs	r3, r0, #4
 1004050:	428b      	cmp	r3, r1
 1004052:	d35f      	bcc.n	1004114 <__divsi3+0xd4>
 1004054:	0a03      	lsrs	r3, r0, #8
 1004056:	428b      	cmp	r3, r1
 1004058:	d344      	bcc.n	10040e4 <__divsi3+0xa4>
 100405a:	0b03      	lsrs	r3, r0, #12
 100405c:	428b      	cmp	r3, r1
 100405e:	d328      	bcc.n	10040b2 <__divsi3+0x72>
 1004060:	0c03      	lsrs	r3, r0, #16
 1004062:	428b      	cmp	r3, r1
 1004064:	d30d      	bcc.n	1004082 <__divsi3+0x42>
 1004066:	22ff      	movs	r2, #255	; 0xff
 1004068:	0209      	lsls	r1, r1, #8
 100406a:	ba12      	rev	r2, r2
 100406c:	0c03      	lsrs	r3, r0, #16
 100406e:	428b      	cmp	r3, r1
 1004070:	d302      	bcc.n	1004078 <__divsi3+0x38>
 1004072:	1212      	asrs	r2, r2, #8
 1004074:	0209      	lsls	r1, r1, #8
 1004076:	d065      	beq.n	1004144 <__divsi3+0x104>
 1004078:	0b03      	lsrs	r3, r0, #12
 100407a:	428b      	cmp	r3, r1
 100407c:	d319      	bcc.n	10040b2 <__divsi3+0x72>
 100407e:	e000      	b.n	1004082 <__divsi3+0x42>
 1004080:	0a09      	lsrs	r1, r1, #8
 1004082:	0bc3      	lsrs	r3, r0, #15
 1004084:	428b      	cmp	r3, r1
 1004086:	d301      	bcc.n	100408c <__divsi3+0x4c>
 1004088:	03cb      	lsls	r3, r1, #15
 100408a:	1ac0      	subs	r0, r0, r3
 100408c:	4152      	adcs	r2, r2
 100408e:	0b83      	lsrs	r3, r0, #14
 1004090:	428b      	cmp	r3, r1
 1004092:	d301      	bcc.n	1004098 <__divsi3+0x58>
 1004094:	038b      	lsls	r3, r1, #14
 1004096:	1ac0      	subs	r0, r0, r3
 1004098:	4152      	adcs	r2, r2
 100409a:	0b43      	lsrs	r3, r0, #13
 100409c:	428b      	cmp	r3, r1
 100409e:	d301      	bcc.n	10040a4 <__divsi3+0x64>
 10040a0:	034b      	lsls	r3, r1, #13
 10040a2:	1ac0      	subs	r0, r0, r3
 10040a4:	4152      	adcs	r2, r2
 10040a6:	0b03      	lsrs	r3, r0, #12
 10040a8:	428b      	cmp	r3, r1
 10040aa:	d301      	bcc.n	10040b0 <__divsi3+0x70>
 10040ac:	030b      	lsls	r3, r1, #12
 10040ae:	1ac0      	subs	r0, r0, r3
 10040b0:	4152      	adcs	r2, r2
 10040b2:	0ac3      	lsrs	r3, r0, #11
 10040b4:	428b      	cmp	r3, r1
 10040b6:	d301      	bcc.n	10040bc <__divsi3+0x7c>
 10040b8:	02cb      	lsls	r3, r1, #11
 10040ba:	1ac0      	subs	r0, r0, r3
 10040bc:	4152      	adcs	r2, r2
 10040be:	0a83      	lsrs	r3, r0, #10
 10040c0:	428b      	cmp	r3, r1
 10040c2:	d301      	bcc.n	10040c8 <__divsi3+0x88>
 10040c4:	028b      	lsls	r3, r1, #10
 10040c6:	1ac0      	subs	r0, r0, r3
 10040c8:	4152      	adcs	r2, r2
 10040ca:	0a43      	lsrs	r3, r0, #9
 10040cc:	428b      	cmp	r3, r1
 10040ce:	d301      	bcc.n	10040d4 <__divsi3+0x94>
 10040d0:	024b      	lsls	r3, r1, #9
 10040d2:	1ac0      	subs	r0, r0, r3
 10040d4:	4152      	adcs	r2, r2
 10040d6:	0a03      	lsrs	r3, r0, #8
 10040d8:	428b      	cmp	r3, r1
 10040da:	d301      	bcc.n	10040e0 <__divsi3+0xa0>
 10040dc:	020b      	lsls	r3, r1, #8
 10040de:	1ac0      	subs	r0, r0, r3
 10040e0:	4152      	adcs	r2, r2
 10040e2:	d2cd      	bcs.n	1004080 <__divsi3+0x40>
 10040e4:	09c3      	lsrs	r3, r0, #7
 10040e6:	428b      	cmp	r3, r1
 10040e8:	d301      	bcc.n	10040ee <__divsi3+0xae>
 10040ea:	01cb      	lsls	r3, r1, #7
 10040ec:	1ac0      	subs	r0, r0, r3
 10040ee:	4152      	adcs	r2, r2
 10040f0:	0983      	lsrs	r3, r0, #6
 10040f2:	428b      	cmp	r3, r1
 10040f4:	d301      	bcc.n	10040fa <__divsi3+0xba>
 10040f6:	018b      	lsls	r3, r1, #6
 10040f8:	1ac0      	subs	r0, r0, r3
 10040fa:	4152      	adcs	r2, r2
 10040fc:	0943      	lsrs	r3, r0, #5
 10040fe:	428b      	cmp	r3, r1
 1004100:	d301      	bcc.n	1004106 <__divsi3+0xc6>
 1004102:	014b      	lsls	r3, r1, #5
 1004104:	1ac0      	subs	r0, r0, r3
 1004106:	4152      	adcs	r2, r2
 1004108:	0903      	lsrs	r3, r0, #4
 100410a:	428b      	cmp	r3, r1
 100410c:	d301      	bcc.n	1004112 <__divsi3+0xd2>
 100410e:	010b      	lsls	r3, r1, #4
 1004110:	1ac0      	subs	r0, r0, r3
 1004112:	4152      	adcs	r2, r2
 1004114:	08c3      	lsrs	r3, r0, #3
 1004116:	428b      	cmp	r3, r1
 1004118:	d301      	bcc.n	100411e <__divsi3+0xde>
 100411a:	00cb      	lsls	r3, r1, #3
 100411c:	1ac0      	subs	r0, r0, r3
 100411e:	4152      	adcs	r2, r2
 1004120:	0883      	lsrs	r3, r0, #2
 1004122:	428b      	cmp	r3, r1
 1004124:	d301      	bcc.n	100412a <__divsi3+0xea>
 1004126:	008b      	lsls	r3, r1, #2
 1004128:	1ac0      	subs	r0, r0, r3
 100412a:	4152      	adcs	r2, r2
 100412c:	0843      	lsrs	r3, r0, #1
 100412e:	428b      	cmp	r3, r1
 1004130:	d301      	bcc.n	1004136 <__divsi3+0xf6>
 1004132:	004b      	lsls	r3, r1, #1
 1004134:	1ac0      	subs	r0, r0, r3
 1004136:	4152      	adcs	r2, r2
 1004138:	1a41      	subs	r1, r0, r1
 100413a:	d200      	bcs.n	100413e <__divsi3+0xfe>
 100413c:	4601      	mov	r1, r0
 100413e:	4152      	adcs	r2, r2
 1004140:	4610      	mov	r0, r2
 1004142:	4770      	bx	lr
 1004144:	e05d      	b.n	1004202 <__divsi3+0x1c2>
 1004146:	0fca      	lsrs	r2, r1, #31
 1004148:	d000      	beq.n	100414c <__divsi3+0x10c>
 100414a:	4249      	negs	r1, r1
 100414c:	1003      	asrs	r3, r0, #32
 100414e:	d300      	bcc.n	1004152 <__divsi3+0x112>
 1004150:	4240      	negs	r0, r0
 1004152:	4053      	eors	r3, r2
 1004154:	2200      	movs	r2, #0
 1004156:	469c      	mov	ip, r3
 1004158:	0903      	lsrs	r3, r0, #4
 100415a:	428b      	cmp	r3, r1
 100415c:	d32d      	bcc.n	10041ba <__divsi3+0x17a>
 100415e:	0a03      	lsrs	r3, r0, #8
 1004160:	428b      	cmp	r3, r1
 1004162:	d312      	bcc.n	100418a <__divsi3+0x14a>
 1004164:	22fc      	movs	r2, #252	; 0xfc
 1004166:	0189      	lsls	r1, r1, #6
 1004168:	ba12      	rev	r2, r2
 100416a:	0a03      	lsrs	r3, r0, #8
 100416c:	428b      	cmp	r3, r1
 100416e:	d30c      	bcc.n	100418a <__divsi3+0x14a>
 1004170:	0189      	lsls	r1, r1, #6
 1004172:	1192      	asrs	r2, r2, #6
 1004174:	428b      	cmp	r3, r1
 1004176:	d308      	bcc.n	100418a <__divsi3+0x14a>
 1004178:	0189      	lsls	r1, r1, #6
 100417a:	1192      	asrs	r2, r2, #6
 100417c:	428b      	cmp	r3, r1
 100417e:	d304      	bcc.n	100418a <__divsi3+0x14a>
 1004180:	0189      	lsls	r1, r1, #6
 1004182:	d03a      	beq.n	10041fa <__divsi3+0x1ba>
 1004184:	1192      	asrs	r2, r2, #6
 1004186:	e000      	b.n	100418a <__divsi3+0x14a>
 1004188:	0989      	lsrs	r1, r1, #6
 100418a:	09c3      	lsrs	r3, r0, #7
 100418c:	428b      	cmp	r3, r1
 100418e:	d301      	bcc.n	1004194 <__divsi3+0x154>
 1004190:	01cb      	lsls	r3, r1, #7
 1004192:	1ac0      	subs	r0, r0, r3
 1004194:	4152      	adcs	r2, r2
 1004196:	0983      	lsrs	r3, r0, #6
 1004198:	428b      	cmp	r3, r1
 100419a:	d301      	bcc.n	10041a0 <__divsi3+0x160>
 100419c:	018b      	lsls	r3, r1, #6
 100419e:	1ac0      	subs	r0, r0, r3
 10041a0:	4152      	adcs	r2, r2
 10041a2:	0943      	lsrs	r3, r0, #5
 10041a4:	428b      	cmp	r3, r1
 10041a6:	d301      	bcc.n	10041ac <__divsi3+0x16c>
 10041a8:	014b      	lsls	r3, r1, #5
 10041aa:	1ac0      	subs	r0, r0, r3
 10041ac:	4152      	adcs	r2, r2
 10041ae:	0903      	lsrs	r3, r0, #4
 10041b0:	428b      	cmp	r3, r1
 10041b2:	d301      	bcc.n	10041b8 <__divsi3+0x178>
 10041b4:	010b      	lsls	r3, r1, #4
 10041b6:	1ac0      	subs	r0, r0, r3
 10041b8:	4152      	adcs	r2, r2
 10041ba:	08c3      	lsrs	r3, r0, #3
 10041bc:	428b      	cmp	r3, r1
 10041be:	d301      	bcc.n	10041c4 <__divsi3+0x184>
 10041c0:	00cb      	lsls	r3, r1, #3
 10041c2:	1ac0      	subs	r0, r0, r3
 10041c4:	4152      	adcs	r2, r2
 10041c6:	0883      	lsrs	r3, r0, #2
 10041c8:	428b      	cmp	r3, r1
 10041ca:	d301      	bcc.n	10041d0 <__divsi3+0x190>
 10041cc:	008b      	lsls	r3, r1, #2
 10041ce:	1ac0      	subs	r0, r0, r3
 10041d0:	4152      	adcs	r2, r2
 10041d2:	d2d9      	bcs.n	1004188 <__divsi3+0x148>
 10041d4:	0843      	lsrs	r3, r0, #1
 10041d6:	428b      	cmp	r3, r1
 10041d8:	d301      	bcc.n	10041de <__divsi3+0x19e>
 10041da:	004b      	lsls	r3, r1, #1
 10041dc:	1ac0      	subs	r0, r0, r3
 10041de:	4152      	adcs	r2, r2
 10041e0:	1a41      	subs	r1, r0, r1
 10041e2:	d200      	bcs.n	10041e6 <__divsi3+0x1a6>
 10041e4:	4601      	mov	r1, r0
 10041e6:	4663      	mov	r3, ip
 10041e8:	4152      	adcs	r2, r2
 10041ea:	105b      	asrs	r3, r3, #1
 10041ec:	4610      	mov	r0, r2
 10041ee:	d301      	bcc.n	10041f4 <__divsi3+0x1b4>
 10041f0:	4240      	negs	r0, r0
 10041f2:	2b00      	cmp	r3, #0
 10041f4:	d500      	bpl.n	10041f8 <__divsi3+0x1b8>
 10041f6:	4249      	negs	r1, r1
 10041f8:	4770      	bx	lr
 10041fa:	4663      	mov	r3, ip
 10041fc:	105b      	asrs	r3, r3, #1
 10041fe:	d300      	bcc.n	1004202 <__divsi3+0x1c2>
 1004200:	4240      	negs	r0, r0
 1004202:	b501      	push	{r0, lr}
 1004204:	2000      	movs	r0, #0
 1004206:	f000 f805 	bl	1004214 <__aeabi_idiv0>
 100420a:	bd02      	pop	{r1, pc}

0100420c <__aeabi_idivmod>:
 100420c:	2900      	cmp	r1, #0
 100420e:	d0f8      	beq.n	1004202 <__divsi3+0x1c2>
 1004210:	e716      	b.n	1004040 <__divsi3>
 1004212:	4770      	bx	lr

01004214 <__aeabi_idiv0>:
 1004214:	4770      	bx	lr
 1004216:	46c0      	nop			; (mov r8, r8)
 1004218:	33323130 	.word	0x33323130
 100421c:	37363534 	.word	0x37363534
 1004220:	62613938 	.word	0x62613938
 1004224:	66656463 	.word	0x66656463
 1004228:	32313000 	.word	0x32313000
 100422c:	36353433 	.word	0x36353433
 1004230:	41393837 	.word	0x41393837
 1004234:	45444342 	.word	0x45444342
 1004238:	00000046 	.word	0x00000046

0100423c <g_pcHex1>:
 100423c:	01004218                                .B..

01004240 <g_pcHex2>:
 1004240:	01004229 4f525245 0a0d0052 3a732520     )B..ERROR... %s:
 1004250:	250a0d00 3a783830 32302500               ...%08x:.%02x .

0100425f <bt_code>:
 100425f:	55aa0200 84c20bf6 00c00e00 42c03c80     ...U.........<.B
 100426f:	44c04280 4ac06380 51c02200 51c06c00     .B.D.c.J.".Q.l.Q
 100427f:	54c02d80 56c03080 5cc07300 5dc07400     .-.T.0.V.s.\.t.]
 100428f:	5ec0b380 75c00e01 20202f81 01c08b4a     ...^...u./  J...
 100429f:	02c03981 03c04581 03c04e01 04c05381     .9...E...N...S..
 10042af:	05c05c01 09c06d81 0ac07d81 0ec00202     .\...m...}......
 10042bf:	0fc01502 0fc03e02 10c06c82 19c0a082     .....>...l......
 10042cf:	1dc0af02 1fc0c202 20c0cd02 29c0df82     ........... ...)
 10042df:	46c0e502 4cc05382 2020f982 42188b4a     ...F.S.L..  J..B
 10042ef:	4020007e 301c2b7d 2079007e 40202c7e     ~. @}+.0~.y ~, @
 10042ff:	3f79147d 40202cfe 4020764a 7420147d     }.y?., @Jv @}. t
 100430f:	40200000 20203900 421b2f4a 4020007e     .. @.9  J/.B~. @
 100431f:	20203800 e46fe94a e31f4e40 4020007e     .8  J.o.@N..~. @
 100432f:	021e2b7d 4020007e 421b147d 40200004     }+..~. @}..B.. @
 100433f:	20203800 4020674b 0098147d 3f79000c     .8  Kg @}.....y?
 100434f:	2020108c 40201f7d 4020c468 4020d760     ..  }. @h. @`. @
 100435f:	20204000 75200a40 20200080 30209a7b     .@  @. u..  {. 0
 100436f:	89705280 0020d455 89700400 0020d255     .Rp.U. ...p.U. .
 100437f:	89700400 0020d155 e26f0400 00c0df41     ..p.U. ...o.A...
 100438f:	00c05000 01c06080 01c05000 02c06080     .P...`...P...`..
 100439f:	10c06000 89706000 8970d055 0018e056     .`...`p.U.p.V...
 10043af:	0018082a 5078002a 507800fc 2f78007c     *...*.xP..xP|.x/
 10043bf:	8970007c 89700002 89700001 89700000     |.p...p...p...p.
 10043cf:	89700003 e26f7004 20790689 e267007e     ..p..po...y ~.g.
 10043df:	60200689 89700000 8970d055 2020c056     .. `..p.U.p.V.  
 10043ef:	42605200 40201700 40202a49 00588049     .R`B.. @I* @I.X.
 10043ff:	40200005 e26f8e4a 20790689 e267007e     .. @J.o...y ~.g.
 100440f:	20200689 89703749 75207c06 00580080     ..  I7p..| u..X.
 100441f:	e4670000 431cdd41 e867007e 60209440     ..g.A..C~.g.@. `
 100442f:	20200000 00587f4b e4678200 0058f641     ..  K.X...g.A.X.
 100443f:	e4679000 0058fe41 e4679a00 0058fa41     ..g.A.X...g.A.X.
 100444f:	e467ad00 0058ea41 e467b000 4020f241     ..g.A.X...g.A. @
 100445f:	4020af4d 4020bc4d 20202a4c 621a4d50     M. @M. @L*  PM.b
 100446f:	04c0007e 01c08980 0ac08700 20208e00     ~.............  
 100447f:	4a70df4d 202000d0 e26ffb4d 5a24cf4a     M.pJ..  M.o.J.$Z
 100448f:	20208c00 4a70084e 602006d0 40200000     ..  N.pJ.. `.. @
 100449f:	2020a802 4020284e 20209200 e26fc350     ..  N( @..  P.o.
 10044af:	7a20d04a e01f0000 e267ffff 7a24d04a     J. z......g.J.$z
 10044bf:	e46f0000 80c25246 6020644d 40200000     ..o.FR..Md `.. @
 10044cf:	7420114f 221a0000 e467007e 40207146     O. t..."~.g.Fq @
 10044df:	e267a700 44687046 44607404 40207346     ..g.FphD.t`DFs @
 10044ef:	3a246c5b e26f8b4a 81c09e04 20204250     [l$:J.o.....PB  
 10044ff:	e26f4250 3a24ed4b 221fab00 6020007e     PBo.K.$:..."~. `
 100450f:	421a0000 6020007e 40200000 3424d001     ...B~. `.. @..$4
 100451f:	20204b4d 4020bd4d 2020b200 2020d350     MK  M. @..  P.  
 100452f:	e26fc84d 13c0ff0a 06c00c81 3bc0bb00     M.o............;
 100453f:	3bc0c400 3cc0ca80 0ac0cf00 20200981     ...;...<......  
 100454f:	221a5c4e e2ef0006 00c00300 00c01c4f     N\."........O...
 100455f:	01c01fcf 01c0254f 2020c280 00581c50     ....O%....  P.X.
 100456f:	20200100 40d8204f 40202800 c0184d5b     ..  O .@.( @[M..
 100457f:	0058fe8b e4e70000 20200500 40201f50     ..X.......  P. @
 100458f:	4020d300 0058f000 e4e70000 20200500     .. @..X.......  
 100459f:	e2ef0201 40200300 4020d700 2020de00     ...... @.. @..  
 10045af:	40200201 2858f400 e6e70200 60200500     .. @..X(...... `
 10045bf:	e2670000 4020960a 2859f400 e8e70203     ..g... @..Y(....
 10045cf:	e26f0500 e6e7960a 60200500 40200000     ..o....... `.. @
 10045df:	4020f400 4020f000 0058f000 e4e70000     .. @.. @..X.....
 10045ef:	40180500 4020ff85 c0184d5b e2ef048c     ...@.. @[M......
 10045ff:	82c20600 82c2eb00 4018eb80 60200184     ...........@.. `
 100460f:	40200000 295af400 f0e70202 40180500     .. @..Z).......@
 100461f:	6020ff85 e2ef0000 e21f0300 e2e70072     .. `........r...
 100462f:	20200500 4020ed67 44e0f700 60200500     ..  g. @...D.. `
 100463f:	e46f0000 00988e44 e4ef000c 7a200600     ..o.D......... z
 100464f:	e01f0000 e2ef0184 c0980600 e2ef008c     ................
 100465f:	c0980600 c218008c 2020000a 4460f900     ..........  ..`D
 100466f:	0a709e0a 005829ff 40200200 4468a550     ..p..)X... @P.hD
 100467f:	44e09e0a 20200a00 e6efb967 e6670300     ...D..  g.....g.
 100468f:	2020aa40 40201f50 20201f50 e26f854d     @.  P. @P.  M.o.
 100469f:	81c27946 e26fe281 83c37946 40180080     Fy....o.Fy.....@
 10046af:	40d8fdff 4020c800 4268b57d 40207a46     ...@.. @}.hBFz @
 10046bf:	e21fb57d 42180022 269a007e e267007e     }..."..B~..&~.g.
 10046cf:	44687a46 40187b46 4020ff85 3a204d5b     FzhDF{.@.. @[M :
 10046df:	48e82b01 28590600 46980203 2224007c     .+.H..Y(...F|.$"
 10046ef:	e2ef2b81 82c20600 82c22781 2020014f     .+.......'..O.  
 10046ff:	40202b01 4468aa02 40207b46 20204d5e     .+ @..hDF{ @^M  
 100470f:	4670034f 0b70007a 40200101 2020e050     O.pFz.p... @P.  
 100471f:	e26f1c50 3a24ed4b 40200957 4a700957     P.o.K.$:W. @W.pJ
 100472f:	4a7001db 005800dc f0670000 0058d14a     ..pJ..X...g.J.X.
 100473f:	e4671b00 6020d94a 40200000 2378ba49     ..g.J. `.. @I.x#
 100474f:	247800fc 800900fc 89190800 e267007e     ..x$........~.g.
 100475f:	8009d502 89190800 e2e7007e e21f0500     ........~.......
 100476f:	3a200072 20208b58 40208758 4020a358     r. :X.  X. @X. @
 100477f:	42681549 40201700 00201c49 4020dc05     I.hB.. @I. ... @
 100478f:	28782149 60d9007c 20207c15 40206958     I!x(|..`.|  Xi @
 100479f:	4020af57 20205101 3620a758 20206880     W. @.Q  X. 6.h  
 10047af:	e26fbe57 3a24ed4b e26fb358 0008db4a     W.o.K.$:X.o.J...
 10047bf:	e2ef0886 e21f0600 00080072 22200886     ........r..... "
 10047cf:	2020bcd8 e26fb958 3a24ed4b e26fc458     ..  X.o.K.$:X.o.
 10047df:	00c05644 e26fd3d8 f21f5744 eb1f007e     DV....o.DW..~...
 10047ef:	e26700fe 4268db4a 40184143 e26706fe     ..g.J.hBCA.@..g.
 10047ff:	ec6fdc4a ec677244 4218dd4a c0d80072     J.o.Drg.J..Br...
 100480f:	40204243 2020cf7c e26fde58 3a24ed4b     CB @|.  X.o.K.$:
 100481f:	40d8f758 e26f0400 3a7d5744 42600604     X..@..o.DW}:..`B
 100482f:	4268db4a 40186143 e26706fe ec6fdc4a     J.hBCa.@..g.J.o.
 100483f:	ec677244 c0d8dd4a 42186243 40200072     Drg.J...Cb.Br. @
 100484f:	4020cf7c 2020a158 4020e25a 4020c95a     |. @X.  Z. @Z. @
 100485f:	e26f9a59 ef2fd502 207904fe e31f2a80     Y.o.../...y .*..
 100486f:	4298007e ef2f00fe 207902fe 07c60f80     ~..B../...y ....
 100487f:	e26f0080 3a20d602 e26f8f01 02c33b04     ..o... :..o..;..
 100488f:	40208f01 40204273 3a7db272 7a240f00     .. @sB @r.}:..$z
 100489f:	42680000 40795204 42600204 e26f5204     ..hB.Ry@..`B.Ro.
 10048af:	7a24ed4b 20200000 e26f9501 7a20d602     K.$z..  ..o... z
 10048bf:	e26f0000 e02fd502 20200106 e02fbd81     ..o.../...  ../.
 10048cf:	20200206 60209d81 e46f0000 82c1d902     ..  .. `..o.....
 10048df:	e6ef0000 e6670600 20797304 09c00f00     ......g..sy ....
 10048ef:	29c0b101 0bc0b301 0cc0aa01 01c03b5e     ...)........^;..
 10048ff:	0fc0ac02 3f79a802 60200f80 00580000     ......y?.. `..X.
 100490f:	e4671e0b 4020d54a 201fb601 20dafef3     ..g.J. @... ... 
 100491f:	4020e002 2020be5a 4020d601 2020b301     .. @Z.  .. @..  
 100492f:	4020cd01 20dab601 2020de02 e26fbe5a     .. @... ..  Z.o.
 100493f:	e01fd602 e01ff9f3 e467fcff 44e8d14a     ..........g.J..D
 100494f:	44600600 6020d34a 20790000 40200f00     ..`DJ. `..y .. @
 100495f:	e26fc501 09c07304 0bc0cd01 29c1cc01     ..o..s.........)
 100496f:	3f790000 60200f80 e26f0000 4468d602     ..y?.. `..o...hD
 100497f:	4098d14a 44600084 e21fd14a 20da0072     J..@..`DJ...r.. 
 100498f:	2020d702 2020be5a 4020d601 7424d001     ..  Z.  .. @..$t
 100499f:	20200000 4020135e e46fc17d 4468d34a     ..  ^. @}.o.J.hD
 10049af:	4698d14a 6224007c 20200080 e46fbf7d     J..F|.$b..  }.o.
 10049bf:	e21fd54a e26f000a e21fd602 40200072     J.....o.....r. @
 10049cf:	a218dc7c e467007e 4020d54a 7424d001     |...~.g.J. @..$t
 10049df:	e0d80000 40200300 2020e650 4020e201     ...... @P.  .. @
 10049ef:	7a24745c 0b700000 00581722 e4671e0b     \t$z..p.".X...g.
 10049ff:	4468d74a 40181e0b 00580484 4020f900     J.hD...@..X... @
 1004a0f:	e01fb57d 0018fca5 e21f0202 40200022     }...........". @
 1004a1f:	e46f325c e21fd74a 221a000c 40200072     \2o.J......"r. @
 1004a2f:	c218cf7c e467007e e46fd74a 469a1e0b     |...~.g.J.o....F
 1004a3f:	e467007e 3a201e0b 40d8fe01 4020f900     ~.g... :...@.. @
 1004a4f:	e21fb57d 00180024 20200102 0058ed01     }...$.....  ..X.
 1004a5f:	e4670000 e0d8d54a 20200300 e26fe250     ..g.J.....  P.o.
 1004a6f:	3a24ed4b 42689b59 4c285204 60200500     K.$:Y.hB.R(L.. `
 1004a7f:	e26f0080 e31fd502 429800fe 01c400fe     ..o........B....
 1004a8f:	3f790080 40790584 42600304 40285204     ..y?..y@..`B.R(@
 1004a9f:	60240306 e26f0080 02c0dd4a e26facd9     ..$`..o.J.....o.
 1004aaf:	01c09744 6020b059 e26f0000 3a24ed4b     D...Y. `..o.K.$:
 1004abf:	e26ff959 82c35204 40200080 40201c5a     Y.o..R.... @Z. @
 1004acf:	3a20535c e2ef3e5a 42e80600 42180600     \S :Z>.....B...B
 1004adf:	269a0022 4020007e 40203a02 e21fb57d     "..&~. @.: @}...
 1004aef:	e2ef0004 e21f0600 221a0002 c098007e     ..........."~...
 1004aff:	a0d8008c 4218dd4a 40200072 4020cf7c     ....J..Br. @|. @
 1004b0f:	40202e5a 4020405a e2ef535c e21f0600     Z. @Z@ @\S......
 1004b1f:	c2180022 42e80026 42180600 469a0024     "...&..B...B$..F
 1004b2f:	4020007e 40203a02 409ab57d e2e700fe     ~. @.: @}..@....
 1004b3f:	269a1300 6224007c 20200080 c218765c     ...&|.$b..  \v..
 1004b4f:	4468000a a218d94a 6020000c e26f0000     ..hDJ..... `..o.
 1004b5f:	3a24ed4b 4260415a 4268dc4a 20795204     K.$:ZA`BJ.hB.Ry 
 1004b6f:	41180504 2198fc7e e26700fe e11f5204     ...A~..!..g..R..
 1004b7f:	0f281f7e 207929fe e26704fe e26fdb4a     ~.(..)y ..g.J.o.
 1004b8f:	2028db4a 20240106 e26f4f82 7a20dc4a     J.( ..$ .Oo.J. z
 1004b9f:	e26f0000 02c43b04 40200000 20204273     ..o..;.... @sB  
 1004baf:	e26f9972 3a24ed4b 60da9a72 4a68db4a     r.o.K.$:r..`J.hJ
 1004bbf:	4020d543 00187772 00980870 0018005e     C. @rw..p...^...
 1004bcf:	40200022 40206372 60dae872 e26fdd4a     ". @rc @r..`J.o.
 1004bdf:	e01fdc4a 609affa5 0018008a e21d0c70     J......`....p...
 1004bef:	e8e7007e 40200500 e26f8e72 e01fdc4a     ~..... @r.o.J...
 1004bff:	e26704fe 4a68dc4a 4018d543 4a600184     ..g.J.hJC..@..`J
 1004c0f:	6020d543 07c60000 40200080 7a24705c     C. `...... @\p$z
 1004c1f:	e26f0000 e11fd502 e267037e e2efde44     ..o.....~.g.D...
 1004c2f:	e2670600 7a20dd44 c2180000 e467007e     ..g.D. z....~.g.
 1004c3f:	e26fdf44 01c0de44 40207e82 e0d8765a     D.o.D....~ @Zv..
 1004c4f:	34240300 4020ec4b 2020f04b e26f6b5a     ..$4K. @K.  Zko.
 1004c5f:	3a24ed4b e26f4460 04c0d702 0ac08402     K.$:`Do.........
 1004c6f:	20209102 20da4560 40da0900 40200900     ..  `E. ...@.. @
 1004c7f:	0058225c f0e72100 40200500 60208b02     \"X..!.... @.. `
 1004c8f:	e26f0000 e11fd802 3a20207e 60208f02     ..o.....~  :.. `
 1004c9f:	4b700000 602001ed e4ef0000 e4670600     ..pK.. `......g.
 1004caf:	2020d94a 20da9402 40da0900 40201500     J.  ... ...@.. @
 1004cbf:	0058225c e4e7fb00 00580500 e4e74808     \"X.......X..H..
 1004ccf:	00580500 e4e7fb00 00580500 e4e74808     ..X.......X..H..
 1004cdf:	60200500 e4ef0000 02c00600 03c0a502     .. `............
 1004cef:	02c0d45e 602096de e6ef0000 e6670600     ^..... `......g.
 1004cff:	20207304 e0d88d5c 20200700 e0d8e250     .s  \.....  P...
 1004d0f:	20200700 4020e650 e467a95c 20207844     ..  P. @\.g.Dx  
 1004d1f:	e26fa25c 3a24ed4b 5578d55b 372000fc     \.o.K.$:[.xU.. 7
 1004d2f:	3624b402 4020e6db e46fa04b e467c140     ..$6.. @K.o.@.g.
 1004d3f:	36244904 07c5b3cb e26fb3cb 3a24dd44     .I$6......o.D.$:
 1004d4f:	e26fb34b 3a24dc4a e26fb34b 82c2bb44     K.o.J.$:K.o.D...
 1004d5f:	e26fb3cb 82c23b04 2020b3cb e26f954b     ..o..;....  K.o.
 1004d6f:	08c07d00 0bc0c602 2020cc82 4268fe60     .}........  `.hB
 1004d7f:	46184e05 2120067c 2020ca02 00700662     .N.F|. !..  b.p.
 1004d8f:	2020247e 20203461 5478b862 4020007c     ~$  a4  b.xT|. @
 1004d9f:	e26fa366 7a204800 83c20000 2020d382     f.o..H z......  
 1004daf:	42c0f263 41c0d602 2020d982 40202164     c..B...A..  d! @
 1004dbf:	e26fdc02 20204800 40207b64 e26fdc02     ..o..H  d{ @..o.
 1004dcf:	20204800 e26fef64 3a202c46 20200d65     .H  d.o.F, :e.  
 1004ddf:	e26f0665 3f799e40 e26703fe 00589e40     e.o.@.y?..g.@.X.
 1004def:	e4670100 6020ca04 e26f0000 1fc0f904     ..g... `..o.....
 1004dff:	39c03ee9 77c047e9 29c0eb82 602005ea     .>.9.G.w...).. `
 1004e0f:	e46f0000 e21ffd04 4020000c e26f8469     ..o....... @i.o.
 1004e1f:	20c0ff04 20c066e9 38c06e69 38c0a7e9     ... .f. in.8...8
 1004e2f:	24c0f502 2020bee9 0a70586a 40200895     ...$..  jXp... @
 1004e3f:	4020ab7b 20207269 e26fba69 3a209044     {. @ir  i.o.D. :
 1004e4f:	4020d05e 20203874 33c13279 004055aa     ^. @t8  y2.3.U@.
 1004e5f:	00024000 00000000 00000000 00000000     .@..............
 1004e6f:	02200000 120c0010 00001900 08000000     .. .............
 1004e7f:	09e80000 0002d018 00024404 00000004     .........D......
 1004e8f:	20000000 00000200 00000000 00000000     ... ............
 1004e9f:	55aa0000 40920001 0155aa0a 40465400     ...U...@..U..TF@
 1004eaf:	000155aa aa134206 98000855 8ffbff40     .U...B..U...@...
 1004ebf:	59858bf8 0355aa83 25421400 55aa054a     ...Y..U...B%J..U
 1004ecf:	453d0004 07007f00 000355aa 0003462d     ..=E.....U..-F..
 1004edf:	0155aa04 01462c00 000655aa 30044657     ..U..,F..U..WF.0
 1004eef:	30303030 001055aa 1c004ff0 1c001fff     0000.U...O......
 1004eff:	4c001c00 4c004fe0 55aa4c00 46680002     ...L.O.L.L.U..hF
 1004f0f:	55aa0700 466c0001 0155aa03 07466f00     ...U..lF..U..oF.
 1004f1f:	000355aa 042440aa 0155aa04 00467900     .U...@$...U..yF.
 1004f2f:	000155aa aa004acf 91000155 55aa0040     .U...J..U...@..U
 1004f3f:	41540003 aa080100 74000155 55aa0241     ..TA....U..tA..U
 1004f4f:	40930001 0155aa00 28466d00 000655aa     ...@..U..mF(.U..
 1004f5f:	2aa740a0 5510212a 000f55aa 330e44e7     .@.**!.U.U...D.3
 1004f6f:	20313231 20756f4d 32317442 0355aa31     121 Mou Bt121.U.
 1004f7f:	2041e400 55aa0200 41e80001 0155aa01     ..A ...U...A..U.
 1004f8f:	01449000 000155aa aa07445f 98000155     ..D..U.._D..U...
 1004f9f:	55aa0044 46750004 002f002d 000155aa     D..U..uF-./..U..
 1004faf:	aa004340 54000255 aa004044 6e000155     @C..U..TD@..U..n
 1004fbf:	55aa0546 44720006 33012221 55aa3a02     F..U..rD!".3.:.U
 1004fcf:	4381000d 3231330c 6f4d2031 6c422075     ...C.3121 Mou Bl
 1004fdf:	0455aa65 03434100 aa020102 61001655     e.U..AC.....U..a
 1004fef:	01020e43 59091102 69686369 30312070     C......Yichip 10
 1004fff:	20733132 aa756f4d 25000755 00030244     21s Mou.U..%D...
 100500f:	03021005 000855aa 00084468 00000010     .....U..hD......
 100501f:	55aa012c 44780001 0155aab9 17447a00     ,..U..xD..U..zD.
 100502f:	000255aa 003144cc 000155aa aa0140d1     .U...D1..U...@..
 100503f:	49000c55 00030545 01010012 03110100     U..IE...........
 100504f:	0155aa00 00455f00 000255aa 46834547     ..U.._E..U..GE.F
 100505f:	00b855aa 12034683 00000100 00010001     .U...F..........
 100506f:	52003601 0a000009 01000100 35010009     .6.R...........5
 100507f:	00121903 35040009 1906350d 00090001     .......5.5......
 100508f:	19033501 00090100 35083509 00121906     .5.......5.5....
 100509f:	09000109 01090002 01020903 09ac0509     ................
 10050af:	02090202 03020939 09440609 01280402     ....9.....D...(.
 10050bf:	09050209 11030200 01030001 00010000     ................
 10050cf:	46003603 0a000009 03000100 35010009     .6.F...........5
 10050df:	01111903 0a020009 00000000 35040009     ...............5
 10050ef:	1903350c 05350001 08030019 06000901     .5....5.........
 10050ff:	65090935 6a00096e 09000109 0a250001     5..en..j......%.
 100510f:	20505053 76616c73 00000065 55aa0001     SPP slave......U
 100511f:	448e0002 55aa47af 47af0235 00020001     ...D.G.U5..G....
 100512f:	18000228 03020002 03020128 2a010200     (.......(......*
 100513f:	0400c802 28030200 00050a01 142a0002     .......(......*.
 100514f:	20747341 4d20454c 6573756f 20202020     Ast LE Mouse    
 100515f:	20202020 03020006 07020128 2a040200         ....(......*
 100516f:	06000608 2c006400 02000801 02012803     .....d.,.....(..
 100517f:	02020009 0a01012a 28030200 000b0801     ....*......(....
 100518f:	062a0302 00000000 000c0000 02280002     ..*...........(.
 100519f:	000d1801 01280302 02000e20 0f002a05     ......(. ....*..
 10051af:	29020200 10000002 28000200 11180402     ...).......(....
 10051bf:	28030200 00121601 012a0702 02001300     ...(......*.....
 10051cf:	00022902 02001400 0f022800 02001518     .).......(......
 10051df:	12012803 19020016 1738012a 28000200     .(......*.8....(
 10051ef:	18180a02 28030200 00190201 032a2302     .......(.....#*.
 10051ff:	1a000000 28030200 001b0201 082a2902     .......(.....)*.
 100520f:	67616c46 70697274 0302001c 1d020128     Flagtrip....(...
 100521f:	2a240200 63697906 1e706968 28030200     ..$*.yichip....(
 100522f:	001f0201 042a2502 336d6f63 03020020     .....%*.com3 ...
 100523f:	21020128 2a260200 302e3103 03020022     (..!..&*.1.0"...
 100524f:	23020128 2a280200 302e3103 03020024     (..#..(*.1.0$...
 100525f:	25020128 2a2a0200 302e3103 03020026     (..%..**.1.0&...
 100526f:	27020128 2a250200 6d6f6304 02002833     (..'..%*.com3(..
 100527f:	55102800 afd205e4 e58fa99f 43fe7d4a     .(.U........J}.C
 100528f:	29495353 28030200 002a1201 24961610     SSI)...(..*....$
 100529f:	6123c647 4d4bd9ba 5353431e 00001449     G.#a..KM.CSSI...
	...
 10052bf:	002b0000 02290202 002c0000 01280302     ..+...)...,...(.
 10052cf:	10002d08 34729bb3 a8d4ecbe 884143f4     .-....r4.....CA.
 10052df:	49535343 00000014 00000000 00000000     CSSI............
	...
 10052f7:	02002e00 04012803 fe10002f 569aca69     .....(../...i..V
 1005307:	02abf619 436daa4d 14495353 00000000     ....M.mCSSI.....
	...
 1005327:	03020030 311a0128 03181000 d85e28a6     0...(..1.....(^.
 1005337:	481c91ec 5343aca3 00144953 00000000     ...H..CSSI......
	...
 1005353:	32000000 29020200 00000002 0755aa00     ...2...)......U.
 1005363:	0f417600 0b0af084 55aa32b2 41570002     .vA......2.U..WA
 1005373:	55aa0b8b 00a10008 00000000 00000000     ...U............
 1005383:	000255aa 240240bd 000855aa 004040ad     .U...@.$.U...@@.
 1005393:	00320200 55aa0200 40bb0002 55aa0020     ..2....U...@ ..U
 10053a3:	40b70004 20000020 000455aa 048040bf     ...@ .. .U...@..
 10053b3:	55aa1000 44e20005 04050e08 0255aa00     ...U...D......U.
 10053c3:	30420200 0155aa1f 20421000 000155aa     ..B0..U...B .U..
 10053d3:	aa0141e0 de000f55 55ba4b4b 57e056d0     .A..U...KK.U.V.W
 10053e3:	596c5888 ffff0710 000255aa 4bde40c3     .XlY.....U...@.K
 10053f3:	2e2e8d64 2f2e2e2f 2e2f2e2e 2e2e2f2e     d.../../../../..
 1005403:	62694c2f 69726172 732f7265 792f6b64     /Librarier/sdk/y
 1005413:	70675f63 632e6f69                        c_gpio.c.

0100541c <__FUNCTION__.5786>:
 100541c:	4f495047 6e6f435f 00676966              GPIO_Config.

01005428 <__FUNCTION__.5795>:
 1005428:	4f495047 696e495f                        GPIO_Init.

01005432 <__FUNCTION__.5824>:
 1005432:	4f495047 6c75505f 4370556c               GPIO_PullUpCmd.

01005441 <__FUNCTION__.5832>:
 1005441:	4f495047 6165525f 706e4964 61447475     GPIO_ReadInputDa
 1005451:	                                         ta.

01005454 <__FUNCTION__.5837>:
 1005454:	4f495047 6165525f 706e4964 61447475     GPIO_ReadInputDa
 1005464:	69426174                                 taBit.

0100546a <__FUNCTION__.5841>:
 100546a:	4f495047 6165525f 74754f64 44747570     GPIO_ReadOutputD
 100547a:	00617461                                ata.

0100547e <__FUNCTION__.5846>:
 100547e:	4f495047 6165525f 74754f64 44747570     GPIO_ReadOutputD
 100548e:	42617461                                 ataBit.

01005495 <__FUNCTION__.5851>:
 1005495:	4f495047 7365525f 69427465               GPIO_ResetBits.

010054a4 <__FUNCTION__.5861>:
 10054a4:	4f495047 7465535f 73746942               GPIO_SetBits.

010054b1 <__FUNCTION__.5873>:
 10054b1:	4f495047 6972575f                        GPIO_Write.

010054bc <__FUNCTION__.5883>:
 10054bc:	4f495047 6972575f 69426574 2e2e0074     GPIO_WriteBit...
 10054cc:	2f2e2e2f 2e2f2e2e 2e2e2f2e 62694c2f     /../../../../Lib
 10054dc:	69726172 732f7265 792f6b64 69745f63     rarier/sdk/yc_ti
 10054ec:	2e72656d                                 mer.c.

010054f2 <__FUNCTION__.5642>:
 10054f2:	5f4d4954 74696e49                        TIM_Init.

010054fb <__FUNCTION__.5649>:
 10054fb:	5f4d4954 00646d43                       TIM_Cmd.

01005503 <__FUNCTION__.5654>:
 1005503:	5f4d4954 65646f4d 666e6f43               TIM_ModeConfig.

01005512 <__FUNCTION__.5659>:
 1005512:	5f4d4954 50746553 6f697265               TIM_SetPeriod.

01005520 <__FUNCTION__.5663>:
 1005520:	5f4d4954 494d5750 0074696e              TIM_PWMInit.

0100552c <__FUNCTION__.5669>:
 100552c:	5f4d4954 50746553 65504d57 646f6972     TIM_SetPWMPeriod
	...

0100553d <__FUNCTION__.5676>:
 100553d:	5f4d4954 444d5750 65666669 746e6572     TIM_PWMDifferent
 100554d:	006c6169 2520304d 000a3a73 54207325     ial.M0 %s:..%s T
 100555d:	3a657079 78323025 7325000a 43504f20     ype:%02x..%s OPC
 100556d:	3a65646f 32302520 25000a78 654c2073     ode: %02x..%s Le
 100557d:	6874676e 3025203a 000a7832 44207325     ngth: %02x..%s D
 100558d:	3a617461 2e2e000a 2f2e2e2f 2e2f2e2e     ata:..../../../.
 100559d:	2e2e2f2e 62694c2f 69726172 732f7265     ./../Librarier/s
 10055ad:	792f6b64 61755f63 632e7472               dk/yc_uart.c.

010055ba <__FUNCTION__.5473>:
 10055ba:	54524155 7475415f 6f6c466f 72744377     UART_AutoFlowCtr
 10055ca:	646d436c                                 lCmd.

010055cf <__FUNCTION__.5487>:
 10055cf:	54524155 4965445f 0074696e              UART_DeInit.

010055db <__FUNCTION__.5496>:
 10055db:	54524155 414d445f 646e6553 00667542     UART_DMASendBuf.

010055eb <__FUNCTION__.5510>:
 10055eb:	54524155 696e495f                        UART_Init.

010055f5 <__FUNCTION__.5514>:
 10055f5:	54524155 5273495f 46494658 6c75464f     UART_IsRXFIFOFul
 1005605:	                                         l.

01005607 <__FUNCTION__.5518>:
 1005607:	54524155 5273495f 46494658 746f4e4f     UART_IsRXFIFONot
 1005617:	74706d45                                 Empty.

0100561d <__FUNCTION__.5522>:
 100561d:	54524155 5573495f 42545241 00797375     UART_IsUARTBusy.

0100562d <__FUNCTION__.5528>:
 100562d:	54524155 4354495f 69666e6f               UART_ITConfig.

0100563b <__FUNCTION__.5535>:
 100563b:	54524155 6365525f 65766965 61746144     UART_ReceiveData
	...

0100564c <__FUNCTION__.5544>:
 100564c:	54524155 6365525f 66754276               UART_RecvBuf.

01005659 <__FUNCTION__.5553>:
 1005659:	54524155 6e65535f 66754264               UART_SendBuf.

01005666 <__FUNCTION__.5579>:
 1005666:	54524155 7465535f 54497852 006d754e     UART_SetRxITNum.

01005676 <__FUNCTION__.5586>:
 1005676:	54524155 6365525f 65766965 61746144     UART_ReceiveData
 1005686:	006e654c 2e2f2e2e 2e2e2f2e 2f2e2e2f     Len.../../../../
 1005696:	4c2f2e2e 61726269 72656972 6b64732f     ../Librarier/sdk
 10056a6:	5f63792f 63737973 2e6c7274               /yc_sysctrl.c.

010056b4 <__FUNCTION__.5488>:
 10056b4:	43535953 5f4c5254 50424841 70697265     SYSCTRL_AHBPerip
 10056c4:	6f6c4368 6d436b63                        hClockCmd.

010056ce <__FUNCTION__.5492>:
 10056ce:	43535953 5f4c5254 65746e45 656c5372     SYSCTRL_EnterSle
 10056de:	                                         ep.

010056e1 <__FUNCTION__.5500>:
 10056e1:	43535953 5f4c5254 4b4c4348 666e6f43     SYSCTRL_HCLKConf
 10056f1:	                                         ig.

010056f4 <USBD_CCID_CfgDesc>:
 10056f4:	005d0209 80040101 00040932 000b0300     ..].....2.......
 1005704:	21360500 03000110 00000001 00000e10     ..6!............
 1005714:	00000e10 0025cd00 0025cd00 00000000     ......%...%.....
	...
 100572c:	00380000 010f0001 00000000 01000000     ..8.............
 100573c:	02810507 07000040 40020105 05070000     ....@......@....
 100574c:	00080382 0d6e4f18 664f000a 000a0d66     .....On...Off...
 100575c:	0a0d7453 0d645300 5047000a 52000a0d     St...Sd...GP...R
 100576c:	000a0d50 0a0d5053 0d534500 4349000a     P...SP...ES...IC
 100577c:	3e000a0d 746e4520 50207265 4f545f43     ...> Enter PC_TO
 100578c:	5244525f 4f42415f 0a0d5452 0d305400     _RDR_ABORT...T0.
 100579c:	454d000a 46000a0d 000a0d52 0a0d4553     ..ME...FR...SE..
 10057ac:	45203e00 7265746e 66656420 746c7561     .> Enter default
 10057bc:	59000a0d 49484349 43532050 55205550     ...YICHIP SCPU U
 10057cc:	43204253 20444943 6f6d6544 2e315620     SB CCID Demo V1.
 10057dc:	000a2e30 31334359 43203132 20444943     0...YC3121 CCID 
 10057ec:	6f6d6544 43495900 00504948 30303030     Demo.YICHIP.0000
 10057fc:	30303030 43303530 72745300 20676e69     0000050C.String 
 100580c:	666e6f43 53006769 49205243 7265746e     Config.SCR Inter
 100581c:	65636166 73616300 64252065 6c000a0d     face.case %d...l
 100582c:	64252063 6c000a0d 64252065 52000a0d     c %d...le %d...R
 100583c:	3a766365 6e45000a 000a3a64 20425355     ecv:..End:..USB 
 100584c:	44494343 6d654420 0a21206f               CCID Demo !...
