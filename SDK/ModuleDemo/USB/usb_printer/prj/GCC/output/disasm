
output/out:     file format elf32-littlearm


Disassembly of section .text:

01000000 <Reset_Handler-0x200>:
	...

01000200 <Reset_Handler>:
 1000200:	4853      	ldr	r0, [pc, #332]	; (1000350 <BT_IRQHandler+0x2>)
 1000202:	4700      	bx	r0

01000204 <hard_fault_handler>:
 1000204:	4853      	ldr	r0, [pc, #332]	; (1000354 <BT_IRQHandler+0x6>)
 1000206:	4700      	bx	r0
 1000208:	46c0      	nop			; (mov r8, r8)

0100020a <svc_handler>:
 100020a:	4853      	ldr	r0, [pc, #332]	; (1000358 <BT_IRQHandler+0xa>)
 100020c:	4700      	bx	r0
 100020e:	46c0      	nop			; (mov r8, r8)

01000210 <pendsv_handler>:
 1000210:	4852      	ldr	r0, [pc, #328]	; (100035c <BT_IRQHandler+0xe>)
 1000212:	4700      	bx	r0
 1000214:	46c0      	nop			; (mov r8, r8)

01000216 <systick>:
 1000216:	4852      	ldr	r0, [pc, #328]	; (1000360 <BT_IRQHandler+0x12>)
 1000218:	4700      	bx	r0
 100021a:	46c0      	nop			; (mov r8, r8)

0100021c <irq0>:
 100021c:	2000      	movs	r0, #0
 100021e:	e03d      	b.n	100029c <isr>

01000220 <irq1>:
 1000220:	2004      	movs	r0, #4
 1000222:	e03b      	b.n	100029c <isr>

01000224 <irq2>:
 1000224:	2008      	movs	r0, #8
 1000226:	e039      	b.n	100029c <isr>

01000228 <irq3>:
 1000228:	200c      	movs	r0, #12
 100022a:	e037      	b.n	100029c <isr>

0100022c <irq4>:
 100022c:	2010      	movs	r0, #16
 100022e:	e035      	b.n	100029c <isr>

01000230 <irq5>:
 1000230:	2014      	movs	r0, #20
 1000232:	e033      	b.n	100029c <isr>

01000234 <irq6>:
 1000234:	2018      	movs	r0, #24
 1000236:	e031      	b.n	100029c <isr>

01000238 <irq7>:
 1000238:	201c      	movs	r0, #28
 100023a:	e02f      	b.n	100029c <isr>

0100023c <irq8>:
 100023c:	2020      	movs	r0, #32
 100023e:	e02d      	b.n	100029c <isr>

01000240 <irq9>:
 1000240:	2024      	movs	r0, #36	; 0x24
 1000242:	e02b      	b.n	100029c <isr>

01000244 <irq10>:
 1000244:	2028      	movs	r0, #40	; 0x28
 1000246:	e029      	b.n	100029c <isr>

01000248 <irq11>:
 1000248:	202c      	movs	r0, #44	; 0x2c
 100024a:	e027      	b.n	100029c <isr>

0100024c <irq12>:
 100024c:	2030      	movs	r0, #48	; 0x30
 100024e:	e025      	b.n	100029c <isr>

01000250 <irq13>:
 1000250:	2034      	movs	r0, #52	; 0x34
 1000252:	e023      	b.n	100029c <isr>

01000254 <irq14>:
 1000254:	2038      	movs	r0, #56	; 0x38
 1000256:	e021      	b.n	100029c <isr>

01000258 <irq15>:
 1000258:	203c      	movs	r0, #60	; 0x3c
 100025a:	e01f      	b.n	100029c <isr>

0100025c <irq16>:
 100025c:	2040      	movs	r0, #64	; 0x40
 100025e:	e01d      	b.n	100029c <isr>

01000260 <irq17>:
 1000260:	2044      	movs	r0, #68	; 0x44
 1000262:	e01b      	b.n	100029c <isr>

01000264 <irq18>:
 1000264:	2048      	movs	r0, #72	; 0x48
 1000266:	e019      	b.n	100029c <isr>

01000268 <irq19>:
 1000268:	204c      	movs	r0, #76	; 0x4c
 100026a:	e017      	b.n	100029c <isr>

0100026c <irq20>:
 100026c:	2050      	movs	r0, #80	; 0x50
 100026e:	e015      	b.n	100029c <isr>

01000270 <irq21>:
 1000270:	2054      	movs	r0, #84	; 0x54
 1000272:	e013      	b.n	100029c <isr>

01000274 <irq22>:
 1000274:	2058      	movs	r0, #88	; 0x58
 1000276:	e011      	b.n	100029c <isr>

01000278 <irq23>:
 1000278:	205c      	movs	r0, #92	; 0x5c
 100027a:	e00f      	b.n	100029c <isr>

0100027c <irq24>:
 100027c:	2060      	movs	r0, #96	; 0x60
 100027e:	e00d      	b.n	100029c <isr>

01000280 <irq25>:
 1000280:	2064      	movs	r0, #100	; 0x64
 1000282:	e00b      	b.n	100029c <isr>

01000284 <irq26>:
 1000284:	2068      	movs	r0, #104	; 0x68
 1000286:	e009      	b.n	100029c <isr>

01000288 <irq27>:
 1000288:	206c      	movs	r0, #108	; 0x6c
 100028a:	e007      	b.n	100029c <isr>

0100028c <irq28>:
 100028c:	2070      	movs	r0, #112	; 0x70
 100028e:	e005      	b.n	100029c <isr>

01000290 <irq29>:
 1000290:	2074      	movs	r0, #116	; 0x74
 1000292:	e003      	b.n	100029c <isr>

01000294 <irq30>:
 1000294:	2078      	movs	r0, #120	; 0x78
 1000296:	e001      	b.n	100029c <isr>

01000298 <irq31>:
 1000298:	207c      	movs	r0, #124	; 0x7c
 100029a:	e7ff      	b.n	100029c <isr>

0100029c <isr>:
 100029c:	4931      	ldr	r1, [pc, #196]	; (1000364 <BT_IRQHandler+0x16>)
 100029e:	5840      	ldr	r0, [r0, r1]
 10002a0:	4700      	bx	r0
 10002a2:	46c0      	nop			; (mov r8, r8)
 10002a4:	46c0      	nop			; (mov r8, r8)
 10002a6:	46c0      	nop			; (mov r8, r8)
 10002a8:	46c0      	nop			; (mov r8, r8)
 10002aa:	46c0      	nop			; (mov r8, r8)
 10002ac:	46c0      	nop			; (mov r8, r8)
 10002ae:	46c0      	nop			; (mov r8, r8)

010002b0 <isr_table>:
 10002b0:	010019b5 	.word	0x010019b5
 10002b4:	0100034f 	.word	0x0100034f
 10002b8:	0100034f 	.word	0x0100034f
 10002bc:	0100034f 	.word	0x0100034f
 10002c0:	0100034f 	.word	0x0100034f
 10002c4:	0100034f 	.word	0x0100034f
 10002c8:	0100034f 	.word	0x0100034f
 10002cc:	0100034f 	.word	0x0100034f
 10002d0:	0100034f 	.word	0x0100034f
 10002d4:	0100034f 	.word	0x0100034f
 10002d8:	0100034f 	.word	0x0100034f
 10002dc:	0100034f 	.word	0x0100034f
 10002e0:	0100034f 	.word	0x0100034f
 10002e4:	01001ee1 	.word	0x01001ee1
 10002e8:	0100034f 	.word	0x0100034f
 10002ec:	0100034f 	.word	0x0100034f
 10002f0:	0100034f 	.word	0x0100034f
 10002f4:	0100034f 	.word	0x0100034f
 10002f8:	0100034f 	.word	0x0100034f
 10002fc:	0100034f 	.word	0x0100034f
 1000300:	0100034f 	.word	0x0100034f
 1000304:	0100034f 	.word	0x0100034f
 1000308:	0100034f 	.word	0x0100034f
 100030c:	0100034f 	.word	0x0100034f
 1000310:	0100034f 	.word	0x0100034f
 1000314:	0100034f 	.word	0x0100034f
 1000318:	0100034f 	.word	0x0100034f

0100031c <hardware_init>:
 100031c:	4912      	ldr	r1, [pc, #72]	; (1000368 <BT_IRQHandler+0x1a>)
 100031e:	4a13      	ldr	r2, [pc, #76]	; (100036c <BT_IRQHandler+0x1e>)
 1000320:	4b13      	ldr	r3, [pc, #76]	; (1000370 <BT_IRQHandler+0x22>)
 1000322:	1a9b      	subs	r3, r3, r2
 1000324:	dd03      	ble.n	100032e <hardware_init+0x12>
 1000326:	3b04      	subs	r3, #4
 1000328:	58c8      	ldr	r0, [r1, r3]
 100032a:	50d0      	str	r0, [r2, r3]
 100032c:	dcfb      	bgt.n	1000326 <hardware_init+0xa>
 100032e:	4911      	ldr	r1, [pc, #68]	; (1000374 <BT_IRQHandler+0x26>)
 1000330:	4a11      	ldr	r2, [pc, #68]	; (1000378 <BT_IRQHandler+0x2a>)
 1000332:	2000      	movs	r0, #0
 1000334:	1a52      	subs	r2, r2, r1
 1000336:	dd02      	ble.n	100033e <hardware_init+0x22>
 1000338:	3a04      	subs	r2, #4
 100033a:	5088      	str	r0, [r1, r2]
 100033c:	dcfc      	bgt.n	1000338 <hardware_init+0x1c>
 100033e:	480f      	ldr	r0, [pc, #60]	; (100037c <BT_IRQHandler+0x2e>)
 1000340:	4b0f      	ldr	r3, [pc, #60]	; (1000380 <BT_IRQHandler+0x32>)
 1000342:	f001 fdfd 	bl	1001f40 <main>

01000346 <delay>:
 1000346:	3801      	subs	r0, #1
 1000348:	d1fd      	bne.n	1000346 <delay>
 100034a:	46c0      	nop			; (mov r8, r8)
 100034c:	4770      	bx	lr

0100034e <BT_IRQHandler>:
 100034e:	e7fe      	b.n	100034e <BT_IRQHandler>
 1000350:	0100031d 	.word	0x0100031d
 1000354:	0100034f 	.word	0x0100034f
 1000358:	0100034f 	.word	0x0100034f
 100035c:	0100034f 	.word	0x0100034f
 1000360:	0100034f 	.word	0x0100034f
 1000364:	010002b0 	.word	0x010002b0
 1000368:	01002f04 	.word	0x01002f04
 100036c:	00020000 	.word	0x00020000
 1000370:	00020008 	.word	0x00020008
 1000374:	00020100 	.word	0x00020100
 1000378:	000218e0 	.word	0x000218e0
 100037c:	00012345 	.word	0x00012345
 1000380:	00001111 	.word	0x00001111
 1000384:	00002041 	.word	0x00002041
 1000388:	61656100 	.word	0x61656100
 100038c:	01006962 	.word	0x01006962
 1000390:	00000016 	.word	0x00000016
 1000394:	726f4305 	.word	0x726f4305
 1000398:	2d786574 	.word	0x2d786574
 100039c:	0600304d 	.word	0x0600304d
 10003a0:	094d070c 	.word	0x094d070c
 10003a4:	00000001 	.word	0x00000001

010003a8 <printfsend>:
#endif

void printfsend(UART_TypeDef UARTx, uint8_t *buf, int len)
{
    uint8_t printbuf[256];
    for (int i = 0; i < len; i++)
 10003a8:	2300      	movs	r3, #0
{
 10003aa:	b530      	push	{r4, r5, lr}
 10003ac:	b0c1      	sub	sp, #260	; 0x104
    for (int i = 0; i < len; i++)
 10003ae:	4293      	cmp	r3, r2
 10003b0:	db04      	blt.n	10003bc <printfsend+0x14>
    else
    {
        UART_SendBuf(UART0, printbuf, len);
    }
#else
    UART_SendBuf(UARTx, printbuf, len);
 10003b2:	4669      	mov	r1, sp
 10003b4:	f000 ff12 	bl	10011dc <UART_SendBuf>
#endif
}
 10003b8:	b041      	add	sp, #260	; 0x104
 10003ba:	bd30      	pop	{r4, r5, pc}
        printbuf[i] = buf[i];
 10003bc:	466d      	mov	r5, sp
 10003be:	5ccc      	ldrb	r4, [r1, r3]
 10003c0:	54ec      	strb	r4, [r5, r3]
    for (int i = 0; i < len; i++)
 10003c2:	3301      	adds	r3, #1
 10003c4:	e7f3      	b.n	10003ae <printfsend+0x6>

010003c6 <MyPrintf>:

void MyPrintf(char *format, ...)
{
 10003c6:	b40f      	push	{r0, r1, r2, r3}
 10003c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 10003ca:	b08d      	sub	sp, #52	; 0x34
 10003cc:	ab12      	add	r3, sp, #72	; 0x48
 10003ce:	cb04      	ldmia	r3!, {r2}
 10003d0:	9202      	str	r2, [sp, #8]
    uint32_t ulIdx, ulValue, ulPos, ulCount, ulBase, ulNeg;
    int8_t *pcStr, pcBuf[16], cFill;
    char HexFormat;
    va_list vaArgP;

    va_start(vaArgP, format);
 10003d2:	9307      	str	r3, [sp, #28]

    while (*format)
 10003d4:	9b02      	ldr	r3, [sp, #8]
 10003d6:	781b      	ldrb	r3, [r3, #0]
 10003d8:	2b00      	cmp	r3, #0
 10003da:	d100      	bne.n	10003de <MyPrintf+0x18>
 10003dc:	e0de      	b.n	100059c <MyPrintf+0x1d6>
 10003de:	9b02      	ldr	r3, [sp, #8]
 10003e0:	9a02      	ldr	r2, [sp, #8]
    {
        // Find the first non-% character, or the end of the string.
        for (ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0'); ulIdx++)
 10003e2:	7819      	ldrb	r1, [r3, #0]
 10003e4:	1a9a      	subs	r2, r3, r2
 10003e6:	001c      	movs	r4, r3
 10003e8:	2925      	cmp	r1, #37	; 0x25
 10003ea:	d002      	beq.n	10003f2 <MyPrintf+0x2c>
 10003ec:	3301      	adds	r3, #1
 10003ee:	2900      	cmp	r1, #0
 10003f0:	d1f6      	bne.n	10003e0 <MyPrintf+0x1a>
        {}

        // Write this portion of the string.
        if (ulIdx > 0)
 10003f2:	2a00      	cmp	r2, #0
 10003f4:	d003      	beq.n	10003fe <MyPrintf+0x38>
        {
//				printfsend(UART0,format, ulIdx);
            printfsend(UART0, (uint8_t *)format, ulIdx);
 10003f6:	9902      	ldr	r1, [sp, #8]
 10003f8:	2000      	movs	r0, #0
 10003fa:	f7ff ffd5 	bl	10003a8 <printfsend>
        }

        format += ulIdx;

        if (*format == '%')
 10003fe:	7823      	ldrb	r3, [r4, #0]
 1000400:	9402      	str	r4, [sp, #8]
 1000402:	2b25      	cmp	r3, #37	; 0x25
 1000404:	d1e6      	bne.n	10003d4 <MyPrintf+0xe>
        {
            format++;
 1000406:	1c61      	adds	r1, r4, #1
                if ((format[-1] == '0') && (ulCount == 0))
                {
                    cFill = '0';
                }

                ulCount *= 10;
 1000408:	220a      	movs	r2, #10
            ulCount = 0;
 100040a:	2400      	movs	r4, #0
            cFill = ' ';
 100040c:	3b05      	subs	r3, #5
 100040e:	9303      	str	r3, [sp, #12]
            switch (*format++)
 1000410:	1c4b      	adds	r3, r1, #1
 1000412:	9302      	str	r3, [sp, #8]
 1000414:	780b      	ldrb	r3, [r1, #0]
 1000416:	2b63      	cmp	r3, #99	; 0x63
 1000418:	d036      	beq.n	1000488 <MyPrintf+0xc2>
 100041a:	d814      	bhi.n	1000446 <MyPrintf+0x80>
 100041c:	2b39      	cmp	r3, #57	; 0x39
 100041e:	d807      	bhi.n	1000430 <MyPrintf+0x6a>
 1000420:	2b30      	cmp	r3, #48	; 0x30
 1000422:	d226      	bcs.n	1000472 <MyPrintf+0xac>
            }

            case '%':
            {
//					printfsend(UART0, format - 1, 1);
                printfsend(UART0, (uint8_t *)format - 1, 1);
 1000424:	2201      	movs	r2, #1
            switch (*format++)
 1000426:	2b25      	cmp	r3, #37	; 0x25
 1000428:	d035      	beq.n	1000496 <MyPrintf+0xd0>
            }

            default:
            {
//					printfsend(UART0, "ERROR", 5);
                printfsend(UART0, (uint8_t *)"ERROR", 5);
 100042a:	2205      	movs	r2, #5
 100042c:	495e      	ldr	r1, [pc, #376]	; (10005a8 <MyPrintf+0x1e2>)
 100042e:	e032      	b.n	1000496 <MyPrintf+0xd0>
            switch (*format++)
 1000430:	2b58      	cmp	r3, #88	; 0x58
 1000432:	d1fa      	bne.n	100042a <MyPrintf+0x64>
                ulValue = va_arg(vaArgP, unsigned long);
 1000434:	9a07      	ldr	r2, [sp, #28]
                HexFormat = 'X';
 1000436:	9304      	str	r3, [sp, #16]
                ulValue = va_arg(vaArgP, unsigned long);
 1000438:	1d11      	adds	r1, r2, #4
 100043a:	6812      	ldr	r2, [r2, #0]
 100043c:	9107      	str	r1, [sp, #28]
 100043e:	9206      	str	r2, [sp, #24]
                ulNeg = 0;
 1000440:	2700      	movs	r7, #0
                ulBase = 16;
 1000442:	2310      	movs	r3, #16
 1000444:	e038      	b.n	10004b8 <MyPrintf+0xf2>
            switch (*format++)
 1000446:	2b73      	cmp	r3, #115	; 0x73
 1000448:	d06e      	beq.n	1000528 <MyPrintf+0x162>
 100044a:	d80d      	bhi.n	1000468 <MyPrintf+0xa2>
 100044c:	2b64      	cmp	r3, #100	; 0x64
 100044e:	d026      	beq.n	100049e <MyPrintf+0xd8>
 1000450:	2b70      	cmp	r3, #112	; 0x70
 1000452:	d1ea      	bne.n	100042a <MyPrintf+0x64>
                ulValue = va_arg(vaArgP, unsigned long);
 1000454:	9b07      	ldr	r3, [sp, #28]
                ulNeg = 0;
 1000456:	2700      	movs	r7, #0
                ulValue = va_arg(vaArgP, unsigned long);
 1000458:	1d1a      	adds	r2, r3, #4
 100045a:	681b      	ldr	r3, [r3, #0]
 100045c:	9207      	str	r2, [sp, #28]
 100045e:	9306      	str	r3, [sp, #24]
                HexFormat = 'x';
 1000460:	2378      	movs	r3, #120	; 0x78
 1000462:	9304      	str	r3, [sp, #16]
                ulBase = 16;
 1000464:	3b68      	subs	r3, #104	; 0x68
 1000466:	e027      	b.n	10004b8 <MyPrintf+0xf2>
            switch (*format++)
 1000468:	2b75      	cmp	r3, #117	; 0x75
 100046a:	d079      	beq.n	1000560 <MyPrintf+0x19a>
 100046c:	2b78      	cmp	r3, #120	; 0x78
 100046e:	d0f1      	beq.n	1000454 <MyPrintf+0x8e>
 1000470:	e7db      	b.n	100042a <MyPrintf+0x64>
                if ((format[-1] == '0') && (ulCount == 0))
 1000472:	2b30      	cmp	r3, #48	; 0x30
 1000474:	d103      	bne.n	100047e <MyPrintf+0xb8>
 1000476:	2c00      	cmp	r4, #0
 1000478:	d101      	bne.n	100047e <MyPrintf+0xb8>
                    cFill = '0';
 100047a:	2130      	movs	r1, #48	; 0x30
 100047c:	9103      	str	r1, [sp, #12]
                ulCount *= 10;
 100047e:	4354      	muls	r4, r2
 1000480:	3c30      	subs	r4, #48	; 0x30
                ulCount += format[-1] - '0';
 1000482:	191c      	adds	r4, r3, r4
            switch (*format++)
 1000484:	9902      	ldr	r1, [sp, #8]
                goto again;
 1000486:	e7c3      	b.n	1000410 <MyPrintf+0x4a>
                ulValue = va_arg(vaArgP, unsigned long);
 1000488:	9b07      	ldr	r3, [sp, #28]
                printfsend(UART0, (uint8_t *)&ulValue, 1);
 100048a:	a906      	add	r1, sp, #24
                ulValue = va_arg(vaArgP, unsigned long);
 100048c:	1d1a      	adds	r2, r3, #4
 100048e:	9207      	str	r2, [sp, #28]
                printfsend(UART0, (uint8_t *)&ulValue, 1);
 1000490:	2201      	movs	r2, #1
                ulValue = va_arg(vaArgP, unsigned long);
 1000492:	681b      	ldr	r3, [r3, #0]
 1000494:	9306      	str	r3, [sp, #24]
                printfsend(UART0, (uint8_t *)"ERROR", 5);
 1000496:	2000      	movs	r0, #0
 1000498:	f7ff ff86 	bl	10003a8 <printfsend>
                break;
 100049c:	e79a      	b.n	10003d4 <MyPrintf+0xe>
                ulValue = va_arg(vaArgP, unsigned long);
 100049e:	9b07      	ldr	r3, [sp, #28]
 10004a0:	1d1a      	adds	r2, r3, #4
 10004a2:	681b      	ldr	r3, [r3, #0]
 10004a4:	9207      	str	r2, [sp, #28]
                if ((long)ulValue < 0)
 10004a6:	2b00      	cmp	r3, #0
 10004a8:	db02      	blt.n	10004b0 <MyPrintf+0xea>
                ulValue = va_arg(vaArgP, unsigned long);
 10004aa:	9306      	str	r3, [sp, #24]
                ulNeg = 0;
 10004ac:	2700      	movs	r7, #0
 10004ae:	e002      	b.n	10004b6 <MyPrintf+0xf0>
                    ulNeg = 1;
 10004b0:	2701      	movs	r7, #1
                    ulValue = -(long)ulValue;
 10004b2:	425b      	negs	r3, r3
 10004b4:	9306      	str	r3, [sp, #24]
                ulBase = 10;
 10004b6:	230a      	movs	r3, #10
                for (ulIdx = 1;
 10004b8:	2601      	movs	r6, #1
                ulBase = 16;
 10004ba:	9301      	str	r3, [sp, #4]
                        (((ulIdx * ulBase) <= ulValue) &&
 10004bc:	9b06      	ldr	r3, [sp, #24]
 10004be:	9305      	str	r3, [sp, #20]
 10004c0:	9d01      	ldr	r5, [sp, #4]
                for (ulIdx = 1;
 10004c2:	9b05      	ldr	r3, [sp, #20]
                        (((ulIdx * ulBase) <= ulValue) &&
 10004c4:	4375      	muls	r5, r6
                for (ulIdx = 1;
 10004c6:	429d      	cmp	r5, r3
 10004c8:	d805      	bhi.n	10004d6 <MyPrintf+0x110>
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
 10004ca:	9901      	ldr	r1, [sp, #4]
 10004cc:	0028      	movs	r0, r5
 10004ce:	f001 fde3 	bl	1002098 <__udivsi3>
                        (((ulIdx * ulBase) <= ulValue) &&
 10004d2:	42b0      	cmp	r0, r6
 10004d4:	d049      	beq.n	100056a <MyPrintf+0x1a4>
 10004d6:	2500      	movs	r5, #0
                if (ulNeg)
 10004d8:	42af      	cmp	r7, r5
 10004da:	d008      	beq.n	10004ee <MyPrintf+0x128>
                if (ulNeg && (cFill == '0'))
 10004dc:	9b03      	ldr	r3, [sp, #12]
                    ulCount--;
 10004de:	3c01      	subs	r4, #1
                if (ulNeg && (cFill == '0'))
 10004e0:	2b30      	cmp	r3, #48	; 0x30
 10004e2:	d104      	bne.n	10004ee <MyPrintf+0x128>
                    pcBuf[ulPos++] = '-';
 10004e4:	222d      	movs	r2, #45	; 0x2d
 10004e6:	003d      	movs	r5, r7
                    ulNeg = 0;
 10004e8:	2700      	movs	r7, #0
                    pcBuf[ulPos++] = '-';
 10004ea:	ab08      	add	r3, sp, #32
 10004ec:	701a      	strb	r2, [r3, #0]
                if ((ulCount > 1) && (ulCount < 16))
 10004ee:	1ea3      	subs	r3, r4, #2
 10004f0:	2b0d      	cmp	r3, #13
 10004f2:	d80a      	bhi.n	100050a <MyPrintf+0x144>
                    for (ulCount--; ulCount; ulCount--)
 10004f4:	1e63      	subs	r3, r4, #1
 10004f6:	192d      	adds	r5, r5, r4
                        pcBuf[ulPos++] = cFill;
 10004f8:	a908      	add	r1, sp, #32
 10004fa:	1aea      	subs	r2, r5, r3
 10004fc:	9803      	ldr	r0, [sp, #12]
 10004fe:	3a01      	subs	r2, #1
                    for (ulCount--; ulCount; ulCount--)
 1000500:	3b01      	subs	r3, #1
                        pcBuf[ulPos++] = cFill;
 1000502:	5488      	strb	r0, [r1, r2]
                    for (ulCount--; ulCount; ulCount--)
 1000504:	2b00      	cmp	r3, #0
 1000506:	d1f8      	bne.n	10004fa <MyPrintf+0x134>
 1000508:	3d01      	subs	r5, #1
                if (ulNeg)
 100050a:	2f00      	cmp	r7, #0
 100050c:	d005      	beq.n	100051a <MyPrintf+0x154>
                    pcBuf[ulPos++] = '-';
 100050e:	2108      	movs	r1, #8
 1000510:	232d      	movs	r3, #45	; 0x2d
 1000512:	aa06      	add	r2, sp, #24
 1000514:	1852      	adds	r2, r2, r1
 1000516:	5553      	strb	r3, [r2, r5]
 1000518:	3501      	adds	r5, #1
                        pcBuf[ulPos++] = g_pcHex1[(ulValue / ulIdx) % ulBase];//x
 100051a:	4f24      	ldr	r7, [pc, #144]	; (10005ac <MyPrintf+0x1e6>)
 100051c:	ac08      	add	r4, sp, #32
                for (; ulIdx; ulIdx /= ulBase)
 100051e:	2e00      	cmp	r6, #0
 1000520:	d126      	bne.n	1000570 <MyPrintf+0x1aa>
                printfsend(UART0, (uint8_t *)pcBuf, ulPos);
 1000522:	002a      	movs	r2, r5
 1000524:	a908      	add	r1, sp, #32
 1000526:	e7b6      	b.n	1000496 <MyPrintf+0xd0>
                pcStr = (int8_t *)va_arg(vaArgP, char *);
 1000528:	9b07      	ldr	r3, [sp, #28]
 100052a:	6819      	ldr	r1, [r3, #0]
 100052c:	1d1a      	adds	r2, r3, #4
                for (ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
 100052e:	000b      	movs	r3, r1
                pcStr = (int8_t *)va_arg(vaArgP, char *);
 1000530:	9207      	str	r2, [sp, #28]
                for (ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
 1000532:	2000      	movs	r0, #0
 1000534:	1a5d      	subs	r5, r3, r1
 1000536:	3301      	adds	r3, #1
 1000538:	1e5a      	subs	r2, r3, #1
 100053a:	5610      	ldrsb	r0, [r2, r0]
 100053c:	2800      	cmp	r0, #0
 100053e:	d1f8      	bne.n	1000532 <MyPrintf+0x16c>
                printfsend(UART0, (uint8_t *)pcStr, ulIdx);
 1000540:	002a      	movs	r2, r5
 1000542:	f7ff ff31 	bl	10003a8 <printfsend>
                if (ulCount > ulIdx)
 1000546:	42ac      	cmp	r4, r5
 1000548:	d800      	bhi.n	100054c <MyPrintf+0x186>
 100054a:	e743      	b.n	10003d4 <MyPrintf+0xe>
                    ulCount -= ulIdx;
 100054c:	1b64      	subs	r4, r4, r5
                    while (ulCount--)
 100054e:	3c01      	subs	r4, #1
 1000550:	d200      	bcs.n	1000554 <MyPrintf+0x18e>
 1000552:	e73f      	b.n	10003d4 <MyPrintf+0xe>
                        printfsend(UART0, (uint8_t *)" ", 1);
 1000554:	2201      	movs	r2, #1
 1000556:	4916      	ldr	r1, [pc, #88]	; (10005b0 <MyPrintf+0x1ea>)
 1000558:	2000      	movs	r0, #0
 100055a:	f7ff ff25 	bl	10003a8 <printfsend>
 100055e:	e7f6      	b.n	100054e <MyPrintf+0x188>
                ulValue = va_arg(vaArgP, unsigned long);
 1000560:	9b07      	ldr	r3, [sp, #28]
 1000562:	1d1a      	adds	r2, r3, #4
 1000564:	9207      	str	r2, [sp, #28]
 1000566:	681b      	ldr	r3, [r3, #0]
 1000568:	e79f      	b.n	10004aa <MyPrintf+0xe4>
                        ulIdx *= ulBase, ulCount--)
 100056a:	3c01      	subs	r4, #1
 100056c:	002e      	movs	r6, r5
 100056e:	e7a7      	b.n	10004c0 <MyPrintf+0xfa>
 1000570:	0031      	movs	r1, r6
 1000572:	9805      	ldr	r0, [sp, #20]
 1000574:	f001 fd90 	bl	1002098 <__udivsi3>
 1000578:	9901      	ldr	r1, [sp, #4]
 100057a:	f001 fe13 	bl	10021a4 <__aeabi_uidivmod>
                    if (HexFormat == 'x')
 100057e:	9b04      	ldr	r3, [sp, #16]
 1000580:	2b78      	cmp	r3, #120	; 0x78
 1000582:	d108      	bne.n	1000596 <MyPrintf+0x1d0>
                        pcBuf[ulPos++] = g_pcHex1[(ulValue / ulIdx) % ulBase];//x
 1000584:	5c7b      	ldrb	r3, [r7, r1]
                        pcBuf[ulPos++] = g_pcHex2[(ulValue / ulIdx) % ulBase];//X
 1000586:	5563      	strb	r3, [r4, r5]
                for (; ulIdx; ulIdx /= ulBase)
 1000588:	0030      	movs	r0, r6
 100058a:	9901      	ldr	r1, [sp, #4]
 100058c:	f001 fd84 	bl	1002098 <__udivsi3>
 1000590:	3501      	adds	r5, #1
 1000592:	0006      	movs	r6, r0
 1000594:	e7c3      	b.n	100051e <MyPrintf+0x158>
                        pcBuf[ulPos++] = g_pcHex2[(ulValue / ulIdx) % ulBase];//X
 1000596:	4b07      	ldr	r3, [pc, #28]	; (10005b4 <MyPrintf+0x1ee>)
 1000598:	5c5b      	ldrb	r3, [r3, r1]
 100059a:	e7f4      	b.n	1000586 <MyPrintf+0x1c0>
            }
            }//switch
        }//if
    }//while
    va_end(vaArgP);
}
 100059c:	b00d      	add	sp, #52	; 0x34
 100059e:	bcf0      	pop	{r4, r5, r6, r7}
 10005a0:	bc08      	pop	{r3}
 10005a2:	b004      	add	sp, #16
 10005a4:	4718      	bx	r3
 10005a6:	46c0      	nop			; (mov r8, r8)
 10005a8:	010023a6 	.word	0x010023a6
 10005ac:	01002384 	.word	0x01002384
 10005b0:	010023bf 	.word	0x010023bf
 10005b4:	01002395 	.word	0x01002395

010005b8 <printv>:

void printv(uint8_t *buf, uint32_t len, uint8_t *s)
{
 10005b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 10005ba:	0005      	movs	r5, r0
 10005bc:	000c      	movs	r4, r1
    uint32_t i = 0;
    uint32_t n = 0;
    MyPrintf("\r\n %s:", s);
 10005be:	480d      	ldr	r0, [pc, #52]	; (10005f4 <printv+0x3c>)
 10005c0:	0011      	movs	r1, r2
 10005c2:	f7ff ff00 	bl	10003c6 <MyPrintf>
    uint32_t n = 0;
 10005c6:	2600      	movs	r6, #0
 10005c8:	192b      	adds	r3, r5, r4
    for (i = 0; i < len; i++)
    {
        if (i % 16 == 0)
 10005ca:	270f      	movs	r7, #15
    for (i = 0; i < len; i++)
 10005cc:	002c      	movs	r4, r5
 10005ce:	9301      	str	r3, [sp, #4]
 10005d0:	9a01      	ldr	r2, [sp, #4]
 10005d2:	1b63      	subs	r3, r4, r5
 10005d4:	4294      	cmp	r4, r2
 10005d6:	d100      	bne.n	10005da <printv+0x22>
            n += 16;
        }
        MyPrintf("%02x ", buf[i]);

    }
}
 10005d8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
        if (i % 16 == 0)
 10005da:	423b      	tst	r3, r7
 10005dc:	d104      	bne.n	10005e8 <printv+0x30>
            MyPrintf("\r\n%08x:", n);
 10005de:	0031      	movs	r1, r6
 10005e0:	4805      	ldr	r0, [pc, #20]	; (10005f8 <printv+0x40>)
 10005e2:	f7ff fef0 	bl	10003c6 <MyPrintf>
            n += 16;
 10005e6:	3610      	adds	r6, #16
        MyPrintf("%02x ", buf[i]);
 10005e8:	7821      	ldrb	r1, [r4, #0]
 10005ea:	4804      	ldr	r0, [pc, #16]	; (10005fc <printv+0x44>)
 10005ec:	f7ff feeb 	bl	10003c6 <MyPrintf>
 10005f0:	3401      	adds	r4, #1
 10005f2:	e7ed      	b.n	10005d0 <printv+0x18>
 10005f4:	010023ac 	.word	0x010023ac
 10005f8:	010023b3 	.word	0x010023b3
 10005fc:	010023bb 	.word	0x010023bb

01000600 <_assert_handler>:

void _assert_handler(const char *file, int line, const char *func)
{
 1000600:	e7fe      	b.n	1000600 <_assert_handler>
 1000602:	46c0      	nop			; (mov r8, r8)

01000604 <NVIC_SetPriority>:
#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
/* End of group Configuration_of_CMSIS */

uint32_t NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 1000604:	b530      	push	{r4, r5, lr}
 1000606:	25ff      	movs	r5, #255	; 0xff
 1000608:	2403      	movs	r4, #3
 100060a:	002a      	movs	r2, r5
 100060c:	b2c3      	uxtb	r3, r0
 100060e:	401c      	ands	r4, r3
 1000610:	00e4      	lsls	r4, r4, #3
 1000612:	40a2      	lsls	r2, r4
 1000614:	0189      	lsls	r1, r1, #6
 1000616:	4029      	ands	r1, r5
 1000618:	43d2      	mvns	r2, r2
 100061a:	40a1      	lsls	r1, r4
    if ((int32_t)(IRQn) < 0)
 100061c:	2800      	cmp	r0, #0
 100061e:	da0c      	bge.n	100063a <NVIC_SetPriority+0x36>
    {
        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 1000620:	200f      	movs	r0, #15
 1000622:	4003      	ands	r3, r0
 1000624:	3b08      	subs	r3, #8
 1000626:	480a      	ldr	r0, [pc, #40]	; (1000650 <NVIC_SetPriority+0x4c>)
 1000628:	089b      	lsrs	r3, r3, #2
 100062a:	009b      	lsls	r3, r3, #2
 100062c:	181b      	adds	r3, r3, r0
 100062e:	69d8      	ldr	r0, [r3, #28]
 1000630:	4002      	ands	r2, r0
 1000632:	4311      	orrs	r1, r2
 1000634:	61d9      	str	r1, [r3, #28]
    {
        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
                                    (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    }
    return SUCCESS;
}
 1000636:	2001      	movs	r0, #1
 1000638:	bd30      	pop	{r4, r5, pc}
 100063a:	4b06      	ldr	r3, [pc, #24]	; (1000654 <NVIC_SetPriority+0x50>)
        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 100063c:	0880      	lsrs	r0, r0, #2
 100063e:	0080      	lsls	r0, r0, #2
 1000640:	18c0      	adds	r0, r0, r3
 1000642:	23c0      	movs	r3, #192	; 0xc0
 1000644:	009b      	lsls	r3, r3, #2
 1000646:	58c4      	ldr	r4, [r0, r3]
 1000648:	4022      	ands	r2, r4
 100064a:	4311      	orrs	r1, r2
 100064c:	50c1      	str	r1, [r0, r3]
 100064e:	e7f2      	b.n	1000636 <NVIC_SetPriority+0x32>
 1000650:	e000ed00 	.word	0xe000ed00
 1000654:	e000e100 	.word	0xe000e100

01000658 <trigger_PendSV>:

#define SBC_ICSR_PENDSV_IRQ	28
void trigger_PendSV(void)
{
    SCB->ICSR |= (1 << SBC_ICSR_PENDSV_IRQ);
 1000658:	2380      	movs	r3, #128	; 0x80
 100065a:	4a03      	ldr	r2, [pc, #12]	; (1000668 <trigger_PendSV+0x10>)
 100065c:	055b      	lsls	r3, r3, #21
 100065e:	6851      	ldr	r1, [r2, #4]
 1000660:	430b      	orrs	r3, r1
 1000662:	6053      	str	r3, [r2, #4]
}
 1000664:	4770      	bx	lr
 1000666:	46c0      	nop			; (mov r8, r8)
 1000668:	e000ed00 	.word	0xe000ed00

0100066c <NVIC_EnableIRQ>:
{
    SYSCTRL_CLK_CLS |= 1 << id;
}
static inline void enable_intr(int intid)
{
    NVIC_ISER |= 1 << intid;
 100066c:	2301      	movs	r3, #1
 100066e:	4083      	lsls	r3, r0
 1000670:	4a02      	ldr	r2, [pc, #8]	; (100067c <NVIC_EnableIRQ+0x10>)
 1000672:	6811      	ldr	r1, [r2, #0]
 1000674:	430b      	orrs	r3, r1
 1000676:	6013      	str	r3, [r2, #0]

void	NVIC_EnableIRQ(IRQn_Type IRQnx)
{
    enable_intr((int) IRQnx);
}
 1000678:	4770      	bx	lr
 100067a:	46c0      	nop			; (mov r8, r8)
 100067c:	e000e100 	.word	0xe000e100

01000680 <NVIC_DisableIRQ>:
}
static inline void disable_intr(int intid)
{
    NVIC_ICER = 1 << intid;
 1000680:	2301      	movs	r3, #1
 1000682:	4083      	lsls	r3, r0
 1000684:	4a01      	ldr	r2, [pc, #4]	; (100068c <NVIC_DisableIRQ+0xc>)
 1000686:	6013      	str	r3, [r2, #0]

void  NVIC_DisableIRQ(IRQn_Type IRQnx)
{
    disable_intr((int) IRQnx);
}
 1000688:	4770      	bx	lr
 100068a:	46c0      	nop			; (mov r8, r8)
 100068c:	e000e180 	.word	0xe000e180

01000690 <soft_reset>:

void soft_reset(void)
{
    SYSCTRL_RST_EN |= 0x01;
 1000690:	2301      	movs	r3, #1
 1000692:	4a04      	ldr	r2, [pc, #16]	; (10006a4 <soft_reset+0x14>)
 1000694:	6811      	ldr	r1, [r2, #0]
 1000696:	430b      	orrs	r3, r1
 1000698:	6013      	str	r3, [r2, #0]
    SYSCTRL_RESET = 0x55;
 100069a:	2255      	movs	r2, #85	; 0x55
 100069c:	4b02      	ldr	r3, [pc, #8]	; (10006a8 <soft_reset+0x18>)
 100069e:	601a      	str	r2, [r3, #0]
 10006a0:	e7fe      	b.n	10006a0 <soft_reset+0x10>
 10006a2:	46c0      	nop			; (mov r8, r8)
 10006a4:	000f8574 	.word	0x000f8574
 10006a8:	000f857c 	.word	0x000f857c

010006ac <get_primask>:
    while (1);
}

uint32_t get_primask(void)
{
    __asm volatile("mrs r0, primask");
 10006ac:	f3ef 8010 	mrs	r0, PRIMASK
}
 10006b0:	4770      	bx	lr

010006b2 <get_msp>:

uint32_t get_msp(void)
{
    __asm volatile("mrs r0, msp");
 10006b2:	f3ef 8008 	mrs	r0, MSP
}
 10006b6:	4770      	bx	lr

010006b8 <set_msp>:
    __asm volatile("msr msp,mainStackPointer");
}
#else
void set_msp(uint32_t mainStackPointer)
{
    __asm volatile("msr msp,r0");
 10006b8:	f380 8808 	msr	MSP, r0
}
 10006bc:	4770      	bx	lr
 10006be:	46c0      	nop			; (mov r8, r8)

010006c0 <GPIO_Config>:

#include "yc_gpio.h"
#include "yc_lpm.h"

void GPIO_Config(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, GPIO_FunTypeDef function)
{
 10006c0:	b570      	push	{r4, r5, r6, lr}
 10006c2:	0005      	movs	r5, r0
 10006c4:	000c      	movs	r4, r1
 10006c6:	0016      	movs	r6, r2
    _ASSERT(ISGPIOGROUP(GPIOx));
 10006c8:	2802      	cmp	r0, #2
 10006ca:	d904      	bls.n	10006d6 <GPIO_Config+0x16>
 10006cc:	4a21      	ldr	r2, [pc, #132]	; (1000754 <GPIO_Config+0x94>)
 10006ce:	210e      	movs	r1, #14
 10006d0:	4821      	ldr	r0, [pc, #132]	; (1000758 <GPIO_Config+0x98>)
 10006d2:	f7ff ff95 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 10006d6:	1e63      	subs	r3, r4, #1
 10006d8:	2b01      	cmp	r3, #1
 10006da:	d92c      	bls.n	1000736 <GPIO_Config+0x76>
 10006dc:	2204      	movs	r2, #4
 10006de:	1f23      	subs	r3, r4, #4
 10006e0:	4393      	bics	r3, r2
 10006e2:	b29b      	uxth	r3, r3
 10006e4:	2b00      	cmp	r3, #0
 10006e6:	d026      	beq.n	1000736 <GPIO_Config+0x76>
 10006e8:	0023      	movs	r3, r4
 10006ea:	320c      	adds	r2, #12
 10006ec:	3b10      	subs	r3, #16
 10006ee:	4393      	bics	r3, r2
 10006f0:	b29b      	uxth	r3, r3
 10006f2:	2b00      	cmp	r3, #0
 10006f4:	d01f      	beq.n	1000736 <GPIO_Config+0x76>
 10006f6:	0023      	movs	r3, r4
 10006f8:	3230      	adds	r2, #48	; 0x30
 10006fa:	3b40      	subs	r3, #64	; 0x40
 10006fc:	4393      	bics	r3, r2
 10006fe:	b29b      	uxth	r3, r3
 1000700:	2b00      	cmp	r3, #0
 1000702:	d018      	beq.n	1000736 <GPIO_Config+0x76>
 1000704:	1e63      	subs	r3, r4, #1
 1000706:	4a15      	ldr	r2, [pc, #84]	; (100075c <GPIO_Config+0x9c>)
 1000708:	3bff      	subs	r3, #255	; 0xff
 100070a:	4213      	tst	r3, r2
 100070c:	d013      	beq.n	1000736 <GPIO_Config+0x76>
 100070e:	4b14      	ldr	r3, [pc, #80]	; (1000760 <GPIO_Config+0xa0>)
 1000710:	4a14      	ldr	r2, [pc, #80]	; (1000764 <GPIO_Config+0xa4>)
 1000712:	18e3      	adds	r3, r4, r3
 1000714:	4213      	tst	r3, r2
 1000716:	d00e      	beq.n	1000736 <GPIO_Config+0x76>
 1000718:	4b13      	ldr	r3, [pc, #76]	; (1000768 <GPIO_Config+0xa8>)
 100071a:	4a14      	ldr	r2, [pc, #80]	; (100076c <GPIO_Config+0xac>)
 100071c:	18e3      	adds	r3, r4, r3
 100071e:	4213      	tst	r3, r2
 1000720:	d009      	beq.n	1000736 <GPIO_Config+0x76>
 1000722:	4b13      	ldr	r3, [pc, #76]	; (1000770 <GPIO_Config+0xb0>)
 1000724:	4a13      	ldr	r2, [pc, #76]	; (1000774 <GPIO_Config+0xb4>)
 1000726:	18e3      	adds	r3, r4, r3
 1000728:	4213      	tst	r3, r2
 100072a:	d004      	beq.n	1000736 <GPIO_Config+0x76>
 100072c:	4a09      	ldr	r2, [pc, #36]	; (1000754 <GPIO_Config+0x94>)
 100072e:	210f      	movs	r1, #15
 1000730:	4809      	ldr	r0, [pc, #36]	; (1000758 <GPIO_Config+0x98>)
 1000732:	f7ff ff65 	bl	1000600 <_assert_handler>
    int i;

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (GPIO_Pin & 1 << i)
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = function;
 1000736:	4b10      	ldr	r3, [pc, #64]	; (1000778 <GPIO_Config+0xb8>)
        if (GPIO_Pin & 1 << i)
 1000738:	2201      	movs	r2, #1
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = function;
 100073a:	18ed      	adds	r5, r5, r3
 100073c:	2300      	movs	r3, #0
 100073e:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 1000740:	0021      	movs	r1, r4
 1000742:	4119      	asrs	r1, r3
 1000744:	4211      	tst	r1, r2
 1000746:	d001      	beq.n	100074c <GPIO_Config+0x8c>
 1000748:	1959      	adds	r1, r3, r5
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = function;
 100074a:	700e      	strb	r6, [r1, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 100074c:	3301      	adds	r3, #1
 100074e:	2b10      	cmp	r3, #16
 1000750:	d1f6      	bne.n	1000740 <GPIO_Config+0x80>
    }
}
 1000752:	bd70      	pop	{r4, r5, r6, pc}
 1000754:	010023f3 	.word	0x010023f3
 1000758:	010023cc 	.word	0x010023cc
 100075c:	0000feff 	.word	0x0000feff
 1000760:	fffffc00 	.word	0xfffffc00
 1000764:	0000fbff 	.word	0x0000fbff
 1000768:	fffff000 	.word	0xfffff000
 100076c:	0000efff 	.word	0x0000efff
 1000770:	ffffc000 	.word	0xffffc000
 1000774:	0000bfff 	.word	0x0000bfff
 1000778:	0000f870 	.word	0x0000f870

0100077c <GPIO_Init>:

void GPIO_Init(GPIO_TypeDef GPIOx, GPIO_InitTypeDef *GPIO_InitStruct)
{
 100077c:	b570      	push	{r4, r5, r6, lr}
 100077e:	0004      	movs	r4, r0
 1000780:	000d      	movs	r5, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000782:	2802      	cmp	r0, #2
 1000784:	d904      	bls.n	1000790 <GPIO_Init+0x14>
 1000786:	4a2f      	ldr	r2, [pc, #188]	; (1000844 <GPIO_Init+0xc8>)
 1000788:	211c      	movs	r1, #28
 100078a:	482f      	ldr	r0, [pc, #188]	; (1000848 <GPIO_Init+0xcc>)
 100078c:	f7ff ff38 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
 1000790:	882b      	ldrh	r3, [r5, #0]
 1000792:	2b00      	cmp	r3, #0
 1000794:	d104      	bne.n	10007a0 <GPIO_Init+0x24>
 1000796:	4a2b      	ldr	r2, [pc, #172]	; (1000844 <GPIO_Init+0xc8>)
 1000798:	211d      	movs	r1, #29
 100079a:	482b      	ldr	r0, [pc, #172]	; (1000848 <GPIO_Init+0xcc>)
 100079c:	f7ff ff30 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
 10007a0:	78ab      	ldrb	r3, [r5, #2]
 10007a2:	3b01      	subs	r3, #1
 10007a4:	2b04      	cmp	r3, #4
 10007a6:	d904      	bls.n	10007b2 <GPIO_Init+0x36>
 10007a8:	4a26      	ldr	r2, [pc, #152]	; (1000844 <GPIO_Init+0xc8>)
 10007aa:	211e      	movs	r1, #30
 10007ac:	4826      	ldr	r0, [pc, #152]	; (1000848 <GPIO_Init+0xcc>)
 10007ae:	f7ff ff27 	bl	1000600 <_assert_handler>

    int i;

    switch (GPIO_InitStruct->GPIO_Mode)
 10007b2:	78a8      	ldrb	r0, [r5, #2]
 10007b4:	3801      	subs	r0, #1
 10007b6:	2804      	cmp	r0, #4
 10007b8:	d813      	bhi.n	10007e2 <GPIO_Init+0x66>
 10007ba:	4b24      	ldr	r3, [pc, #144]	; (100084c <GPIO_Init+0xd0>)
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0xC0;
        }
        break;

    case GPIO_Mode_Out_PP:
        for (i = 0; i < GPIO_PIN_NUM; i++)
 10007bc:	2200      	movs	r2, #0
 10007be:	18e3      	adds	r3, r4, r3
        {
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x3E;
 10007c0:	011b      	lsls	r3, r3, #4
    switch (GPIO_InitStruct->GPIO_Mode)
 10007c2:	f001 fc5f 	bl	1002084 <__gnu_thumb1_case_uqi>
 10007c6:	0f03      	.short	0x0f03
 10007c8:	271b      	.short	0x271b
 10007ca:	33          	.byte	0x33
 10007cb:	00          	.byte	0x00
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007cc:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x00;
 10007ce:	0014      	movs	r4, r2
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007d0:	8829      	ldrh	r1, [r5, #0]
 10007d2:	4111      	asrs	r1, r2
 10007d4:	4201      	tst	r1, r0
 10007d6:	d001      	beq.n	10007dc <GPIO_Init+0x60>
 10007d8:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x00;
 10007da:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 10007dc:	3201      	adds	r2, #1
 10007de:	2a10      	cmp	r2, #16
 10007e0:	d1f6      	bne.n	10007d0 <GPIO_Init+0x54>
        break;

    default:
        break;
    }
}
 10007e2:	bd70      	pop	{r4, r5, r6, pc}
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007e4:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x40;
 10007e6:	2440      	movs	r4, #64	; 0x40
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007e8:	8829      	ldrh	r1, [r5, #0]
 10007ea:	4111      	asrs	r1, r2
 10007ec:	4201      	tst	r1, r0
 10007ee:	d001      	beq.n	10007f4 <GPIO_Init+0x78>
 10007f0:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x40;
 10007f2:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 10007f4:	3201      	adds	r2, #1
 10007f6:	2a10      	cmp	r2, #16
 10007f8:	d1f6      	bne.n	10007e8 <GPIO_Init+0x6c>
 10007fa:	e7f2      	b.n	10007e2 <GPIO_Init+0x66>
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 10007fc:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x80;
 10007fe:	2480      	movs	r4, #128	; 0x80
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000800:	8829      	ldrh	r1, [r5, #0]
 1000802:	4111      	asrs	r1, r2
 1000804:	4201      	tst	r1, r0
 1000806:	d001      	beq.n	100080c <GPIO_Init+0x90>
 1000808:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x80;
 100080a:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 100080c:	3201      	adds	r2, #1
 100080e:	2a10      	cmp	r2, #16
 1000810:	d1f6      	bne.n	1000800 <GPIO_Init+0x84>
 1000812:	e7e6      	b.n	10007e2 <GPIO_Init+0x66>
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000814:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0xC0;
 1000816:	24c0      	movs	r4, #192	; 0xc0
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000818:	8829      	ldrh	r1, [r5, #0]
 100081a:	4111      	asrs	r1, r2
 100081c:	4201      	tst	r1, r0
 100081e:	d001      	beq.n	1000824 <GPIO_Init+0xa8>
 1000820:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0xC0;
 1000822:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 1000824:	3201      	adds	r2, #1
 1000826:	2a10      	cmp	r2, #16
 1000828:	d1f6      	bne.n	1000818 <GPIO_Init+0x9c>
 100082a:	e7da      	b.n	10007e2 <GPIO_Init+0x66>
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 100082c:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x3E;
 100082e:	243e      	movs	r4, #62	; 0x3e
            if (GPIO_InitStruct->GPIO_Pin & 1 << i)
 1000830:	8829      	ldrh	r1, [r5, #0]
 1000832:	4111      	asrs	r1, r2
 1000834:	4201      	tst	r1, r0
 1000836:	d001      	beq.n	100083c <GPIO_Init+0xc0>
 1000838:	18d1      	adds	r1, r2, r3
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = 0x3E;
 100083a:	700c      	strb	r4, [r1, #0]
        for (i = 0; i < GPIO_PIN_NUM; i++)
 100083c:	3201      	adds	r2, #1
 100083e:	2a10      	cmp	r2, #16
 1000840:	d1f6      	bne.n	1000830 <GPIO_Init+0xb4>
 1000842:	e7ce      	b.n	10007e2 <GPIO_Init+0x66>
 1000844:	010023ff 	.word	0x010023ff
 1000848:	010023cc 	.word	0x010023cc
 100084c:	0000f870 	.word	0x0000f870

01000850 <GPIO_PullUpCmd>:

void GPIO_PullUpCmd(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, FunctionalState NewState)
{
 1000850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1000852:	0005      	movs	r5, r0
 1000854:	000c      	movs	r4, r1
 1000856:	0016      	movs	r6, r2
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000858:	2802      	cmp	r0, #2
 100085a:	d904      	bls.n	1000866 <GPIO_PullUpCmd+0x16>
 100085c:	4a27      	ldr	r2, [pc, #156]	; (10008fc <GPIO_PullUpCmd+0xac>)
 100085e:	2153      	movs	r1, #83	; 0x53
 1000860:	4827      	ldr	r0, [pc, #156]	; (1000900 <GPIO_PullUpCmd+0xb0>)
 1000862:	f7ff fecd 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000866:	1e63      	subs	r3, r4, #1
 1000868:	2b01      	cmp	r3, #1
 100086a:	d92c      	bls.n	10008c6 <GPIO_PullUpCmd+0x76>
 100086c:	2204      	movs	r2, #4
 100086e:	1f23      	subs	r3, r4, #4
 1000870:	4393      	bics	r3, r2
 1000872:	b29b      	uxth	r3, r3
 1000874:	2b00      	cmp	r3, #0
 1000876:	d026      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 1000878:	0023      	movs	r3, r4
 100087a:	320c      	adds	r2, #12
 100087c:	3b10      	subs	r3, #16
 100087e:	4393      	bics	r3, r2
 1000880:	b29b      	uxth	r3, r3
 1000882:	2b00      	cmp	r3, #0
 1000884:	d01f      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 1000886:	0023      	movs	r3, r4
 1000888:	3230      	adds	r2, #48	; 0x30
 100088a:	3b40      	subs	r3, #64	; 0x40
 100088c:	4393      	bics	r3, r2
 100088e:	b29b      	uxth	r3, r3
 1000890:	2b00      	cmp	r3, #0
 1000892:	d018      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 1000894:	1e63      	subs	r3, r4, #1
 1000896:	4a1b      	ldr	r2, [pc, #108]	; (1000904 <GPIO_PullUpCmd+0xb4>)
 1000898:	3bff      	subs	r3, #255	; 0xff
 100089a:	4213      	tst	r3, r2
 100089c:	d013      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 100089e:	4b1a      	ldr	r3, [pc, #104]	; (1000908 <GPIO_PullUpCmd+0xb8>)
 10008a0:	4a1a      	ldr	r2, [pc, #104]	; (100090c <GPIO_PullUpCmd+0xbc>)
 10008a2:	18e3      	adds	r3, r4, r3
 10008a4:	4213      	tst	r3, r2
 10008a6:	d00e      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 10008a8:	4b19      	ldr	r3, [pc, #100]	; (1000910 <GPIO_PullUpCmd+0xc0>)
 10008aa:	4a1a      	ldr	r2, [pc, #104]	; (1000914 <GPIO_PullUpCmd+0xc4>)
 10008ac:	18e3      	adds	r3, r4, r3
 10008ae:	4213      	tst	r3, r2
 10008b0:	d009      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 10008b2:	4b19      	ldr	r3, [pc, #100]	; (1000918 <GPIO_PullUpCmd+0xc8>)
 10008b4:	4a19      	ldr	r2, [pc, #100]	; (100091c <GPIO_PullUpCmd+0xcc>)
 10008b6:	18e3      	adds	r3, r4, r3
 10008b8:	4213      	tst	r3, r2
 10008ba:	d004      	beq.n	10008c6 <GPIO_PullUpCmd+0x76>
 10008bc:	4a0f      	ldr	r2, [pc, #60]	; (10008fc <GPIO_PullUpCmd+0xac>)
 10008be:	2154      	movs	r1, #84	; 0x54
 10008c0:	480f      	ldr	r0, [pc, #60]	; (1000900 <GPIO_PullUpCmd+0xb0>)
 10008c2:	f7ff fe9d 	bl	1000600 <_assert_handler>
            {
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 1 << 6;
            }
            else if (NewState == DISABLE)
            {
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008c6:	4b16      	ldr	r3, [pc, #88]	; (1000920 <GPIO_PullUpCmd+0xd0>)
        if (GPIO_Pin & 1 << i)
 10008c8:	2001      	movs	r0, #1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008ca:	18ed      	adds	r5, r5, r3
 10008cc:	2140      	movs	r1, #64	; 0x40
 10008ce:	2300      	movs	r3, #0
 10008d0:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 10008d2:	0022      	movs	r2, r4
 10008d4:	411a      	asrs	r2, r3
 10008d6:	4202      	tst	r2, r0
 10008d8:	d005      	beq.n	10008e6 <GPIO_PullUpCmd+0x96>
            if (NewState == ENABLE)
 10008da:	2e01      	cmp	r6, #1
 10008dc:	d107      	bne.n	10008ee <GPIO_PullUpCmd+0x9e>
 10008de:	195f      	adds	r7, r3, r5
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 1 << 6;
 10008e0:	783a      	ldrb	r2, [r7, #0]
 10008e2:	430a      	orrs	r2, r1
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008e4:	703a      	strb	r2, [r7, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 10008e6:	3301      	adds	r3, #1
 10008e8:	2b10      	cmp	r3, #16
 10008ea:	d1f2      	bne.n	10008d2 <GPIO_PullUpCmd+0x82>
            }
        }
    }
}
 10008ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            else if (NewState == DISABLE)
 10008ee:	2e00      	cmp	r6, #0
 10008f0:	d1f9      	bne.n	10008e6 <GPIO_PullUpCmd+0x96>
 10008f2:	195f      	adds	r7, r3, r5
                GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) &= ~(1 << 6);
 10008f4:	783a      	ldrb	r2, [r7, #0]
 10008f6:	438a      	bics	r2, r1
 10008f8:	e7f4      	b.n	10008e4 <GPIO_PullUpCmd+0x94>
 10008fa:	46c0      	nop			; (mov r8, r8)
 10008fc:	01002409 	.word	0x01002409
 1000900:	010023cc 	.word	0x010023cc
 1000904:	0000feff 	.word	0x0000feff
 1000908:	fffffc00 	.word	0xfffffc00
 100090c:	0000fbff 	.word	0x0000fbff
 1000910:	fffff000 	.word	0xfffff000
 1000914:	0000efff 	.word	0x0000efff
 1000918:	ffffc000 	.word	0xffffc000
 100091c:	0000bfff 	.word	0x0000bfff
 1000920:	0000f870 	.word	0x0000f870

01000924 <GPIO_ReadInputData>:

uint16_t GPIO_ReadInputData(GPIO_TypeDef GPIOx)
{
 1000924:	b510      	push	{r4, lr}
 1000926:	0004      	movs	r4, r0
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000928:	2802      	cmp	r0, #2
 100092a:	d904      	bls.n	1000936 <GPIO_ReadInputData+0x12>
 100092c:	4a05      	ldr	r2, [pc, #20]	; (1000944 <GPIO_ReadInputData+0x20>)
 100092e:	216a      	movs	r1, #106	; 0x6a
 1000930:	4805      	ldr	r0, [pc, #20]	; (1000948 <GPIO_ReadInputData+0x24>)
 1000932:	f7ff fe65 	bl	1000600 <_assert_handler>

    return GPIO_IN(GPIOx);
 1000936:	4b05      	ldr	r3, [pc, #20]	; (100094c <GPIO_ReadInputData+0x28>)
 1000938:	0064      	lsls	r4, r4, #1
 100093a:	18e4      	adds	r4, r4, r3
 100093c:	8820      	ldrh	r0, [r4, #0]
 100093e:	b280      	uxth	r0, r0
}
 1000940:	bd10      	pop	{r4, pc}
 1000942:	46c0      	nop			; (mov r8, r8)
 1000944:	01002418 	.word	0x01002418
 1000948:	010023cc 	.word	0x010023cc
 100094c:	000f873c 	.word	0x000f873c

01000950 <GPIO_ReadInputDataBit>:

uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000950:	b570      	push	{r4, r5, r6, lr}
 1000952:	0005      	movs	r5, r0
 1000954:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000956:	2802      	cmp	r0, #2
 1000958:	d904      	bls.n	1000964 <GPIO_ReadInputDataBit+0x14>
 100095a:	4a1f      	ldr	r2, [pc, #124]	; (10009d8 <GPIO_ReadInputDataBit+0x88>)
 100095c:	2171      	movs	r1, #113	; 0x71
 100095e:	481f      	ldr	r0, [pc, #124]	; (10009dc <GPIO_ReadInputDataBit+0x8c>)
 1000960:	f7ff fe4e 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000964:	1e63      	subs	r3, r4, #1
 1000966:	2b01      	cmp	r3, #1
 1000968:	d92c      	bls.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 100096a:	2204      	movs	r2, #4
 100096c:	1f23      	subs	r3, r4, #4
 100096e:	4393      	bics	r3, r2
 1000970:	b29b      	uxth	r3, r3
 1000972:	2b00      	cmp	r3, #0
 1000974:	d026      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 1000976:	0023      	movs	r3, r4
 1000978:	320c      	adds	r2, #12
 100097a:	3b10      	subs	r3, #16
 100097c:	4393      	bics	r3, r2
 100097e:	b29b      	uxth	r3, r3
 1000980:	2b00      	cmp	r3, #0
 1000982:	d01f      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 1000984:	0023      	movs	r3, r4
 1000986:	3230      	adds	r2, #48	; 0x30
 1000988:	3b40      	subs	r3, #64	; 0x40
 100098a:	4393      	bics	r3, r2
 100098c:	b29b      	uxth	r3, r3
 100098e:	2b00      	cmp	r3, #0
 1000990:	d018      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 1000992:	1e63      	subs	r3, r4, #1
 1000994:	4a12      	ldr	r2, [pc, #72]	; (10009e0 <GPIO_ReadInputDataBit+0x90>)
 1000996:	3bff      	subs	r3, #255	; 0xff
 1000998:	4213      	tst	r3, r2
 100099a:	d013      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 100099c:	4b11      	ldr	r3, [pc, #68]	; (10009e4 <GPIO_ReadInputDataBit+0x94>)
 100099e:	4a12      	ldr	r2, [pc, #72]	; (10009e8 <GPIO_ReadInputDataBit+0x98>)
 10009a0:	18e3      	adds	r3, r4, r3
 10009a2:	4213      	tst	r3, r2
 10009a4:	d00e      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 10009a6:	4b11      	ldr	r3, [pc, #68]	; (10009ec <GPIO_ReadInputDataBit+0x9c>)
 10009a8:	4a11      	ldr	r2, [pc, #68]	; (10009f0 <GPIO_ReadInputDataBit+0xa0>)
 10009aa:	18e3      	adds	r3, r4, r3
 10009ac:	4213      	tst	r3, r2
 10009ae:	d009      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 10009b0:	4b10      	ldr	r3, [pc, #64]	; (10009f4 <GPIO_ReadInputDataBit+0xa4>)
 10009b2:	4a11      	ldr	r2, [pc, #68]	; (10009f8 <GPIO_ReadInputDataBit+0xa8>)
 10009b4:	18e3      	adds	r3, r4, r3
 10009b6:	4213      	tst	r3, r2
 10009b8:	d004      	beq.n	10009c4 <GPIO_ReadInputDataBit+0x74>
 10009ba:	4a07      	ldr	r2, [pc, #28]	; (10009d8 <GPIO_ReadInputDataBit+0x88>)
 10009bc:	2172      	movs	r1, #114	; 0x72
 10009be:	4807      	ldr	r0, [pc, #28]	; (10009dc <GPIO_ReadInputDataBit+0x8c>)
 10009c0:	f7ff fe1e 	bl	1000600 <_assert_handler>

    if (GPIO_IN(GPIOx) & GPIO_Pin)
 10009c4:	4b0d      	ldr	r3, [pc, #52]	; (10009fc <GPIO_ReadInputDataBit+0xac>)
 10009c6:	006d      	lsls	r5, r5, #1
 10009c8:	18ed      	adds	r5, r5, r3
 10009ca:	8828      	ldrh	r0, [r5, #0]
 10009cc:	4004      	ands	r4, r0
 10009ce:	1e60      	subs	r0, r4, #1
 10009d0:	4184      	sbcs	r4, r0
 10009d2:	b2e0      	uxtb	r0, r4
    }
    else
    {
        return (uint8_t)0x00;
    }
}
 10009d4:	bd70      	pop	{r4, r5, r6, pc}
 10009d6:	46c0      	nop			; (mov r8, r8)
 10009d8:	0100242b 	.word	0x0100242b
 10009dc:	010023cc 	.word	0x010023cc
 10009e0:	0000feff 	.word	0x0000feff
 10009e4:	fffffc00 	.word	0xfffffc00
 10009e8:	0000fbff 	.word	0x0000fbff
 10009ec:	fffff000 	.word	0xfffff000
 10009f0:	0000efff 	.word	0x0000efff
 10009f4:	ffffc000 	.word	0xffffc000
 10009f8:	0000bfff 	.word	0x0000bfff
 10009fc:	000f873c 	.word	0x000f873c

01000a00 <GPIO_ReadOutputData>:

uint16_t GPIO_ReadOutputData(GPIO_TypeDef GPIOx)
{
 1000a00:	b510      	push	{r4, lr}
 1000a02:	0004      	movs	r4, r0
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000a04:	2802      	cmp	r0, #2
 1000a06:	d904      	bls.n	1000a12 <GPIO_ReadOutputData+0x12>
 1000a08:	4a05      	ldr	r2, [pc, #20]	; (1000a20 <GPIO_ReadOutputData+0x20>)
 1000a0a:	2180      	movs	r1, #128	; 0x80
 1000a0c:	4805      	ldr	r0, [pc, #20]	; (1000a24 <GPIO_ReadOutputData+0x24>)
 1000a0e:	f7ff fdf7 	bl	1000600 <_assert_handler>

    return GPIO_IN(GPIOx);
 1000a12:	4b05      	ldr	r3, [pc, #20]	; (1000a28 <GPIO_ReadOutputData+0x28>)
 1000a14:	0064      	lsls	r4, r4, #1
 1000a16:	18e4      	adds	r4, r4, r3
 1000a18:	8820      	ldrh	r0, [r4, #0]
 1000a1a:	b280      	uxth	r0, r0
}
 1000a1c:	bd10      	pop	{r4, pc}
 1000a1e:	46c0      	nop			; (mov r8, r8)
 1000a20:	01002441 	.word	0x01002441
 1000a24:	010023cc 	.word	0x010023cc
 1000a28:	000f873c 	.word	0x000f873c

01000a2c <GPIO_ReadOutputDataBit>:

uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000a2c:	b570      	push	{r4, r5, r6, lr}
 1000a2e:	0005      	movs	r5, r0
 1000a30:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000a32:	2802      	cmp	r0, #2
 1000a34:	d904      	bls.n	1000a40 <GPIO_ReadOutputDataBit+0x14>
 1000a36:	4a1f      	ldr	r2, [pc, #124]	; (1000ab4 <GPIO_ReadOutputDataBit+0x88>)
 1000a38:	2187      	movs	r1, #135	; 0x87
 1000a3a:	481f      	ldr	r0, [pc, #124]	; (1000ab8 <GPIO_ReadOutputDataBit+0x8c>)
 1000a3c:	f7ff fde0 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000a40:	1e63      	subs	r3, r4, #1
 1000a42:	2b01      	cmp	r3, #1
 1000a44:	d92c      	bls.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a46:	2204      	movs	r2, #4
 1000a48:	1f23      	subs	r3, r4, #4
 1000a4a:	4393      	bics	r3, r2
 1000a4c:	b29b      	uxth	r3, r3
 1000a4e:	2b00      	cmp	r3, #0
 1000a50:	d026      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a52:	0023      	movs	r3, r4
 1000a54:	320c      	adds	r2, #12
 1000a56:	3b10      	subs	r3, #16
 1000a58:	4393      	bics	r3, r2
 1000a5a:	b29b      	uxth	r3, r3
 1000a5c:	2b00      	cmp	r3, #0
 1000a5e:	d01f      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a60:	0023      	movs	r3, r4
 1000a62:	3230      	adds	r2, #48	; 0x30
 1000a64:	3b40      	subs	r3, #64	; 0x40
 1000a66:	4393      	bics	r3, r2
 1000a68:	b29b      	uxth	r3, r3
 1000a6a:	2b00      	cmp	r3, #0
 1000a6c:	d018      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a6e:	1e63      	subs	r3, r4, #1
 1000a70:	4a12      	ldr	r2, [pc, #72]	; (1000abc <GPIO_ReadOutputDataBit+0x90>)
 1000a72:	3bff      	subs	r3, #255	; 0xff
 1000a74:	4213      	tst	r3, r2
 1000a76:	d013      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a78:	4b11      	ldr	r3, [pc, #68]	; (1000ac0 <GPIO_ReadOutputDataBit+0x94>)
 1000a7a:	4a12      	ldr	r2, [pc, #72]	; (1000ac4 <GPIO_ReadOutputDataBit+0x98>)
 1000a7c:	18e3      	adds	r3, r4, r3
 1000a7e:	4213      	tst	r3, r2
 1000a80:	d00e      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a82:	4b11      	ldr	r3, [pc, #68]	; (1000ac8 <GPIO_ReadOutputDataBit+0x9c>)
 1000a84:	4a11      	ldr	r2, [pc, #68]	; (1000acc <GPIO_ReadOutputDataBit+0xa0>)
 1000a86:	18e3      	adds	r3, r4, r3
 1000a88:	4213      	tst	r3, r2
 1000a8a:	d009      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a8c:	4b10      	ldr	r3, [pc, #64]	; (1000ad0 <GPIO_ReadOutputDataBit+0xa4>)
 1000a8e:	4a11      	ldr	r2, [pc, #68]	; (1000ad4 <GPIO_ReadOutputDataBit+0xa8>)
 1000a90:	18e3      	adds	r3, r4, r3
 1000a92:	4213      	tst	r3, r2
 1000a94:	d004      	beq.n	1000aa0 <GPIO_ReadOutputDataBit+0x74>
 1000a96:	4a07      	ldr	r2, [pc, #28]	; (1000ab4 <GPIO_ReadOutputDataBit+0x88>)
 1000a98:	2188      	movs	r1, #136	; 0x88
 1000a9a:	4807      	ldr	r0, [pc, #28]	; (1000ab8 <GPIO_ReadOutputDataBit+0x8c>)
 1000a9c:	f7ff fdb0 	bl	1000600 <_assert_handler>

    if (GPIO_IN(GPIOx) & GPIO_Pin)
 1000aa0:	4b0d      	ldr	r3, [pc, #52]	; (1000ad8 <GPIO_ReadOutputDataBit+0xac>)
 1000aa2:	006d      	lsls	r5, r5, #1
 1000aa4:	18ed      	adds	r5, r5, r3
 1000aa6:	8828      	ldrh	r0, [r5, #0]
 1000aa8:	4004      	ands	r4, r0
 1000aaa:	1e60      	subs	r0, r4, #1
 1000aac:	4184      	sbcs	r4, r0
 1000aae:	b2e0      	uxtb	r0, r4
    }
    else
    {
        return (uint8_t)0x00;
    }
}
 1000ab0:	bd70      	pop	{r4, r5, r6, pc}
 1000ab2:	46c0      	nop			; (mov r8, r8)
 1000ab4:	01002455 	.word	0x01002455
 1000ab8:	010023cc 	.word	0x010023cc
 1000abc:	0000feff 	.word	0x0000feff
 1000ac0:	fffffc00 	.word	0xfffffc00
 1000ac4:	0000fbff 	.word	0x0000fbff
 1000ac8:	fffff000 	.word	0xfffff000
 1000acc:	0000efff 	.word	0x0000efff
 1000ad0:	ffffc000 	.word	0xffffc000
 1000ad4:	0000bfff 	.word	0x0000bfff
 1000ad8:	000f873c 	.word	0x000f873c

01000adc <GPIO_ResetBits>:

void GPIO_ResetBits(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000adc:	b570      	push	{r4, r5, r6, lr}
 1000ade:	0005      	movs	r5, r0
 1000ae0:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000ae2:	2802      	cmp	r0, #2
 1000ae4:	d904      	bls.n	1000af0 <GPIO_ResetBits+0x14>
 1000ae6:	4a24      	ldr	r2, [pc, #144]	; (1000b78 <GPIO_ResetBits+0x9c>)
 1000ae8:	2196      	movs	r1, #150	; 0x96
 1000aea:	4824      	ldr	r0, [pc, #144]	; (1000b7c <GPIO_ResetBits+0xa0>)
 1000aec:	f7ff fd88 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000af0:	1e63      	subs	r3, r4, #1
 1000af2:	2b01      	cmp	r3, #1
 1000af4:	d92c      	bls.n	1000b50 <GPIO_ResetBits+0x74>
 1000af6:	2204      	movs	r2, #4
 1000af8:	1f23      	subs	r3, r4, #4
 1000afa:	4393      	bics	r3, r2
 1000afc:	b29b      	uxth	r3, r3
 1000afe:	2b00      	cmp	r3, #0
 1000b00:	d026      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b02:	0023      	movs	r3, r4
 1000b04:	320c      	adds	r2, #12
 1000b06:	3b10      	subs	r3, #16
 1000b08:	4393      	bics	r3, r2
 1000b0a:	b29b      	uxth	r3, r3
 1000b0c:	2b00      	cmp	r3, #0
 1000b0e:	d01f      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b10:	0023      	movs	r3, r4
 1000b12:	3230      	adds	r2, #48	; 0x30
 1000b14:	3b40      	subs	r3, #64	; 0x40
 1000b16:	4393      	bics	r3, r2
 1000b18:	b29b      	uxth	r3, r3
 1000b1a:	2b00      	cmp	r3, #0
 1000b1c:	d018      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b1e:	1e63      	subs	r3, r4, #1
 1000b20:	4a17      	ldr	r2, [pc, #92]	; (1000b80 <GPIO_ResetBits+0xa4>)
 1000b22:	3bff      	subs	r3, #255	; 0xff
 1000b24:	4213      	tst	r3, r2
 1000b26:	d013      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b28:	4b16      	ldr	r3, [pc, #88]	; (1000b84 <GPIO_ResetBits+0xa8>)
 1000b2a:	4a17      	ldr	r2, [pc, #92]	; (1000b88 <GPIO_ResetBits+0xac>)
 1000b2c:	18e3      	adds	r3, r4, r3
 1000b2e:	4213      	tst	r3, r2
 1000b30:	d00e      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b32:	4b16      	ldr	r3, [pc, #88]	; (1000b8c <GPIO_ResetBits+0xb0>)
 1000b34:	4a16      	ldr	r2, [pc, #88]	; (1000b90 <GPIO_ResetBits+0xb4>)
 1000b36:	18e3      	adds	r3, r4, r3
 1000b38:	4213      	tst	r3, r2
 1000b3a:	d009      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b3c:	4b15      	ldr	r3, [pc, #84]	; (1000b94 <GPIO_ResetBits+0xb8>)
 1000b3e:	4a16      	ldr	r2, [pc, #88]	; (1000b98 <GPIO_ResetBits+0xbc>)
 1000b40:	18e3      	adds	r3, r4, r3
 1000b42:	4213      	tst	r3, r2
 1000b44:	d004      	beq.n	1000b50 <GPIO_ResetBits+0x74>
 1000b46:	4a0c      	ldr	r2, [pc, #48]	; (1000b78 <GPIO_ResetBits+0x9c>)
 1000b48:	2197      	movs	r1, #151	; 0x97
 1000b4a:	480c      	ldr	r0, [pc, #48]	; (1000b7c <GPIO_ResetBits+0xa0>)
 1000b4c:	f7ff fd58 	bl	1000600 <_assert_handler>

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (GPIO_Pin & 1 << i)
        {
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b50:	4b12      	ldr	r3, [pc, #72]	; (1000b9c <GPIO_ResetBits+0xc0>)
        if (GPIO_Pin & 1 << i)
 1000b52:	2101      	movs	r1, #1
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b54:	18ed      	adds	r5, r5, r3
            Temp |= 0x3F; //00111111
            Temp &= 0xFE; //11111110
 1000b56:	263e      	movs	r6, #62	; 0x3e
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b58:	2300      	movs	r3, #0
 1000b5a:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 1000b5c:	0022      	movs	r2, r4
 1000b5e:	411a      	asrs	r2, r3
 1000b60:	420a      	tst	r2, r1
 1000b62:	d004      	beq.n	1000b6e <GPIO_ResetBits+0x92>
 1000b64:	1958      	adds	r0, r3, r5
            Temp = GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i);
 1000b66:	7802      	ldrb	r2, [r0, #0]
 1000b68:	438a      	bics	r2, r1
            Temp &= 0xFE; //11111110
 1000b6a:	4332      	orrs	r2, r6
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) = Temp;
 1000b6c:	7002      	strb	r2, [r0, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000b6e:	3301      	adds	r3, #1
 1000b70:	2b10      	cmp	r3, #16
 1000b72:	d1f3      	bne.n	1000b5c <GPIO_ResetBits+0x80>
        }
    }
}
 1000b74:	bd70      	pop	{r4, r5, r6, pc}
 1000b76:	46c0      	nop			; (mov r8, r8)
 1000b78:	0100246c 	.word	0x0100246c
 1000b7c:	010023cc 	.word	0x010023cc
 1000b80:	0000feff 	.word	0x0000feff
 1000b84:	fffffc00 	.word	0xfffffc00
 1000b88:	0000fbff 	.word	0x0000fbff
 1000b8c:	fffff000 	.word	0xfffff000
 1000b90:	0000efff 	.word	0x0000efff
 1000b94:	ffffc000 	.word	0xffffc000
 1000b98:	0000bfff 	.word	0x0000bfff
 1000b9c:	0000f870 	.word	0x0000f870

01000ba0 <GPIO_SetBits>:

void GPIO_SetBits(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin)
{
 1000ba0:	b570      	push	{r4, r5, r6, lr}
 1000ba2:	0005      	movs	r5, r0
 1000ba4:	000c      	movs	r4, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000ba6:	2802      	cmp	r0, #2
 1000ba8:	d904      	bls.n	1000bb4 <GPIO_SetBits+0x14>
 1000baa:	4a23      	ldr	r2, [pc, #140]	; (1000c38 <GPIO_SetBits+0x98>)
 1000bac:	21aa      	movs	r1, #170	; 0xaa
 1000bae:	4823      	ldr	r0, [pc, #140]	; (1000c3c <GPIO_SetBits+0x9c>)
 1000bb0:	f7ff fd26 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000bb4:	1e63      	subs	r3, r4, #1
 1000bb6:	2b01      	cmp	r3, #1
 1000bb8:	d92c      	bls.n	1000c14 <GPIO_SetBits+0x74>
 1000bba:	2204      	movs	r2, #4
 1000bbc:	1f23      	subs	r3, r4, #4
 1000bbe:	4393      	bics	r3, r2
 1000bc0:	b29b      	uxth	r3, r3
 1000bc2:	2b00      	cmp	r3, #0
 1000bc4:	d026      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000bc6:	0023      	movs	r3, r4
 1000bc8:	320c      	adds	r2, #12
 1000bca:	3b10      	subs	r3, #16
 1000bcc:	4393      	bics	r3, r2
 1000bce:	b29b      	uxth	r3, r3
 1000bd0:	2b00      	cmp	r3, #0
 1000bd2:	d01f      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000bd4:	0023      	movs	r3, r4
 1000bd6:	3230      	adds	r2, #48	; 0x30
 1000bd8:	3b40      	subs	r3, #64	; 0x40
 1000bda:	4393      	bics	r3, r2
 1000bdc:	b29b      	uxth	r3, r3
 1000bde:	2b00      	cmp	r3, #0
 1000be0:	d018      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000be2:	1e63      	subs	r3, r4, #1
 1000be4:	4a16      	ldr	r2, [pc, #88]	; (1000c40 <GPIO_SetBits+0xa0>)
 1000be6:	3bff      	subs	r3, #255	; 0xff
 1000be8:	4213      	tst	r3, r2
 1000bea:	d013      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000bec:	4b15      	ldr	r3, [pc, #84]	; (1000c44 <GPIO_SetBits+0xa4>)
 1000bee:	4a16      	ldr	r2, [pc, #88]	; (1000c48 <GPIO_SetBits+0xa8>)
 1000bf0:	18e3      	adds	r3, r4, r3
 1000bf2:	4213      	tst	r3, r2
 1000bf4:	d00e      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000bf6:	4b15      	ldr	r3, [pc, #84]	; (1000c4c <GPIO_SetBits+0xac>)
 1000bf8:	4a15      	ldr	r2, [pc, #84]	; (1000c50 <GPIO_SetBits+0xb0>)
 1000bfa:	18e3      	adds	r3, r4, r3
 1000bfc:	4213      	tst	r3, r2
 1000bfe:	d009      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000c00:	4b14      	ldr	r3, [pc, #80]	; (1000c54 <GPIO_SetBits+0xb4>)
 1000c02:	4a15      	ldr	r2, [pc, #84]	; (1000c58 <GPIO_SetBits+0xb8>)
 1000c04:	18e3      	adds	r3, r4, r3
 1000c06:	4213      	tst	r3, r2
 1000c08:	d004      	beq.n	1000c14 <GPIO_SetBits+0x74>
 1000c0a:	4a0b      	ldr	r2, [pc, #44]	; (1000c38 <GPIO_SetBits+0x98>)
 1000c0c:	21ab      	movs	r1, #171	; 0xab
 1000c0e:	480b      	ldr	r0, [pc, #44]	; (1000c3c <GPIO_SetBits+0x9c>)
 1000c10:	f7ff fcf6 	bl	1000600 <_assert_handler>
    int i;

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (GPIO_Pin & 1 << i)
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 0x3F; //00111111
 1000c14:	4b11      	ldr	r3, [pc, #68]	; (1000c5c <GPIO_SetBits+0xbc>)
        if (GPIO_Pin & 1 << i)
 1000c16:	2001      	movs	r0, #1
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 0x3F; //00111111
 1000c18:	18ed      	adds	r5, r5, r3
 1000c1a:	263f      	movs	r6, #63	; 0x3f
 1000c1c:	2300      	movs	r3, #0
 1000c1e:	012d      	lsls	r5, r5, #4
        if (GPIO_Pin & 1 << i)
 1000c20:	0022      	movs	r2, r4
 1000c22:	411a      	asrs	r2, r3
 1000c24:	4202      	tst	r2, r0
 1000c26:	d003      	beq.n	1000c30 <GPIO_SetBits+0x90>
 1000c28:	1959      	adds	r1, r3, r5
            GPIO_CONFIG(GPIOx * GPIO_PIN_NUM + i) |= 0x3F; //00111111
 1000c2a:	780a      	ldrb	r2, [r1, #0]
 1000c2c:	4332      	orrs	r2, r6
 1000c2e:	700a      	strb	r2, [r1, #0]
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000c30:	3301      	adds	r3, #1
 1000c32:	2b10      	cmp	r3, #16
 1000c34:	d1f4      	bne.n	1000c20 <GPIO_SetBits+0x80>
    }
}
 1000c36:	bd70      	pop	{r4, r5, r6, pc}
 1000c38:	0100247b 	.word	0x0100247b
 1000c3c:	010023cc 	.word	0x010023cc
 1000c40:	0000feff 	.word	0x0000feff
 1000c44:	fffffc00 	.word	0xfffffc00
 1000c48:	0000fbff 	.word	0x0000fbff
 1000c4c:	fffff000 	.word	0xfffff000
 1000c50:	0000efff 	.word	0x0000efff
 1000c54:	ffffc000 	.word	0xffffc000
 1000c58:	0000bfff 	.word	0x0000bfff
 1000c5c:	0000f870 	.word	0x0000f870

01000c60 <GPIO_StructInit>:

void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
{
    GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 1000c60:	2301      	movs	r3, #1
 1000c62:	425b      	negs	r3, r3
 1000c64:	8003      	strh	r3, [r0, #0]
    GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 1000c66:	3302      	adds	r3, #2
 1000c68:	7083      	strb	r3, [r0, #2]
}
 1000c6a:	4770      	bx	lr

01000c6c <GPIO_Write>:

void GPIO_Write(GPIO_TypeDef GPIOx, uint16_t value)
{
 1000c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1000c6e:	0005      	movs	r5, r0
 1000c70:	000e      	movs	r6, r1
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000c72:	2802      	cmp	r0, #2
 1000c74:	d904      	bls.n	1000c80 <GPIO_Write+0x14>
 1000c76:	4a0c      	ldr	r2, [pc, #48]	; (1000ca8 <GPIO_Write+0x3c>)
 1000c78:	21be      	movs	r1, #190	; 0xbe
 1000c7a:	480c      	ldr	r0, [pc, #48]	; (1000cac <GPIO_Write+0x40>)
 1000c7c:	f7ff fcc0 	bl	1000600 <_assert_handler>
{
 1000c80:	2400      	movs	r4, #0

    int i;

    for (i = 0; i < GPIO_PIN_NUM; i++)
    {
        if (BIT_GET(value, i))
 1000c82:	2701      	movs	r7, #1
 1000c84:	003b      	movs	r3, r7
 1000c86:	40a3      	lsls	r3, r4
 1000c88:	b299      	uxth	r1, r3
 1000c8a:	4033      	ands	r3, r6
 1000c8c:	4123      	asrs	r3, r4
            GPIO_SetBits(GPIOx, 1 << i);
 1000c8e:	0028      	movs	r0, r5
        if (BIT_GET(value, i))
 1000c90:	2b00      	cmp	r3, #0
 1000c92:	d005      	beq.n	1000ca0 <GPIO_Write+0x34>
            GPIO_SetBits(GPIOx, 1 << i);
 1000c94:	f7ff ff84 	bl	1000ba0 <GPIO_SetBits>
    for (i = 0; i < GPIO_PIN_NUM; i++)
 1000c98:	3401      	adds	r4, #1
 1000c9a:	2c10      	cmp	r4, #16
 1000c9c:	d1f2      	bne.n	1000c84 <GPIO_Write+0x18>
        else
            GPIO_ResetBits(GPIOx, 1 << i);
    }
}
 1000c9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            GPIO_ResetBits(GPIOx, 1 << i);
 1000ca0:	f7ff ff1c 	bl	1000adc <GPIO_ResetBits>
 1000ca4:	e7f8      	b.n	1000c98 <GPIO_Write+0x2c>
 1000ca6:	46c0      	nop			; (mov r8, r8)
 1000ca8:	01002488 	.word	0x01002488
 1000cac:	010023cc 	.word	0x010023cc

01000cb0 <GPIO_WriteBit>:

void GPIO_WriteBit(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 1000cb0:	b570      	push	{r4, r5, r6, lr}
 1000cb2:	0005      	movs	r5, r0
 1000cb4:	000c      	movs	r4, r1
 1000cb6:	0016      	movs	r6, r2
    _ASSERT(ISGPIOGROUP(GPIOx));
 1000cb8:	2802      	cmp	r0, #2
 1000cba:	d904      	bls.n	1000cc6 <GPIO_WriteBit+0x16>
 1000cbc:	4a21      	ldr	r2, [pc, #132]	; (1000d44 <GPIO_WriteBit+0x94>)
 1000cbe:	21cd      	movs	r1, #205	; 0xcd
 1000cc0:	4821      	ldr	r0, [pc, #132]	; (1000d48 <GPIO_WriteBit+0x98>)
 1000cc2:	f7ff fc9d 	bl	1000600 <_assert_handler>
    _ASSERT(IS_GET_GPIO_PIN(GPIO_Pin));
 1000cc6:	1e63      	subs	r3, r4, #1
 1000cc8:	2b01      	cmp	r3, #1
 1000cca:	d92c      	bls.n	1000d26 <GPIO_WriteBit+0x76>
 1000ccc:	2204      	movs	r2, #4
 1000cce:	1f23      	subs	r3, r4, #4
 1000cd0:	4393      	bics	r3, r2
 1000cd2:	b29b      	uxth	r3, r3
 1000cd4:	2b00      	cmp	r3, #0
 1000cd6:	d026      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000cd8:	0023      	movs	r3, r4
 1000cda:	320c      	adds	r2, #12
 1000cdc:	3b10      	subs	r3, #16
 1000cde:	4393      	bics	r3, r2
 1000ce0:	b29b      	uxth	r3, r3
 1000ce2:	2b00      	cmp	r3, #0
 1000ce4:	d01f      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000ce6:	0023      	movs	r3, r4
 1000ce8:	3230      	adds	r2, #48	; 0x30
 1000cea:	3b40      	subs	r3, #64	; 0x40
 1000cec:	4393      	bics	r3, r2
 1000cee:	b29b      	uxth	r3, r3
 1000cf0:	2b00      	cmp	r3, #0
 1000cf2:	d018      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000cf4:	1e63      	subs	r3, r4, #1
 1000cf6:	4a15      	ldr	r2, [pc, #84]	; (1000d4c <GPIO_WriteBit+0x9c>)
 1000cf8:	3bff      	subs	r3, #255	; 0xff
 1000cfa:	4213      	tst	r3, r2
 1000cfc:	d013      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000cfe:	4b14      	ldr	r3, [pc, #80]	; (1000d50 <GPIO_WriteBit+0xa0>)
 1000d00:	4a14      	ldr	r2, [pc, #80]	; (1000d54 <GPIO_WriteBit+0xa4>)
 1000d02:	18e3      	adds	r3, r4, r3
 1000d04:	4213      	tst	r3, r2
 1000d06:	d00e      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000d08:	4b13      	ldr	r3, [pc, #76]	; (1000d58 <GPIO_WriteBit+0xa8>)
 1000d0a:	4a14      	ldr	r2, [pc, #80]	; (1000d5c <GPIO_WriteBit+0xac>)
 1000d0c:	18e3      	adds	r3, r4, r3
 1000d0e:	4213      	tst	r3, r2
 1000d10:	d009      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000d12:	4b13      	ldr	r3, [pc, #76]	; (1000d60 <GPIO_WriteBit+0xb0>)
 1000d14:	4a13      	ldr	r2, [pc, #76]	; (1000d64 <GPIO_WriteBit+0xb4>)
 1000d16:	18e3      	adds	r3, r4, r3
 1000d18:	4213      	tst	r3, r2
 1000d1a:	d004      	beq.n	1000d26 <GPIO_WriteBit+0x76>
 1000d1c:	4a09      	ldr	r2, [pc, #36]	; (1000d44 <GPIO_WriteBit+0x94>)
 1000d1e:	21ce      	movs	r1, #206	; 0xce
 1000d20:	4809      	ldr	r0, [pc, #36]	; (1000d48 <GPIO_WriteBit+0x98>)
 1000d22:	f7ff fc6d 	bl	1000600 <_assert_handler>

    if (BitVal == Bit_SET)
 1000d26:	2e01      	cmp	r6, #1
 1000d28:	d104      	bne.n	1000d34 <GPIO_WriteBit+0x84>
        GPIO_SetBits(GPIOx, GPIO_Pin);
 1000d2a:	0021      	movs	r1, r4
 1000d2c:	0028      	movs	r0, r5
 1000d2e:	f7ff ff37 	bl	1000ba0 <GPIO_SetBits>
    else if (BitVal == Bit_RESET)
        GPIO_ResetBits(GPIOx, GPIO_Pin);
}
 1000d32:	bd70      	pop	{r4, r5, r6, pc}
    else if (BitVal == Bit_RESET)
 1000d34:	2e00      	cmp	r6, #0
 1000d36:	d1fc      	bne.n	1000d32 <GPIO_WriteBit+0x82>
        GPIO_ResetBits(GPIOx, GPIO_Pin);
 1000d38:	0021      	movs	r1, r4
 1000d3a:	0028      	movs	r0, r5
 1000d3c:	f7ff fece 	bl	1000adc <GPIO_ResetBits>
}
 1000d40:	e7f7      	b.n	1000d32 <GPIO_WriteBit+0x82>
 1000d42:	46c0      	nop			; (mov r8, r8)
 1000d44:	01002493 	.word	0x01002493
 1000d48:	010023cc 	.word	0x010023cc
 1000d4c:	0000feff 	.word	0x0000feff
 1000d50:	fffffc00 	.word	0xfffffc00
 1000d54:	0000fbff 	.word	0x0000fbff
 1000d58:	fffff000 	.word	0xfffff000
 1000d5c:	0000efff 	.word	0x0000efff
 1000d60:	ffffc000 	.word	0xffffc000
 1000d64:	0000bfff 	.word	0x0000bfff

01000d68 <UART_AutoFlowCtrlCmd>:

#define Set_RxITNum_Mask    0xff00
#define Statu_RxNum_Mask    (uint32_t)0xffff0000

void UART_AutoFlowCtrlCmd(UART_TypeDef UARTx, FunctionalState NewState)
{
 1000d68:	b570      	push	{r4, r5, r6, lr}
 1000d6a:	0004      	movs	r4, r0
 1000d6c:	000d      	movs	r5, r1
    _ASSERT(IS_UART(UARTx));
 1000d6e:	2801      	cmp	r0, #1
 1000d70:	d904      	bls.n	1000d7c <UART_AutoFlowCtrlCmd+0x14>
 1000d72:	4a0f      	ldr	r2, [pc, #60]	; (1000db0 <UART_AutoFlowCtrlCmd+0x48>)
 1000d74:	211c      	movs	r1, #28
 1000d76:	480f      	ldr	r0, [pc, #60]	; (1000db4 <UART_AutoFlowCtrlCmd+0x4c>)
 1000d78:	f7ff fc42 	bl	1000600 <_assert_handler>

    if (NewState == ENABLE)
 1000d7c:	2d01      	cmp	r5, #1
 1000d7e:	d10c      	bne.n	1000d9a <UART_AutoFlowCtrlCmd+0x32>
    {
        switch (UARTx)
 1000d80:	2c00      	cmp	r4, #0
 1000d82:	d002      	beq.n	1000d8a <UART_AutoFlowCtrlCmd+0x22>
 1000d84:	2c01      	cmp	r4, #1
 1000d86:	d006      	beq.n	1000d96 <UART_AutoFlowCtrlCmd+0x2e>
            UART1_CTRL &= (~FlowCtrl_Enable);
            break;
        }
    }
    return;
}
 1000d88:	bd70      	pop	{r4, r5, r6, pc}
            UART0_CTRL |= FlowCtrl_Enable;
 1000d8a:	4a0b      	ldr	r2, [pc, #44]	; (1000db8 <UART_AutoFlowCtrlCmd+0x50>)
            UART1_CTRL |= FlowCtrl_Enable;
 1000d8c:	2310      	movs	r3, #16
 1000d8e:	6811      	ldr	r1, [r2, #0]
 1000d90:	430b      	orrs	r3, r1
            UART1_CTRL &= (~FlowCtrl_Enable);
 1000d92:	6013      	str	r3, [r2, #0]
    return;
 1000d94:	e7f8      	b.n	1000d88 <UART_AutoFlowCtrlCmd+0x20>
            UART1_CTRL |= FlowCtrl_Enable;
 1000d96:	4a09      	ldr	r2, [pc, #36]	; (1000dbc <UART_AutoFlowCtrlCmd+0x54>)
 1000d98:	e7f8      	b.n	1000d8c <UART_AutoFlowCtrlCmd+0x24>
        switch (UARTx)
 1000d9a:	2c00      	cmp	r4, #0
 1000d9c:	d003      	beq.n	1000da6 <UART_AutoFlowCtrlCmd+0x3e>
 1000d9e:	2c01      	cmp	r4, #1
 1000da0:	d1f2      	bne.n	1000d88 <UART_AutoFlowCtrlCmd+0x20>
            UART1_CTRL &= (~FlowCtrl_Enable);
 1000da2:	4a06      	ldr	r2, [pc, #24]	; (1000dbc <UART_AutoFlowCtrlCmd+0x54>)
 1000da4:	e000      	b.n	1000da8 <UART_AutoFlowCtrlCmd+0x40>
            UART0_CTRL &= (~FlowCtrl_Enable);
 1000da6:	4a04      	ldr	r2, [pc, #16]	; (1000db8 <UART_AutoFlowCtrlCmd+0x50>)
            UART1_CTRL &= (~FlowCtrl_Enable);
 1000da8:	2110      	movs	r1, #16
 1000daa:	6813      	ldr	r3, [r2, #0]
 1000dac:	438b      	bics	r3, r1
 1000dae:	e7f0      	b.n	1000d92 <UART_AutoFlowCtrlCmd+0x2a>
 1000db0:	010024c8 	.word	0x010024c8
 1000db4:	010024a1 	.word	0x010024a1
 1000db8:	000f8b1c 	.word	0x000f8b1c
 1000dbc:	000f8c1c 	.word	0x000f8c1c

01000dc0 <UART_ClearIT>:

void UART_ClearIT(UART_TypeDef UARTx)
{
 1000dc0:	b510      	push	{r4, lr}
 1000dc2:	0004      	movs	r4, r0
    uint8_t ITType = UART_GetITIdentity(UARTx);
 1000dc4:	f000 f864 	bl	1000e90 <UART_GetITIdentity>
    UART_ITConfig(UARTx, ITType, DISABLE);
 1000dc8:	2200      	movs	r2, #0
    uint8_t ITType = UART_GetITIdentity(UARTx);
 1000dca:	0001      	movs	r1, r0
    UART_ITConfig(UARTx, ITType, DISABLE);
 1000dcc:	0020      	movs	r0, r4
 1000dce:	f000 f971 	bl	10010b4 <UART_ITConfig>
}
 1000dd2:	bd10      	pop	{r4, pc}

01000dd4 <UART_DeInit>:

void UART_DeInit(UART_TypeDef  UARTx)
{
 1000dd4:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1000dd6:	2801      	cmp	r0, #1
 1000dd8:	d905      	bls.n	1000de6 <UART_DeInit+0x12>
 1000dda:	4a07      	ldr	r2, [pc, #28]	; (1000df8 <UART_DeInit+0x24>)
 1000ddc:	2141      	movs	r1, #65	; 0x41
 1000dde:	4807      	ldr	r0, [pc, #28]	; (1000dfc <UART_DeInit+0x28>)
 1000de0:	f7ff fc0e 	bl	1000600 <_assert_handler>
        break;
    case UART1:
        UART1_CTRL = 0;
        break;
    }
}
 1000de4:	bd10      	pop	{r4, pc}
 1000de6:	2300      	movs	r3, #0
    switch (UARTx)
 1000de8:	2801      	cmp	r0, #1
 1000dea:	d002      	beq.n	1000df2 <UART_DeInit+0x1e>
        UART0_CTRL = 0;
 1000dec:	4a04      	ldr	r2, [pc, #16]	; (1000e00 <UART_DeInit+0x2c>)
        UART1_CTRL = 0;
 1000dee:	6013      	str	r3, [r2, #0]
}
 1000df0:	e7f8      	b.n	1000de4 <UART_DeInit+0x10>
        UART1_CTRL = 0;
 1000df2:	4a04      	ldr	r2, [pc, #16]	; (1000e04 <UART_DeInit+0x30>)
 1000df4:	e7fb      	b.n	1000dee <UART_DeInit+0x1a>
 1000df6:	46c0      	nop			; (mov r8, r8)
 1000df8:	010024dd 	.word	0x010024dd
 1000dfc:	010024a1 	.word	0x010024a1
 1000e00:	000f8b1c 	.word	0x000f8b1c
 1000e04:	000f8c1c 	.word	0x000f8c1c

01000e08 <UART_DMASendBuf>:

void UART_DMASendBuf(UART_TypeDef UARTx, uint8_t *buf, int len)
{
 1000e08:	b570      	push	{r4, r5, r6, lr}
 1000e0a:	0004      	movs	r4, r0
 1000e0c:	000e      	movs	r6, r1
 1000e0e:	0015      	movs	r5, r2
    _ASSERT(IS_UART(UARTx));
 1000e10:	2801      	cmp	r0, #1
 1000e12:	d904      	bls.n	1000e1e <UART_DMASendBuf+0x16>
 1000e14:	4a15      	ldr	r2, [pc, #84]	; (1000e6c <UART_DMASendBuf+0x64>)
 1000e16:	2150      	movs	r1, #80	; 0x50
 1000e18:	4815      	ldr	r0, [pc, #84]	; (1000e70 <UART_DMASendBuf+0x68>)
 1000e1a:	f7ff fbf1 	bl	1000600 <_assert_handler>
    _ASSERT(NULL != buf);
 1000e1e:	2e00      	cmp	r6, #0
 1000e20:	d104      	bne.n	1000e2c <UART_DMASendBuf+0x24>
 1000e22:	4a12      	ldr	r2, [pc, #72]	; (1000e6c <UART_DMASendBuf+0x64>)
 1000e24:	2151      	movs	r1, #81	; 0x51
 1000e26:	4812      	ldr	r0, [pc, #72]	; (1000e70 <UART_DMASendBuf+0x68>)
 1000e28:	f7ff fbea 	bl	1000600 <_assert_handler>
    _ASSERT((len < 0xffff));
 1000e2c:	4b11      	ldr	r3, [pc, #68]	; (1000e74 <UART_DMASendBuf+0x6c>)
 1000e2e:	429d      	cmp	r5, r3
 1000e30:	dd04      	ble.n	1000e3c <UART_DMASendBuf+0x34>
 1000e32:	4a0e      	ldr	r2, [pc, #56]	; (1000e6c <UART_DMASendBuf+0x64>)
 1000e34:	2152      	movs	r1, #82	; 0x52
 1000e36:	480e      	ldr	r0, [pc, #56]	; (1000e70 <UART_DMASendBuf+0x68>)
 1000e38:	f7ff fbe2 	bl	1000600 <_assert_handler>
 1000e3c:	042d      	lsls	r5, r5, #16

    if (UARTx == UART0)
 1000e3e:	2c00      	cmp	r4, #0
 1000e40:	d10a      	bne.n	1000e58 <UART_DMASendBuf+0x50>
    {
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1000e42:	4b0d      	ldr	r3, [pc, #52]	; (1000e78 <UART_DMASendBuf+0x70>)
        DMA_LEN(DMACH_UART0) = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1000e44:	490d      	ldr	r1, [pc, #52]	; (1000e7c <UART_DMASendBuf+0x74>)
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1000e46:	601e      	str	r6, [r3, #0]
        DMA_LEN(DMACH_UART0) = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1000e48:	680a      	ldr	r2, [r1, #0]
        DMA_START(DMACH_UART0) = (1 << DMA_START_BIT);
 1000e4a:	4b0d      	ldr	r3, [pc, #52]	; (1000e80 <UART_DMASendBuf+0x78>)
        DMA_LEN(DMACH_UART0) = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1000e4c:	b292      	uxth	r2, r2
 1000e4e:	432a      	orrs	r2, r5
 1000e50:	600a      	str	r2, [r1, #0]
    }
    else
    {
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
        DMA_LEN(DMACH_UART1) = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
        DMA_START(DMACH_UART1) = (1 << DMA_START_BIT);
 1000e52:	2280      	movs	r2, #128	; 0x80
 1000e54:	701a      	strb	r2, [r3, #0]
    }
}
 1000e56:	bd70      	pop	{r4, r5, r6, pc}
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1000e58:	4b0a      	ldr	r3, [pc, #40]	; (1000e84 <UART_DMASendBuf+0x7c>)
        DMA_LEN(DMACH_UART1) = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1000e5a:	490b      	ldr	r1, [pc, #44]	; (1000e88 <UART_DMASendBuf+0x80>)
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1000e5c:	601e      	str	r6, [r3, #0]
        DMA_LEN(DMACH_UART1) = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1000e5e:	680a      	ldr	r2, [r1, #0]
        DMA_START(DMACH_UART1) = (1 << DMA_START_BIT);
 1000e60:	4b0a      	ldr	r3, [pc, #40]	; (1000e8c <UART_DMASendBuf+0x84>)
        DMA_LEN(DMACH_UART1) = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1000e62:	b292      	uxth	r2, r2
 1000e64:	432a      	orrs	r2, r5
 1000e66:	600a      	str	r2, [r1, #0]
 1000e68:	e7f3      	b.n	1000e52 <UART_DMASendBuf+0x4a>
 1000e6a:	46c0      	nop			; (mov r8, r8)
 1000e6c:	010024e9 	.word	0x010024e9
 1000e70:	010024a1 	.word	0x010024a1
 1000e74:	0000fffe 	.word	0x0000fffe
 1000e78:	000f8b00 	.word	0x000f8b00
 1000e7c:	000f8b08 	.word	0x000f8b08
 1000e80:	000f8b0f 	.word	0x000f8b0f
 1000e84:	000f8c00 	.word	0x000f8c00
 1000e88:	000f8c08 	.word	0x000f8c08
 1000e8c:	000f8c0f 	.word	0x000f8c0f

01000e90 <UART_GetITIdentity>:

uint8_t UART_GetITIdentity(UART_TypeDef UARTx)
{
    uint8_t IT_Mode = 0;
    switch (UARTx)
 1000e90:	2800      	cmp	r0, #0
 1000e92:	d003      	beq.n	1000e9c <UART_GetITIdentity+0xc>
 1000e94:	2801      	cmp	r0, #1
 1000e96:	d010      	beq.n	1000eba <UART_GetITIdentity+0x2a>
    uint8_t IT_Mode = 0;
 1000e98:	2000      	movs	r0, #0
 1000e9a:	e00d      	b.n	1000eb8 <UART_GetITIdentity+0x28>
    {
    case UART0:
    {
        if (((UART0_CTRL & Set_RxITNum_Mask) > 0) && ((UART0_STATUS >> 16) > 0))
 1000e9c:	22ff      	movs	r2, #255	; 0xff
 1000e9e:	4b0b      	ldr	r3, [pc, #44]	; (1000ecc <UART_GetITIdentity+0x3c>)
 1000ea0:	0212      	lsls	r2, r2, #8
 1000ea2:	6819      	ldr	r1, [r3, #0]
 1000ea4:	4211      	tst	r1, r2
 1000ea6:	d005      	beq.n	1000eb4 <UART_GetITIdentity+0x24>
 1000ea8:	4a09      	ldr	r2, [pc, #36]	; (1000ed0 <UART_GetITIdentity+0x40>)
    }
    break;

    case UART1:
    {
        if (((UART1_CTRL & Set_RxITNum_Mask) > 0) && ((UART1_STATUS >> 16) > 0))
 1000eaa:	6812      	ldr	r2, [r2, #0]
            IT_Mode =  UART_IT_RX;
 1000eac:	2002      	movs	r0, #2
        if (((UART1_CTRL & Set_RxITNum_Mask) > 0) && ((UART1_STATUS >> 16) > 0))
 1000eae:	1412      	asrs	r2, r2, #16
 1000eb0:	2a00      	cmp	r2, #0
 1000eb2:	dc01      	bgt.n	1000eb8 <UART_GetITIdentity+0x28>
        {
            IT_Mode =  UART_IT_RX;
        }
        else
        {
            if (UART1_CTRL & TX_INTR_ENABLE)
 1000eb4:	6818      	ldr	r0, [r3, #0]
    uint8_t IT_Mode = 0;
 1000eb6:	0fc0      	lsrs	r0, r0, #31
        }
    }
    break;
    }
    return IT_Mode;
}
 1000eb8:	4770      	bx	lr
        if (((UART1_CTRL & Set_RxITNum_Mask) > 0) && ((UART1_STATUS >> 16) > 0))
 1000eba:	22ff      	movs	r2, #255	; 0xff
 1000ebc:	4b05      	ldr	r3, [pc, #20]	; (1000ed4 <UART_GetITIdentity+0x44>)
 1000ebe:	0212      	lsls	r2, r2, #8
 1000ec0:	6819      	ldr	r1, [r3, #0]
 1000ec2:	4211      	tst	r1, r2
 1000ec4:	d0f6      	beq.n	1000eb4 <UART_GetITIdentity+0x24>
 1000ec6:	4a04      	ldr	r2, [pc, #16]	; (1000ed8 <UART_GetITIdentity+0x48>)
 1000ec8:	e7ef      	b.n	1000eaa <UART_GetITIdentity+0x1a>
 1000eca:	46c0      	nop			; (mov r8, r8)
 1000ecc:	000f8b1c 	.word	0x000f8b1c
 1000ed0:	000f8b28 	.word	0x000f8b28
 1000ed4:	000f8c1c 	.word	0x000f8c1c
 1000ed8:	000f8c28 	.word	0x000f8c28

01000edc <UART_Init>:

void UART_Init(UART_TypeDef UARTx, UART_InitTypeDef *UART_InitStruct)
{
 1000edc:	b570      	push	{r4, r5, r6, lr}
 1000ede:	0005      	movs	r5, r0
 1000ee0:	000e      	movs	r6, r1
#define RESET_BAUD (1<<7)
#define AUTO_BAUD  (0<<7)
    uint32_t reg_value = 0;
    uint32_t temp_baudrate = 0;

    _ASSERT(IS_UART(UARTx));
 1000ee2:	2801      	cmp	r0, #1
 1000ee4:	d904      	bls.n	1000ef0 <UART_Init+0x14>
 1000ee6:	4a3a      	ldr	r2, [pc, #232]	; (1000fd0 <UART_Init+0xf4>)
 1000ee8:	219a      	movs	r1, #154	; 0x9a
 1000eea:	483a      	ldr	r0, [pc, #232]	; (1000fd4 <UART_Init+0xf8>)
 1000eec:	f7ff fb88 	bl	1000600 <_assert_handler>
    _ASSERT(IS_MODE(UART_InitStruct->Mode));
 1000ef0:	2240      	movs	r2, #64	; 0x40
 1000ef2:	7833      	ldrb	r3, [r6, #0]
 1000ef4:	4393      	bics	r3, r2
 1000ef6:	d004      	beq.n	1000f02 <UART_Init+0x26>
 1000ef8:	4a35      	ldr	r2, [pc, #212]	; (1000fd0 <UART_Init+0xf4>)
 1000efa:	219b      	movs	r1, #155	; 0x9b
 1000efc:	4835      	ldr	r0, [pc, #212]	; (1000fd4 <UART_Init+0xf8>)
 1000efe:	f7ff fb7f 	bl	1000600 <_assert_handler>
    _ASSERT(IS_BAUDRATE(UART_InitStruct->BaudRate));
 1000f02:	4a35      	ldr	r2, [pc, #212]	; (1000fd8 <UART_Init+0xfc>)
 1000f04:	6873      	ldr	r3, [r6, #4]
 1000f06:	189b      	adds	r3, r3, r2
 1000f08:	4a34      	ldr	r2, [pc, #208]	; (1000fdc <UART_Init+0x100>)
 1000f0a:	4293      	cmp	r3, r2
 1000f0c:	d904      	bls.n	1000f18 <UART_Init+0x3c>
 1000f0e:	4a30      	ldr	r2, [pc, #192]	; (1000fd0 <UART_Init+0xf4>)
 1000f10:	219c      	movs	r1, #156	; 0x9c
 1000f12:	4830      	ldr	r0, [pc, #192]	; (1000fd4 <UART_Init+0xf8>)
 1000f14:	f7ff fb74 	bl	1000600 <_assert_handler>
    _ASSERT(IS_PARITY(UART_InitStruct->Parity));
 1000f18:	2202      	movs	r2, #2
 1000f1a:	7ab3      	ldrb	r3, [r6, #10]
 1000f1c:	4393      	bics	r3, r2
 1000f1e:	d004      	beq.n	1000f2a <UART_Init+0x4e>
 1000f20:	4a2b      	ldr	r2, [pc, #172]	; (1000fd0 <UART_Init+0xf4>)
 1000f22:	219d      	movs	r1, #157	; 0x9d
 1000f24:	482b      	ldr	r0, [pc, #172]	; (1000fd4 <UART_Init+0xf8>)
 1000f26:	f7ff fb6b 	bl	1000600 <_assert_handler>
    _ASSERT(IS_FlowCtrl(UART_InitStruct->FlowCtrl));
 1000f2a:	2210      	movs	r2, #16
 1000f2c:	7af3      	ldrb	r3, [r6, #11]
 1000f2e:	4393      	bics	r3, r2
 1000f30:	d004      	beq.n	1000f3c <UART_Init+0x60>
 1000f32:	4a27      	ldr	r2, [pc, #156]	; (1000fd0 <UART_Init+0xf4>)
 1000f34:	219e      	movs	r1, #158	; 0x9e
 1000f36:	4827      	ldr	r0, [pc, #156]	; (1000fd4 <UART_Init+0xf8>)
 1000f38:	f7ff fb62 	bl	1000600 <_assert_handler>
    _ASSERT(IS_USART_STOPBITS(UART_InitStruct->StopBits));
 1000f3c:	2208      	movs	r2, #8
 1000f3e:	7a73      	ldrb	r3, [r6, #9]
 1000f40:	4393      	bics	r3, r2
 1000f42:	d004      	beq.n	1000f4e <UART_Init+0x72>
 1000f44:	4a22      	ldr	r2, [pc, #136]	; (1000fd0 <UART_Init+0xf4>)
 1000f46:	219f      	movs	r1, #159	; 0x9f
 1000f48:	4822      	ldr	r0, [pc, #136]	; (1000fd4 <UART_Init+0xf8>)
 1000f4a:	f7ff fb59 	bl	1000600 <_assert_handler>
    reg_value = RX_ENABLE                |
                UART_InitStruct->Parity  | \
                UART_InitStruct->DataBits | \
                UART_InitStruct->StopBits | \
                UART_InitStruct->FlowCtrl | \
                UART_InitStruct->Mode    | \
 1000f4e:	7ab0      	ldrb	r0, [r6, #10]
 1000f50:	7a34      	ldrb	r4, [r6, #8]
    temp_baudrate = ((48000000 / UART_InitStruct->BaudRate) << 16);
 1000f52:	6871      	ldr	r1, [r6, #4]
                UART_InitStruct->Mode    | \
 1000f54:	4304      	orrs	r4, r0
 1000f56:	207f      	movs	r0, #127	; 0x7f
 1000f58:	4240      	negs	r0, r0
 1000f5a:	4320      	orrs	r0, r4
 1000f5c:	7a74      	ldrb	r4, [r6, #9]
 1000f5e:	4320      	orrs	r0, r4
 1000f60:	7af4      	ldrb	r4, [r6, #11]
 1000f62:	4320      	orrs	r0, r4
 1000f64:	7834      	ldrb	r4, [r6, #0]
 1000f66:	4304      	orrs	r4, r0
    temp_baudrate = ((48000000 / UART_InitStruct->BaudRate) << 16);
 1000f68:	481d      	ldr	r0, [pc, #116]	; (1000fe0 <UART_Init+0x104>)
 1000f6a:	f001 f895 	bl	1002098 <__udivsi3>
 1000f6e:	2380      	movs	r3, #128	; 0x80
                UART_InitStruct->Mode    | \
 1000f70:	b2e4      	uxtb	r4, r4
    temp_baudrate = ((48000000 / UART_InitStruct->BaudRate) << 16);
 1000f72:	0400      	lsls	r0, r0, #16
    reg_value = RX_ENABLE                |
 1000f74:	4320      	orrs	r0, r4
 1000f76:	00db      	lsls	r3, r3, #3
                RESET_BAUD               | \
                temp_baudrate;

    if (UARTx == UART0)
 1000f78:	2d00      	cmp	r5, #0
 1000f7a:	d114      	bne.n	1000fa6 <UART_Init+0xca>
    {
        UART0_CTRL                 = 0;
 1000f7c:	4a19      	ldr	r2, [pc, #100]	; (1000fe4 <UART_Init+0x108>)
        DMA_DEST_ADDR(DMACH_UART0) = (int)uart0_DMA_buf;
 1000f7e:	4c1a      	ldr	r4, [pc, #104]	; (1000fe8 <UART_Init+0x10c>)
 1000f80:	491a      	ldr	r1, [pc, #104]	; (1000fec <UART_Init+0x110>)
        UART0_CTRL                 = 0;
 1000f82:	6015      	str	r5, [r2, #0]
        DMA_DEST_ADDR(DMACH_UART0) = (int)uart0_DMA_buf;
 1000f84:	600c      	str	r4, [r1, #0]
        DMA_LEN(DMACH_UART0)       = uart_DMA_buf_len;
 1000f86:	491a      	ldr	r1, [pc, #104]	; (1000ff0 <UART_Init+0x114>)
        DMA_CONFIG(DMACH_UART0)    = 1;
        DMA_START(DMACH_UART0)    |= (1 << (DMA_RESET_BIT));
 1000f88:	2420      	movs	r4, #32
        DMA_LEN(DMACH_UART0)       = uart_DMA_buf_len;
 1000f8a:	600b      	str	r3, [r1, #0]
        DMA_CONFIG(DMACH_UART0)    = 1;
 1000f8c:	2101      	movs	r1, #1
 1000f8e:	4b19      	ldr	r3, [pc, #100]	; (1000ff4 <UART_Init+0x118>)
 1000f90:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART0)    |= (1 << (DMA_RESET_BIT));
 1000f92:	4b19      	ldr	r3, [pc, #100]	; (1000ff8 <UART_Init+0x11c>)
 1000f94:	7819      	ldrb	r1, [r3, #0]
 1000f96:	4321      	orrs	r1, r4
 1000f98:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART0)    &= ~(1 << (DMA_RESET_BIT));
 1000f9a:	7819      	ldrb	r1, [r3, #0]
 1000f9c:	43a1      	bics	r1, r4
 1000f9e:	7019      	strb	r1, [r3, #0]
        UART0_CTRL                 = 0;
 1000fa0:	6015      	str	r5, [r2, #0]
        DMA_LEN(DMACH_UART1)       = uart_DMA_buf_len;
        DMA_CONFIG(DMACH_UART1)    = 1;
        DMA_START(DMACH_UART1)    |= (1 << (DMA_RESET_BIT));
        DMA_START(DMACH_UART1)    &= ~(1 << (DMA_RESET_BIT));
        UART1_CTRL                 = 0;
        UART1_CTRL                 = reg_value;
 1000fa2:	6010      	str	r0, [r2, #0]
    }
    return;
}
 1000fa4:	bd70      	pop	{r4, r5, r6, pc}
        UART1_CTRL                 = 0;
 1000fa6:	2400      	movs	r4, #0
 1000fa8:	4a14      	ldr	r2, [pc, #80]	; (1000ffc <UART_Init+0x120>)
        DMA_DEST_ADDR(DMACH_UART1) = (int)uart1_DMA_buf;
 1000faa:	4d15      	ldr	r5, [pc, #84]	; (1001000 <UART_Init+0x124>)
 1000fac:	4915      	ldr	r1, [pc, #84]	; (1001004 <UART_Init+0x128>)
        UART1_CTRL                 = 0;
 1000fae:	6014      	str	r4, [r2, #0]
        DMA_DEST_ADDR(DMACH_UART1) = (int)uart1_DMA_buf;
 1000fb0:	600d      	str	r5, [r1, #0]
        DMA_LEN(DMACH_UART1)       = uart_DMA_buf_len;
 1000fb2:	4915      	ldr	r1, [pc, #84]	; (1001008 <UART_Init+0x12c>)
        DMA_START(DMACH_UART1)    |= (1 << (DMA_RESET_BIT));
 1000fb4:	2520      	movs	r5, #32
        DMA_LEN(DMACH_UART1)       = uart_DMA_buf_len;
 1000fb6:	600b      	str	r3, [r1, #0]
        DMA_CONFIG(DMACH_UART1)    = 1;
 1000fb8:	2101      	movs	r1, #1
 1000fba:	4b14      	ldr	r3, [pc, #80]	; (100100c <UART_Init+0x130>)
 1000fbc:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART1)    |= (1 << (DMA_RESET_BIT));
 1000fbe:	4b14      	ldr	r3, [pc, #80]	; (1001010 <UART_Init+0x134>)
 1000fc0:	7819      	ldrb	r1, [r3, #0]
 1000fc2:	4329      	orrs	r1, r5
 1000fc4:	7019      	strb	r1, [r3, #0]
        DMA_START(DMACH_UART1)    &= ~(1 << (DMA_RESET_BIT));
 1000fc6:	7819      	ldrb	r1, [r3, #0]
 1000fc8:	43a9      	bics	r1, r5
 1000fca:	7019      	strb	r1, [r3, #0]
        UART1_CTRL                 = 0;
 1000fcc:	6014      	str	r4, [r2, #0]
 1000fce:	e7e8      	b.n	1000fa2 <UART_Init+0xc6>
 1000fd0:	010024f9 	.word	0x010024f9
 1000fd4:	010024a1 	.word	0x010024a1
 1000fd8:	fffffa47 	.word	0xfffffa47
 1000fdc:	0044a467 	.word	0x0044a467
 1000fe0:	02dc6c00 	.word	0x02dc6c00
 1000fe4:	000f8b1c 	.word	0x000f8b1c
 1000fe8:	00020100 	.word	0x00020100
 1000fec:	000f8b04 	.word	0x000f8b04
 1000ff0:	000f8b08 	.word	0x000f8b08
 1000ff4:	000f8b0c 	.word	0x000f8b0c
 1000ff8:	000f8b0f 	.word	0x000f8b0f
 1000ffc:	000f8c1c 	.word	0x000f8c1c
 1001000:	00020500 	.word	0x00020500
 1001004:	000f8c04 	.word	0x000f8c04
 1001008:	000f8c08 	.word	0x000f8c08
 100100c:	000f8c0c 	.word	0x000f8c0c
 1001010:	000f8c0f 	.word	0x000f8c0f

01001014 <UART_IsRXFIFOFull>:

Boolean UART_IsRXFIFOFull(UART_TypeDef UARTx)
{
 1001014:	b510      	push	{r4, lr}
#define BITRXFULL 1
    _ASSERT(IS_UART(UARTx));
 1001016:	2801      	cmp	r0, #1
 1001018:	d906      	bls.n	1001028 <UART_IsRXFIFOFull+0x14>
 100101a:	4a07      	ldr	r2, [pc, #28]	; (1001038 <UART_IsRXFIFOFull+0x24>)
 100101c:	21c8      	movs	r1, #200	; 0xc8
 100101e:	4807      	ldr	r0, [pc, #28]	; (100103c <UART_IsRXFIFOFull+0x28>)
 1001020:	f7ff faee 	bl	1000600 <_assert_handler>
    {
        return (Boolean)(UART0_STATUS & (1 << BITRXFULL));
    }
    else
    {
        return (Boolean)(UART1_STATUS & (1 << BITRXFULL));
 1001024:	4b06      	ldr	r3, [pc, #24]	; (1001040 <UART_IsRXFIFOFull+0x2c>)
 1001026:	e002      	b.n	100102e <UART_IsRXFIFOFull+0x1a>
    if (UART0 == UARTx)
 1001028:	2800      	cmp	r0, #0
 100102a:	d1fb      	bne.n	1001024 <UART_IsRXFIFOFull+0x10>
        return (Boolean)(UART0_STATUS & (1 << BITRXFULL));
 100102c:	4b05      	ldr	r3, [pc, #20]	; (1001044 <UART_IsRXFIFOFull+0x30>)
        return (Boolean)(UART1_STATUS & (1 << BITRXFULL));
 100102e:	6818      	ldr	r0, [r3, #0]
 1001030:	2302      	movs	r3, #2
 1001032:	4018      	ands	r0, r3
    }
}
 1001034:	bd10      	pop	{r4, pc}
 1001036:	46c0      	nop			; (mov r8, r8)
 1001038:	01002503 	.word	0x01002503
 100103c:	010024a1 	.word	0x010024a1
 1001040:	000f8c28 	.word	0x000f8c28
 1001044:	000f8b28 	.word	0x000f8b28

01001048 <UART_IsRXFIFONotEmpty>:

Boolean UART_IsRXFIFONotEmpty(UART_TypeDef  UARTx)
{
 1001048:	b510      	push	{r4, lr}
#define BITRXEMPTY 0
    _ASSERT(IS_UART(UARTx));
 100104a:	2801      	cmp	r0, #1
 100104c:	d906      	bls.n	100105c <UART_IsRXFIFONotEmpty+0x14>
 100104e:	4a08      	ldr	r2, [pc, #32]	; (1001070 <UART_IsRXFIFONotEmpty+0x28>)
 1001050:	21d7      	movs	r1, #215	; 0xd7
 1001052:	4808      	ldr	r0, [pc, #32]	; (1001074 <UART_IsRXFIFONotEmpty+0x2c>)
 1001054:	f7ff fad4 	bl	1000600 <_assert_handler>
    {
        return (Boolean)((UART0_STATUS >> 16) ? 1 : 0);
    }
    else
    {
        return (Boolean)((UART1_STATUS >> 16) ? 1 : 0);
 1001058:	4b07      	ldr	r3, [pc, #28]	; (1001078 <UART_IsRXFIFONotEmpty+0x30>)
 100105a:	e002      	b.n	1001062 <UART_IsRXFIFONotEmpty+0x1a>
    if (UART0 == UARTx)
 100105c:	2800      	cmp	r0, #0
 100105e:	d1fb      	bne.n	1001058 <UART_IsRXFIFONotEmpty+0x10>
        return (Boolean)((UART0_STATUS >> 16) ? 1 : 0);
 1001060:	4b06      	ldr	r3, [pc, #24]	; (100107c <UART_IsRXFIFONotEmpty+0x34>)
        return (Boolean)((UART1_STATUS >> 16) ? 1 : 0);
 1001062:	6818      	ldr	r0, [r3, #0]
 1001064:	1400      	asrs	r0, r0, #16
 1001066:	1e43      	subs	r3, r0, #1
 1001068:	4198      	sbcs	r0, r3
        return (Boolean)((UART0_STATUS >> 16) ? 1 : 0);
 100106a:	b2c0      	uxtb	r0, r0
    }
}
 100106c:	bd10      	pop	{r4, pc}
 100106e:	46c0      	nop			; (mov r8, r8)
 1001070:	01002515 	.word	0x01002515
 1001074:	010024a1 	.word	0x010024a1
 1001078:	000f8c28 	.word	0x000f8c28
 100107c:	000f8b28 	.word	0x000f8b28

01001080 <UART_IsUARTBusy>:

Boolean UART_IsUARTBusy(UART_TypeDef  UARTx)
{
 1001080:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1001082:	2801      	cmp	r0, #1
 1001084:	d906      	bls.n	1001094 <UART_IsUARTBusy+0x14>
 1001086:	4a07      	ldr	r2, [pc, #28]	; (10010a4 <UART_IsUARTBusy+0x24>)
 1001088:	21e5      	movs	r1, #229	; 0xe5
 100108a:	4807      	ldr	r0, [pc, #28]	; (10010a8 <UART_IsUARTBusy+0x28>)
 100108c:	f7ff fab8 	bl	1000600 <_assert_handler>
    {
        return (Boolean)(!(DMA_STATUS(DMACH_UART0) & 1));
    }
    else
    {
        return (Boolean)(!(DMA_STATUS(DMACH_UART1) & 1));
 1001090:	4b06      	ldr	r3, [pc, #24]	; (10010ac <UART_IsUARTBusy+0x2c>)
 1001092:	e002      	b.n	100109a <UART_IsUARTBusy+0x1a>
    if (UART0 == UARTx)
 1001094:	2800      	cmp	r0, #0
 1001096:	d1fb      	bne.n	1001090 <UART_IsUARTBusy+0x10>
        return (Boolean)(!(DMA_STATUS(DMACH_UART0) & 1));
 1001098:	4b05      	ldr	r3, [pc, #20]	; (10010b0 <UART_IsUARTBusy+0x30>)
        return (Boolean)(!(DMA_STATUS(DMACH_UART1) & 1));
 100109a:	2001      	movs	r0, #1
 100109c:	681b      	ldr	r3, [r3, #0]
 100109e:	4398      	bics	r0, r3
    }
}
 10010a0:	bd10      	pop	{r4, pc}
 10010a2:	46c0      	nop			; (mov r8, r8)
 10010a4:	0100252b 	.word	0x0100252b
 10010a8:	010024a1 	.word	0x010024a1
 10010ac:	000f8c10 	.word	0x000f8c10
 10010b0:	000f8b10 	.word	0x000f8b10

010010b4 <UART_ITConfig>:

void UART_ITConfig(UART_TypeDef UARTx, uint32_t UART_IT, FunctionalState NewState)
{
 10010b4:	b570      	push	{r4, r5, r6, lr}
 10010b6:	0006      	movs	r6, r0
 10010b8:	000d      	movs	r5, r1
 10010ba:	0014      	movs	r4, r2
    _ASSERT(IS_UART(UARTx));
 10010bc:	2801      	cmp	r0, #1
 10010be:	d904      	bls.n	10010ca <UART_ITConfig+0x16>
 10010c0:	4a1a      	ldr	r2, [pc, #104]	; (100112c <UART_ITConfig+0x78>)
 10010c2:	21f3      	movs	r1, #243	; 0xf3
 10010c4:	481a      	ldr	r0, [pc, #104]	; (1001130 <UART_ITConfig+0x7c>)
 10010c6:	f7ff fa9b 	bl	1000600 <_assert_handler>
    _ASSERT(IS_UART_IT(UART_IT));
 10010ca:	1e6b      	subs	r3, r5, #1
 10010cc:	2b01      	cmp	r3, #1
 10010ce:	d904      	bls.n	10010da <UART_ITConfig+0x26>
 10010d0:	4a16      	ldr	r2, [pc, #88]	; (100112c <UART_ITConfig+0x78>)
 10010d2:	21f4      	movs	r1, #244	; 0xf4
 10010d4:	4816      	ldr	r0, [pc, #88]	; (1001130 <UART_ITConfig+0x7c>)
 10010d6:	f7ff fa93 	bl	1000600 <_assert_handler>

    switch (UARTx)
 10010da:	2e00      	cmp	r6, #0
 10010dc:	d002      	beq.n	10010e4 <UART_ITConfig+0x30>
 10010de:	2e01      	cmp	r6, #1
 10010e0:	d01b      	beq.n	100111a <UART_ITConfig+0x66>
            UART1_CTRL |= (NewState << TX_INTR_ENABLE_BIT);
        }
    }
    break;
    }
}
 10010e2:	bd70      	pop	{r4, r5, r6, pc}
        if (UART_IT == UART_IT_RX)
 10010e4:	2d02      	cmp	r5, #2
 10010e6:	d10c      	bne.n	1001102 <UART_ITConfig+0x4e>
 10010e8:	4b12      	ldr	r3, [pc, #72]	; (1001134 <UART_ITConfig+0x80>)
            if (NewState)
 10010ea:	2c00      	cmp	r4, #0
 10010ec:	d004      	beq.n	10010f8 <UART_ITConfig+0x44>
                UART1_CTRL |= ((ENABLE << 8));
 10010ee:	2280      	movs	r2, #128	; 0x80
 10010f0:	6819      	ldr	r1, [r3, #0]
 10010f2:	0052      	lsls	r2, r2, #1
 10010f4:	430a      	orrs	r2, r1
 10010f6:	e002      	b.n	10010fe <UART_ITConfig+0x4a>
                UART0_CTRL &= ~Set_RxITNum_Mask;
 10010f8:	681a      	ldr	r2, [r3, #0]
 10010fa:	490f      	ldr	r1, [pc, #60]	; (1001138 <UART_ITConfig+0x84>)
 10010fc:	400a      	ands	r2, r1
 10010fe:	601a      	str	r2, [r3, #0]
 1001100:	e7ef      	b.n	10010e2 <UART_ITConfig+0x2e>
        else if (UART_IT == UART_IT_TX)
 1001102:	2d01      	cmp	r5, #1
 1001104:	d1ed      	bne.n	10010e2 <UART_ITConfig+0x2e>
            UART0_CTRL &= (~TX_INTR_ENABLE);
 1001106:	4a0b      	ldr	r2, [pc, #44]	; (1001134 <UART_ITConfig+0x80>)
            UART1_CTRL &= (uint32_t)~TX_INTR_ENABLE;
 1001108:	6813      	ldr	r3, [r2, #0]
            UART1_CTRL |= (NewState << TX_INTR_ENABLE_BIT);
 100110a:	07e4      	lsls	r4, r4, #31
            UART1_CTRL &= (uint32_t)~TX_INTR_ENABLE;
 100110c:	005b      	lsls	r3, r3, #1
 100110e:	085b      	lsrs	r3, r3, #1
 1001110:	6013      	str	r3, [r2, #0]
            UART1_CTRL |= (NewState << TX_INTR_ENABLE_BIT);
 1001112:	6813      	ldr	r3, [r2, #0]
 1001114:	431c      	orrs	r4, r3
 1001116:	6014      	str	r4, [r2, #0]
}
 1001118:	e7e3      	b.n	10010e2 <UART_ITConfig+0x2e>
        if (UART_IT == UART_IT_RX)
 100111a:	2d02      	cmp	r5, #2
 100111c:	d101      	bne.n	1001122 <UART_ITConfig+0x6e>
 100111e:	4b07      	ldr	r3, [pc, #28]	; (100113c <UART_ITConfig+0x88>)
 1001120:	e7e3      	b.n	10010ea <UART_ITConfig+0x36>
        else if (UART_IT == UART_IT_TX)
 1001122:	2d01      	cmp	r5, #1
 1001124:	d1dd      	bne.n	10010e2 <UART_ITConfig+0x2e>
            UART1_CTRL &= (uint32_t)~TX_INTR_ENABLE;
 1001126:	4a05      	ldr	r2, [pc, #20]	; (100113c <UART_ITConfig+0x88>)
 1001128:	e7ee      	b.n	1001108 <UART_ITConfig+0x54>
 100112a:	46c0      	nop			; (mov r8, r8)
 100112c:	0100253b 	.word	0x0100253b
 1001130:	010024a1 	.word	0x010024a1
 1001134:	000f8b1c 	.word	0x000f8b1c
 1001138:	ffff00ff 	.word	0xffff00ff
 100113c:	000f8c1c 	.word	0x000f8c1c

01001140 <UART_ReceiveData>:

uint8_t UART_ReceiveData(UART_TypeDef UARTx)
{
 1001140:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1001142:	2801      	cmp	r0, #1
 1001144:	d907      	bls.n	1001156 <UART_ReceiveData+0x16>
 1001146:	2128      	movs	r1, #40	; 0x28
 1001148:	4a06      	ldr	r2, [pc, #24]	; (1001164 <UART_ReceiveData+0x24>)
 100114a:	31ff      	adds	r1, #255	; 0xff
 100114c:	4806      	ldr	r0, [pc, #24]	; (1001168 <UART_ReceiveData+0x28>)
 100114e:	f7ff fa57 	bl	1000600 <_assert_handler>
    {
        return UART0_RDATA;
    }
    else
    {
        return UART1_RDATA;
 1001152:	4b06      	ldr	r3, [pc, #24]	; (100116c <UART_ReceiveData+0x2c>)
 1001154:	e002      	b.n	100115c <UART_ReceiveData+0x1c>
    if (UART0 == UARTx)
 1001156:	2800      	cmp	r0, #0
 1001158:	d1fb      	bne.n	1001152 <UART_ReceiveData+0x12>
        return UART0_RDATA;
 100115a:	4b05      	ldr	r3, [pc, #20]	; (1001170 <UART_ReceiveData+0x30>)
        return UART1_RDATA;
 100115c:	7818      	ldrb	r0, [r3, #0]
 100115e:	b2c0      	uxtb	r0, r0
    }
}
 1001160:	bd10      	pop	{r4, pc}
 1001162:	46c0      	nop			; (mov r8, r8)
 1001164:	01002549 	.word	0x01002549
 1001168:	010024a1 	.word	0x010024a1
 100116c:	000f8c24 	.word	0x000f8c24
 1001170:	000f8b24 	.word	0x000f8b24

01001174 <UART_RecvBuf>:

int UART_RecvBuf(UART_TypeDef UARTx, uint8_t *buf, int len)
{
 1001174:	b570      	push	{r4, r5, r6, lr}
 1001176:	0006      	movs	r6, r0
 1001178:	000c      	movs	r4, r1
 100117a:	0015      	movs	r5, r2
    uint32_t length = 0;
    volatile int *pstatus = NULL;
    volatile unsigned char *pdata = NULL;
    _ASSERT(IS_UART(UARTx));
 100117c:	2801      	cmp	r0, #1
 100117e:	d905      	bls.n	100118c <UART_RecvBuf+0x18>
 1001180:	219c      	movs	r1, #156	; 0x9c
 1001182:	4a10      	ldr	r2, [pc, #64]	; (10011c4 <UART_RecvBuf+0x50>)
 1001184:	0049      	lsls	r1, r1, #1
 1001186:	4810      	ldr	r0, [pc, #64]	; (10011c8 <UART_RecvBuf+0x54>)
 1001188:	f7ff fa3a 	bl	1000600 <_assert_handler>
    _ASSERT(NULL != buf);
 100118c:	2c00      	cmp	r4, #0
 100118e:	d105      	bne.n	100119c <UART_RecvBuf+0x28>
 1001190:	213a      	movs	r1, #58	; 0x3a
 1001192:	4a0c      	ldr	r2, [pc, #48]	; (10011c4 <UART_RecvBuf+0x50>)
 1001194:	31ff      	adds	r1, #255	; 0xff
 1001196:	480c      	ldr	r0, [pc, #48]	; (10011c8 <UART_RecvBuf+0x54>)
 1001198:	f7ff fa32 	bl	1000600 <_assert_handler>

    if (UART0 == UARTx)
 100119c:	2e00      	cmp	r6, #0
 100119e:	d00d      	beq.n	10011bc <UART_RecvBuf+0x48>
        pdata = &UART0_RDATA;
    }
    else
    {
        pstatus = &UART1_STATUS;
        pdata = &UART1_RDATA;
 10011a0:	490a      	ldr	r1, [pc, #40]	; (10011cc <UART_RecvBuf+0x58>)
        pstatus = &UART1_STATUS;
 10011a2:	4a0b      	ldr	r2, [pc, #44]	; (10011d0 <UART_RecvBuf+0x5c>)
        pstatus = &UART0_STATUS;
 10011a4:	2000      	movs	r0, #0
 10011a6:	e004      	b.n	10011b2 <UART_RecvBuf+0x3e>
    }

    while ((*pstatus >> 16) > 0)
    {
        if (length < len)
 10011a8:	4285      	cmp	r5, r0
 10011aa:	d006      	beq.n	10011ba <UART_RecvBuf+0x46>
        {
            buf[length++] = *pdata;
 10011ac:	780b      	ldrb	r3, [r1, #0]
 10011ae:	5423      	strb	r3, [r4, r0]
 10011b0:	3001      	adds	r0, #1
    while ((*pstatus >> 16) > 0)
 10011b2:	6813      	ldr	r3, [r2, #0]
 10011b4:	141b      	asrs	r3, r3, #16
 10011b6:	2b00      	cmp	r3, #0
 10011b8:	dcf6      	bgt.n	10011a8 <UART_RecvBuf+0x34>
            break;
        }
    }

    return length;
}
 10011ba:	bd70      	pop	{r4, r5, r6, pc}
        pdata = &UART0_RDATA;
 10011bc:	4905      	ldr	r1, [pc, #20]	; (10011d4 <UART_RecvBuf+0x60>)
        pstatus = &UART0_STATUS;
 10011be:	4a06      	ldr	r2, [pc, #24]	; (10011d8 <UART_RecvBuf+0x64>)
 10011c0:	e7f0      	b.n	10011a4 <UART_RecvBuf+0x30>
 10011c2:	46c0      	nop			; (mov r8, r8)
 10011c4:	0100255a 	.word	0x0100255a
 10011c8:	010024a1 	.word	0x010024a1
 10011cc:	000f8c24 	.word	0x000f8c24
 10011d0:	000f8c28 	.word	0x000f8c28
 10011d4:	000f8b24 	.word	0x000f8b24
 10011d8:	000f8b28 	.word	0x000f8b28

010011dc <UART_SendBuf>:


void UART_SendBuf(UART_TypeDef UARTx, uint8_t *buf, int len)
{
 10011dc:	b570      	push	{r4, r5, r6, lr}
 10011de:	0004      	movs	r4, r0
 10011e0:	000e      	movs	r6, r1
 10011e2:	0015      	movs	r5, r2
    _ASSERT(IS_UART(UARTx));
 10011e4:	2801      	cmp	r0, #1
 10011e6:	d905      	bls.n	10011f4 <UART_SendBuf+0x18>
 10011e8:	21ac      	movs	r1, #172	; 0xac
 10011ea:	4a1c      	ldr	r2, [pc, #112]	; (100125c <UART_SendBuf+0x80>)
 10011ec:	0049      	lsls	r1, r1, #1
 10011ee:	481c      	ldr	r0, [pc, #112]	; (1001260 <UART_SendBuf+0x84>)
 10011f0:	f7ff fa06 	bl	1000600 <_assert_handler>
    _ASSERT(NULL != buf);
 10011f4:	2e00      	cmp	r6, #0
 10011f6:	d105      	bne.n	1001204 <UART_SendBuf+0x28>
 10011f8:	215a      	movs	r1, #90	; 0x5a
 10011fa:	4a18      	ldr	r2, [pc, #96]	; (100125c <UART_SendBuf+0x80>)
 10011fc:	31ff      	adds	r1, #255	; 0xff
 10011fe:	4818      	ldr	r0, [pc, #96]	; (1001260 <UART_SendBuf+0x84>)
 1001200:	f7ff f9fe 	bl	1000600 <_assert_handler>
    _ASSERT((len < 0xffff));
 1001204:	4b17      	ldr	r3, [pc, #92]	; (1001264 <UART_SendBuf+0x88>)
 1001206:	429d      	cmp	r5, r3
 1001208:	dd05      	ble.n	1001216 <UART_SendBuf+0x3a>
 100120a:	21ad      	movs	r1, #173	; 0xad
 100120c:	4a13      	ldr	r2, [pc, #76]	; (100125c <UART_SendBuf+0x80>)
 100120e:	0049      	lsls	r1, r1, #1
 1001210:	4813      	ldr	r0, [pc, #76]	; (1001260 <UART_SendBuf+0x84>)
 1001212:	f7ff f9f5 	bl	1000600 <_assert_handler>
 1001216:	042d      	lsls	r5, r5, #16

    if (UARTx == UART0)
 1001218:	2c00      	cmp	r4, #0
 100121a:	d10f      	bne.n	100123c <UART_SendBuf+0x60>
    {
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 100121c:	4b12      	ldr	r3, [pc, #72]	; (1001268 <UART_SendBuf+0x8c>)
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 100121e:	4913      	ldr	r1, [pc, #76]	; (100126c <UART_SendBuf+0x90>)
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001220:	601e      	str	r6, [r3, #0]
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1001222:	680a      	ldr	r2, [r1, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 1001224:	4b12      	ldr	r3, [pc, #72]	; (1001270 <UART_SendBuf+0x94>)
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | len << 16;
 1001226:	b292      	uxth	r2, r2
 1001228:	432a      	orrs	r2, r5
 100122a:	600a      	str	r2, [r1, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 100122c:	2280      	movs	r2, #128	; 0x80
 100122e:	701a      	strb	r2, [r3, #0]
        while ((!(DMA_STATUS(DMACH_UART0) & 1)));
 1001230:	2301      	movs	r3, #1
 1001232:	4910      	ldr	r1, [pc, #64]	; (1001274 <UART_SendBuf+0x98>)
 1001234:	680a      	ldr	r2, [r1, #0]
 1001236:	421a      	tst	r2, r3
 1001238:	d0fc      	beq.n	1001234 <UART_SendBuf+0x58>
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
        while ((!(DMA_STATUS(DMACH_UART1) & 1)));
    }
}
 100123a:	bd70      	pop	{r4, r5, r6, pc}
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 100123c:	4b0e      	ldr	r3, [pc, #56]	; (1001278 <UART_SendBuf+0x9c>)
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 100123e:	490f      	ldr	r1, [pc, #60]	; (100127c <UART_SendBuf+0xa0>)
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 1001240:	601e      	str	r6, [r3, #0]
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1001242:	680a      	ldr	r2, [r1, #0]
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 1001244:	4b0e      	ldr	r3, [pc, #56]	; (1001280 <UART_SendBuf+0xa4>)
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | len << 16;
 1001246:	b292      	uxth	r2, r2
 1001248:	432a      	orrs	r2, r5
 100124a:	600a      	str	r2, [r1, #0]
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 100124c:	2280      	movs	r2, #128	; 0x80
 100124e:	701a      	strb	r2, [r3, #0]
        while ((!(DMA_STATUS(DMACH_UART1) & 1)));
 1001250:	2301      	movs	r3, #1
 1001252:	490c      	ldr	r1, [pc, #48]	; (1001284 <UART_SendBuf+0xa8>)
 1001254:	680a      	ldr	r2, [r1, #0]
 1001256:	421a      	tst	r2, r3
 1001258:	d0fc      	beq.n	1001254 <UART_SendBuf+0x78>
 100125a:	e7ee      	b.n	100123a <UART_SendBuf+0x5e>
 100125c:	01002567 	.word	0x01002567
 1001260:	010024a1 	.word	0x010024a1
 1001264:	0000fffe 	.word	0x0000fffe
 1001268:	000f8b00 	.word	0x000f8b00
 100126c:	000f8b08 	.word	0x000f8b08
 1001270:	000f8b0f 	.word	0x000f8b0f
 1001274:	000f8b10 	.word	0x000f8b10
 1001278:	000f8c00 	.word	0x000f8c00
 100127c:	000f8c08 	.word	0x000f8c08
 1001280:	000f8c0f 	.word	0x000f8c0f
 1001284:	000f8c10 	.word	0x000f8c10

01001288 <UART_SendData>:

void UART_SendData(UART_TypeDef UARTx, uint8_t Data)
{
 1001288:	b082      	sub	sp, #8
    uint8_t buf[1] = {Data};
 100128a:	ab01      	add	r3, sp, #4
 100128c:	7019      	strb	r1, [r3, #0]
 100128e:	2180      	movs	r1, #128	; 0x80
 1001290:	0249      	lsls	r1, r1, #9

    if (UARTx == UART0)
 1001292:	2800      	cmp	r0, #0
 1001294:	d110      	bne.n	10012b8 <UART_SendData+0x30>
    {
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 1001296:	4a10      	ldr	r2, [pc, #64]	; (10012d8 <UART_SendData+0x50>)
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | 1 << 16;
 1001298:	4810      	ldr	r0, [pc, #64]	; (10012dc <UART_SendData+0x54>)
        DMA_SRC_ADDR(DMACH_UART0) = (int)buf;
 100129a:	6013      	str	r3, [r2, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 100129c:	2280      	movs	r2, #128	; 0x80
        DMA_LEN(DMACH_UART0)      = (DMA_LEN(DMACH_UART0) & 0xffff) | 1 << 16;
 100129e:	6803      	ldr	r3, [r0, #0]
 10012a0:	b29b      	uxth	r3, r3
 10012a2:	430b      	orrs	r3, r1
 10012a4:	6003      	str	r3, [r0, #0]
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 10012a6:	4b0e      	ldr	r3, [pc, #56]	; (10012e0 <UART_SendData+0x58>)
        while (!(DMA_STATUS(DMACH_UART0) & 1));
 10012a8:	490e      	ldr	r1, [pc, #56]	; (10012e4 <UART_SendData+0x5c>)
        DMA_START(DMACH_UART0)    = (1 << DMA_START_BIT);
 10012aa:	701a      	strb	r2, [r3, #0]
        while (!(DMA_STATUS(DMACH_UART0) & 1));
 10012ac:	2301      	movs	r3, #1
 10012ae:	680a      	ldr	r2, [r1, #0]
 10012b0:	421a      	tst	r2, r3
 10012b2:	d0fc      	beq.n	10012ae <UART_SendData+0x26>
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | 1 << 16;
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
        while (!(DMA_STATUS(DMACH_UART1) & 1));
    }
}
 10012b4:	b002      	add	sp, #8
 10012b6:	4770      	bx	lr
        DMA_SRC_ADDR(DMACH_UART1) = (int)buf;
 10012b8:	4a0b      	ldr	r2, [pc, #44]	; (10012e8 <UART_SendData+0x60>)
 10012ba:	6013      	str	r3, [r2, #0]
        DMA_LEN(DMACH_UART1)      = (DMA_LEN(DMACH_UART1) & 0xffff) | 1 << 16;
 10012bc:	4a0b      	ldr	r2, [pc, #44]	; (10012ec <UART_SendData+0x64>)
 10012be:	6813      	ldr	r3, [r2, #0]
 10012c0:	b29b      	uxth	r3, r3
 10012c2:	430b      	orrs	r3, r1
 10012c4:	6013      	str	r3, [r2, #0]
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 10012c6:	2280      	movs	r2, #128	; 0x80
 10012c8:	4b09      	ldr	r3, [pc, #36]	; (10012f0 <UART_SendData+0x68>)
        while (!(DMA_STATUS(DMACH_UART1) & 1));
 10012ca:	490a      	ldr	r1, [pc, #40]	; (10012f4 <UART_SendData+0x6c>)
        DMA_START(DMACH_UART1)    = (1 << DMA_START_BIT);
 10012cc:	701a      	strb	r2, [r3, #0]
        while (!(DMA_STATUS(DMACH_UART1) & 1));
 10012ce:	2301      	movs	r3, #1
 10012d0:	680a      	ldr	r2, [r1, #0]
 10012d2:	421a      	tst	r2, r3
 10012d4:	d0fc      	beq.n	10012d0 <UART_SendData+0x48>
 10012d6:	e7ed      	b.n	10012b4 <UART_SendData+0x2c>
 10012d8:	000f8b00 	.word	0x000f8b00
 10012dc:	000f8b08 	.word	0x000f8b08
 10012e0:	000f8b0f 	.word	0x000f8b0f
 10012e4:	000f8b10 	.word	0x000f8b10
 10012e8:	000f8c00 	.word	0x000f8c00
 10012ec:	000f8c08 	.word	0x000f8c08
 10012f0:	000f8c0f 	.word	0x000f8c0f
 10012f4:	000f8c10 	.word	0x000f8c10

010012f8 <UART_SetITTimeout>:

void UART_SetITTimeout(UART_TypeDef UARTx, uint16_t timeout)
{
    if (UART0 == UARTx)
 10012f8:	2800      	cmp	r0, #0
 10012fa:	d102      	bne.n	1001302 <UART_SetITTimeout+0xa>
    {
        UART0_INTR = timeout;
 10012fc:	4b02      	ldr	r3, [pc, #8]	; (1001308 <UART_SetITTimeout+0x10>)
    }
    else
    {
        UART1_INTR = timeout;
 10012fe:	6019      	str	r1, [r3, #0]
    }
}
 1001300:	4770      	bx	lr
        UART1_INTR = timeout;
 1001302:	4b02      	ldr	r3, [pc, #8]	; (100130c <UART_SetITTimeout+0x14>)
 1001304:	e7fb      	b.n	10012fe <UART_SetITTimeout+0x6>
 1001306:	46c0      	nop			; (mov r8, r8)
 1001308:	000f8b20 	.word	0x000f8b20
 100130c:	000f8c20 	.word	0x000f8c20

01001310 <UART_SetRxITNum>:

void UART_SetRxITNum(UART_TypeDef UARTx, uint8_t Bcnt)
{
 1001310:	b570      	push	{r4, r5, r6, lr}
 1001312:	020c      	lsls	r4, r1, #8
 1001314:	4d09      	ldr	r5, [pc, #36]	; (100133c <UART_SetRxITNum+0x2c>)
    _ASSERT(IS_UART(UARTx));
 1001316:	2801      	cmp	r0, #1
 1001318:	d907      	bls.n	100132a <UART_SetRxITNum+0x1a>
 100131a:	21c7      	movs	r1, #199	; 0xc7
 100131c:	4a08      	ldr	r2, [pc, #32]	; (1001340 <UART_SetRxITNum+0x30>)
 100131e:	0049      	lsls	r1, r1, #1
 1001320:	4808      	ldr	r0, [pc, #32]	; (1001344 <UART_SetRxITNum+0x34>)
 1001322:	f7ff f96d 	bl	1000600 <_assert_handler>
    {
        UART0_CTRL = (UART0_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
    }
    else
    {
        UART1_CTRL = (UART1_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
 1001326:	4b08      	ldr	r3, [pc, #32]	; (1001348 <UART_SetRxITNum+0x38>)
 1001328:	e002      	b.n	1001330 <UART_SetRxITNum+0x20>
    if (UART0 == UARTx)
 100132a:	2800      	cmp	r0, #0
 100132c:	d1fb      	bne.n	1001326 <UART_SetRxITNum+0x16>
        UART0_CTRL = (UART0_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
 100132e:	4b07      	ldr	r3, [pc, #28]	; (100134c <UART_SetRxITNum+0x3c>)
        UART1_CTRL = (UART1_CTRL & 0xffff00ff) | ((Bcnt & 0xff) << 8);
 1001330:	6819      	ldr	r1, [r3, #0]
 1001332:	4029      	ands	r1, r5
 1001334:	4321      	orrs	r1, r4
 1001336:	6019      	str	r1, [r3, #0]
    }

}
 1001338:	bd70      	pop	{r4, r5, r6, pc}
 100133a:	46c0      	nop			; (mov r8, r8)
 100133c:	ffff00ff 	.word	0xffff00ff
 1001340:	01002574 	.word	0x01002574
 1001344:	010024a1 	.word	0x010024a1
 1001348:	000f8c1c 	.word	0x000f8c1c
 100134c:	000f8b1c 	.word	0x000f8b1c

01001350 <UART_StructInit>:

void UART_StructInit(UART_InitTypeDef *UART_InitStruct)
{
    UART_InitStruct->BaudRate = 9600;
 1001350:	2296      	movs	r2, #150	; 0x96
    UART_InitStruct->DataBits = Databits_8b;
    UART_InitStruct->FlowCtrl = FlowCtrl_None ;
    UART_InitStruct->Mode = Mode_duplex;
 1001352:	2300      	movs	r3, #0
    UART_InitStruct->BaudRate = 9600;
 1001354:	0192      	lsls	r2, r2, #6
    UART_InitStruct->Mode = Mode_duplex;
 1001356:	7003      	strb	r3, [r0, #0]
    UART_InitStruct->BaudRate = 9600;
 1001358:	6042      	str	r2, [r0, #4]
 100135a:	6083      	str	r3, [r0, #8]
    UART_InitStruct->StopBits = StopBits_1;
    UART_InitStruct->Parity = 0;
}
 100135c:	4770      	bx	lr

0100135e <UART_ReceiveDataLen>:

uint16_t UART_ReceiveDataLen(UART_TypeDef UARTx)
{
 100135e:	b510      	push	{r4, lr}
    _ASSERT(IS_UART(UARTx));
 1001360:	2801      	cmp	r0, #1
 1001362:	d907      	bls.n	1001374 <UART_ReceiveDataLen+0x16>
 1001364:	21a8      	movs	r1, #168	; 0xa8
 1001366:	4a06      	ldr	r2, [pc, #24]	; (1001380 <UART_ReceiveDataLen+0x22>)
 1001368:	31ff      	adds	r1, #255	; 0xff
 100136a:	4806      	ldr	r0, [pc, #24]	; (1001384 <UART_ReceiveDataLen+0x26>)
 100136c:	f7ff f948 	bl	1000600 <_assert_handler>
    {
        return (uint16_t)(UART0_STATUS >> 16);
    }
    else
    {
        return (uint16_t)(UART1_STATUS >> 16);
 1001370:	4b05      	ldr	r3, [pc, #20]	; (1001388 <UART_ReceiveDataLen+0x2a>)
 1001372:	e002      	b.n	100137a <UART_ReceiveDataLen+0x1c>
    if (UART0 == UARTx)
 1001374:	2800      	cmp	r0, #0
 1001376:	d1fb      	bne.n	1001370 <UART_ReceiveDataLen+0x12>
        return (uint16_t)(UART0_STATUS >> 16);
 1001378:	4b04      	ldr	r3, [pc, #16]	; (100138c <UART_ReceiveDataLen+0x2e>)
        return (uint16_t)(UART1_STATUS >> 16);
 100137a:	6818      	ldr	r0, [r3, #0]
 100137c:	0c00      	lsrs	r0, r0, #16
    }
}
 100137e:	bd10      	pop	{r4, pc}
 1001380:	01002584 	.word	0x01002584
 1001384:	010024a1 	.word	0x010024a1
 1001388:	000f8c28 	.word	0x000f8c28
 100138c:	000f8b28 	.word	0x000f8b28

01001390 <SYSCTRL_AHBPeriphClockCmd>:
#include "yc_sysctrl.h"

void SYSCTRL_AHBPeriphClockCmd(uint32_t SYSCTRL_AHBPeriph, FunctionalState NewState)
{
    _ASSERT(IS_SYSCTRL_AHB_PERIPH(SYSCTRL_AHBPeriph));
 1001390:	4b0a      	ldr	r3, [pc, #40]	; (10013bc <SYSCTRL_AHBPeriphClockCmd+0x2c>)
{
 1001392:	b570      	push	{r4, r5, r6, lr}
 1001394:	0004      	movs	r4, r0
 1001396:	000d      	movs	r5, r1
    _ASSERT(IS_SYSCTRL_AHB_PERIPH(SYSCTRL_AHBPeriph));
 1001398:	4218      	tst	r0, r3
 100139a:	d104      	bne.n	10013a6 <SYSCTRL_AHBPeriphClockCmd+0x16>
 100139c:	4a08      	ldr	r2, [pc, #32]	; (10013c0 <SYSCTRL_AHBPeriphClockCmd+0x30>)
 100139e:	2105      	movs	r1, #5
 10013a0:	4808      	ldr	r0, [pc, #32]	; (10013c4 <SYSCTRL_AHBPeriphClockCmd+0x34>)
 10013a2:	f7ff f92d 	bl	1000600 <_assert_handler>
 10013a6:	4b08      	ldr	r3, [pc, #32]	; (10013c8 <SYSCTRL_AHBPeriphClockCmd+0x38>)
    if (NewState == DISABLE)
    {
        SYSCTRL_CLK_CLS |= SYSCTRL_AHBPeriph;
 10013a8:	681a      	ldr	r2, [r3, #0]
    if (NewState == DISABLE)
 10013aa:	2d00      	cmp	r5, #0
 10013ac:	d102      	bne.n	10013b4 <SYSCTRL_AHBPeriphClockCmd+0x24>
        SYSCTRL_CLK_CLS |= SYSCTRL_AHBPeriph;
 10013ae:	4314      	orrs	r4, r2
 10013b0:	601c      	str	r4, [r3, #0]
    }
    else
    {
        SYSCTRL_CLK_CLS &= ~SYSCTRL_AHBPeriph;
    }
}
 10013b2:	bd70      	pop	{r4, r5, r6, pc}
        SYSCTRL_CLK_CLS &= ~SYSCTRL_AHBPeriph;
 10013b4:	43a2      	bics	r2, r4
 10013b6:	601a      	str	r2, [r3, #0]
}
 10013b8:	e7fb      	b.n	10013b2 <SYSCTRL_AHBPeriphClockCmd+0x22>
 10013ba:	46c0      	nop			; (mov r8, r8)
 10013bc:	0007fffe 	.word	0x0007fffe
 10013c0:	010025c2 	.word	0x010025c2
 10013c4:	01002598 	.word	0x01002598
 10013c8:	000f856c 	.word	0x000f856c

010013cc <SYSCTRL_EnterSleep>:

void SYSCTRL_EnterSleep(SleepMode_TypeDef SleepMode)
{
 10013cc:	b510      	push	{r4, lr}
    _ASSERT(IS_ALL_SLEEP_MODE(SleepMode));
 10013ce:	2802      	cmp	r0, #2
 10013d0:	d004      	beq.n	10013dc <SYSCTRL_EnterSleep+0x10>
 10013d2:	4a04      	ldr	r2, [pc, #16]	; (10013e4 <SYSCTRL_EnterSleep+0x18>)
 10013d4:	2112      	movs	r1, #18
 10013d6:	4804      	ldr	r0, [pc, #16]	; (10013e8 <SYSCTRL_EnterSleep+0x1c>)
 10013d8:	f7ff f912 	bl	1000600 <_assert_handler>
    *LPM_SLEEP = 0x5a;
 10013dc:	225a      	movs	r2, #90	; 0x5a
 10013de:	4b03      	ldr	r3, [pc, #12]	; (10013ec <SYSCTRL_EnterSleep+0x20>)
 10013e0:	601a      	str	r2, [r3, #0]
}
 10013e2:	bd10      	pop	{r4, pc}
 10013e4:	010025dc 	.word	0x010025dc
 10013e8:	01002598 	.word	0x01002598
 10013ec:	000f8420 	.word	0x000f8420

010013f0 <HCLKConfig_Div_None>:

void __NOINLINE HCLKConfig_Div_None(uint32_t HCLK_Div)
{
    QSPI_CTRL  |= (0x80);
 10013f0:	2380      	movs	r3, #128	; 0x80
 10013f2:	4a05      	ldr	r2, [pc, #20]	; (1001408 <HCLKConfig_Div_None+0x18>)
 10013f4:	6811      	ldr	r1, [r2, #0]
 10013f6:	430b      	orrs	r3, r1
    int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
 10013f8:	210f      	movs	r1, #15
    QSPI_CTRL  |= (0x80);
 10013fa:	6013      	str	r3, [r2, #0]
    int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
 10013fc:	4a03      	ldr	r2, [pc, #12]	; (100140c <HCLKConfig_Div_None+0x1c>)
 10013fe:	6813      	ldr	r3, [r2, #0]
 1001400:	438b      	bics	r3, r1
 1001402:	4318      	orrs	r0, r3
    SYSCTRL_HCLK_CON =  temp;
 1001404:	6010      	str	r0, [r2, #0]
}
 1001406:	4770      	bx	lr
 1001408:	000f881c 	.word	0x000f881c
 100140c:	000f8560 	.word	0x000f8560

01001410 <SYSCTRL_HCLKConfig>:

void SYSCTRL_HCLKConfig(uint32_t HCLK_Div)
{
    _ASSERT(IS_GET_SYSCTRL_HCLK_DIV(HCLK_Div));
 1001410:	2302      	movs	r3, #2
 1001412:	0002      	movs	r2, r0
{
 1001414:	b510      	push	{r4, lr}
    _ASSERT(IS_GET_SYSCTRL_HCLK_DIV(HCLK_Div));
 1001416:	439a      	bics	r2, r3
{
 1001418:	0004      	movs	r4, r0
    _ASSERT(IS_GET_SYSCTRL_HCLK_DIV(HCLK_Div));
 100141a:	2a00      	cmp	r2, #0
 100141c:	d009      	beq.n	1001432 <SYSCTRL_HCLKConfig+0x22>
 100141e:	2308      	movs	r3, #8
 1001420:	0002      	movs	r2, r0
 1001422:	439a      	bics	r2, r3
 1001424:	2a06      	cmp	r2, #6
 1001426:	d004      	beq.n	1001432 <SYSCTRL_HCLKConfig+0x22>
 1001428:	4a0c      	ldr	r2, [pc, #48]	; (100145c <SYSCTRL_HCLKConfig+0x4c>)
 100142a:	211f      	movs	r1, #31
 100142c:	480c      	ldr	r0, [pc, #48]	; (1001460 <SYSCTRL_HCLKConfig+0x50>)
 100142e:	f7ff f8e7 	bl	1000600 <_assert_handler>
    __asm("CPSID i");
 1001432:	b672      	cpsid	i
    if (HCLK_Div == SYSCTRL_HCLK_Div_None)
 1001434:	2c00      	cmp	r4, #0
 1001436:	d109      	bne.n	100144c <SYSCTRL_HCLKConfig+0x3c>
    {
        uint32_t HCLKConfig_Div_None_addr = (uint32_t)HCLKConfig_Div_None;
        ((void(*)(void *, void *))FUNC_PREFETCH)(((uint32_t *)HCLKConfig_Div_None_addr), ((uint32_t *)(HCLKConfig_Div_None_addr + 64)));
 1001438:	480a      	ldr	r0, [pc, #40]	; (1001464 <SYSCTRL_HCLKConfig+0x54>)
 100143a:	4b0b      	ldr	r3, [pc, #44]	; (1001468 <SYSCTRL_HCLKConfig+0x58>)
 100143c:	0001      	movs	r1, r0
 100143e:	3140      	adds	r1, #64	; 0x40
 1001440:	4798      	blx	r3
        HCLKConfig_Div_None(HCLK_Div);
 1001442:	0020      	movs	r0, r4
 1001444:	f7ff ffd4 	bl	10013f0 <HCLKConfig_Div_None>
    else
    {
        int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
        SYSCTRL_HCLK_CON =  temp;
    }
    __asm("CPSIE i");
 1001448:	b662      	cpsie	i
}
 100144a:	bd10      	pop	{r4, pc}
        int temp = (SYSCTRL_HCLK_CON & (~SYSCTRL_HCLK_COFG_REGBIT)) | HCLK_Div;
 100144c:	220f      	movs	r2, #15
 100144e:	4b07      	ldr	r3, [pc, #28]	; (100146c <SYSCTRL_HCLKConfig+0x5c>)
 1001450:	6818      	ldr	r0, [r3, #0]
 1001452:	4390      	bics	r0, r2
 1001454:	4320      	orrs	r0, r4
        SYSCTRL_HCLK_CON =  temp;
 1001456:	6018      	str	r0, [r3, #0]
 1001458:	e7f6      	b.n	1001448 <SYSCTRL_HCLKConfig+0x38>
 100145a:	46c0      	nop			; (mov r8, r8)
 100145c:	010025ef 	.word	0x010025ef
 1001460:	01002598 	.word	0x01002598
 1001464:	010013f1 	.word	0x010013f1
 1001468:	00004405 	.word	0x00004405
 100146c:	000f8560 	.word	0x000f8560

01001470 <SYSCTRL_GetClocksFreq>:

void SYSCTRL_GetClocksFreq(SYSCTRL_ClocksTypeDef *SYSCTRL_Clocks)
{
    SYSCTRL_Clocks->HCLK_Frequency = CPU_MHZ;
 1001470:	4b05      	ldr	r3, [pc, #20]	; (1001488 <SYSCTRL_GetClocksFreq+0x18>)
{
 1001472:	b510      	push	{r4, lr}
    SYSCTRL_Clocks->HCLK_Frequency = CPU_MHZ;
 1001474:	6819      	ldr	r1, [r3, #0]
 1001476:	230f      	movs	r3, #15
 1001478:	4019      	ands	r1, r3
{
 100147a:	0004      	movs	r4, r0
    SYSCTRL_Clocks->HCLK_Frequency = CPU_MHZ;
 100147c:	3102      	adds	r1, #2
 100147e:	4803      	ldr	r0, [pc, #12]	; (100148c <SYSCTRL_GetClocksFreq+0x1c>)
 1001480:	f000 fe94 	bl	10021ac <__divsi3>
 1001484:	6020      	str	r0, [r4, #0]
}
 1001486:	bd10      	pop	{r4, pc}
 1001488:	000f8560 	.word	0x000f8560
 100148c:	0b71b000 	.word	0x0b71b000

01001490 <SYSCTRL_EnableDpllClk>:
    SYSCTRL_CLK_CLS &= ~(1 << id);
 1001490:	4a0e      	ldr	r2, [pc, #56]	; (10014cc <SYSCTRL_EnableDpllClk+0x3c>)
 1001492:	490f      	ldr	r1, [pc, #60]	; (10014d0 <SYSCTRL_EnableDpllClk+0x40>)
 1001494:	6813      	ldr	r3, [r2, #0]

void SYSCTRL_EnableDpllClk(void)
{
 1001496:	b510      	push	{r4, lr}
 1001498:	400b      	ands	r3, r1
 100149a:	6013      	str	r3, [r2, #0]
    enable_clock(CLKCLS_BT);
    SYSCTRL_ROM_SWITCH = 0x94;
    delay(500);
 100149c:	20fa      	movs	r0, #250	; 0xfa
    SYSCTRL_ROM_SWITCH = 0x94;
 100149e:	2294      	movs	r2, #148	; 0x94
 10014a0:	4b0c      	ldr	r3, [pc, #48]	; (10014d4 <SYSCTRL_EnableDpllClk+0x44>)
    delay(500);
 10014a2:	0040      	lsls	r0, r0, #1
    SYSCTRL_ROM_SWITCH = 0x94;
 10014a4:	701a      	strb	r2, [r3, #0]
    delay(500);
 10014a6:	f7fe ff4e 	bl	1000346 <delay>

    *(volatile byte *)0xc4ab1 = 0x7f;
 10014aa:	227f      	movs	r2, #127	; 0x7f
 10014ac:	4b0a      	ldr	r3, [pc, #40]	; (10014d8 <SYSCTRL_EnableDpllClk+0x48>)
    *(volatile byte *)0xc4ab2 = 0xff;
    *(volatile byte *)0xc4ab3 = 0xff;

    *(volatile byte *)0xc40c3 = 0xb1;
 10014ae:	21b1      	movs	r1, #177	; 0xb1
    *(volatile byte *)0xc4ab1 = 0x7f;
 10014b0:	701a      	strb	r2, [r3, #0]
    *(volatile byte *)0xc4ab2 = 0xff;
 10014b2:	23ff      	movs	r3, #255	; 0xff
 10014b4:	4a09      	ldr	r2, [pc, #36]	; (10014dc <SYSCTRL_EnableDpllClk+0x4c>)
 10014b6:	7013      	strb	r3, [r2, #0]
    *(volatile byte *)0xc4ab3 = 0xff;
 10014b8:	4a09      	ldr	r2, [pc, #36]	; (10014e0 <SYSCTRL_EnableDpllClk+0x50>)
 10014ba:	7013      	strb	r3, [r2, #0]
    *(volatile byte *)0xc40c3 = 0xb1;
 10014bc:	4a09      	ldr	r2, [pc, #36]	; (10014e4 <SYSCTRL_EnableDpllClk+0x54>)
 10014be:	7011      	strb	r1, [r2, #0]
    *(volatile byte *)0xc40c4 = 0x4a;
 10014c0:	4a09      	ldr	r2, [pc, #36]	; (10014e8 <SYSCTRL_EnableDpllClk+0x58>)
 10014c2:	3967      	subs	r1, #103	; 0x67
 10014c4:	7011      	strb	r1, [r2, #0]

    BT_CLKPLL_EN = 0xff;
 10014c6:	4a09      	ldr	r2, [pc, #36]	; (10014ec <SYSCTRL_EnableDpllClk+0x5c>)
 10014c8:	7013      	strb	r3, [r2, #0]
}
 10014ca:	bd10      	pop	{r4, pc}
 10014cc:	000f856c 	.word	0x000f856c
 10014d0:	ffffdfff 	.word	0xffffdfff
 10014d4:	000f853c 	.word	0x000f853c
 10014d8:	000c4ab1 	.word	0x000c4ab1
 10014dc:	000c4ab2 	.word	0x000c4ab2
 10014e0:	000c4ab3 	.word	0x000c4ab3
 10014e4:	000c40c3 	.word	0x000c40c3
 10014e8:	000c40c4 	.word	0x000c40c4
 10014ec:	000c8905 	.word	0x000c8905

010014f0 <delay_us>:
#include "yc_timer.h"
#include "rom_api.h"

void delay_us(int us)
{
 10014f0:	b510      	push	{r4, lr}
    ((void(*)(int))(FUNC_DELAY_US_ADDR))(us);
 10014f2:	4b01      	ldr	r3, [pc, #4]	; (10014f8 <delay_us+0x8>)
 10014f4:	4798      	blx	r3
}
 10014f6:	bd10      	pop	{r4, pc}
 10014f8:	00004239 	.word	0x00004239

010014fc <delay_ms>:

void delay_ms(int ms)
{
 10014fc:	b510      	push	{r4, lr}
    ((void(*)(int))(FUNC_DELAY_MS_ADDR))(ms);
 10014fe:	4b01      	ldr	r3, [pc, #4]	; (1001504 <delay_ms+0x8>)
 1001500:	4798      	blx	r3
}
 1001502:	bd10      	pop	{r4, pc}
 1001504:	0000425d 	.word	0x0000425d

01001508 <TIM_Init>:

void TIM_Init(TIM_InitTypeDef *TIM_init_struct)
{
    _ASSERT(ISTIMERNUM(TIM_init_struct->TIMx));
 1001508:	7803      	ldrb	r3, [r0, #0]
{
 100150a:	b510      	push	{r4, lr}
 100150c:	0004      	movs	r4, r0
    _ASSERT(ISTIMERNUM(TIM_init_struct->TIMx));
 100150e:	2b08      	cmp	r3, #8
 1001510:	d904      	bls.n	100151c <TIM_Init+0x14>
 1001512:	4a0f      	ldr	r2, [pc, #60]	; (1001550 <TIM_Init+0x48>)
 1001514:	2110      	movs	r1, #16
 1001516:	480f      	ldr	r0, [pc, #60]	; (1001554 <TIM_Init+0x4c>)
 1001518:	f7ff f872 	bl	1000600 <_assert_handler>

    TIM_Cmd(TIM_init_struct->TIMx, DISABLE);
 100151c:	2100      	movs	r1, #0
 100151e:	7820      	ldrb	r0, [r4, #0]
 1001520:	f000 f828 	bl	1001574 <TIM_Cmd>
    TIM_PCNT(TIM_init_struct->TIMx) = TIM_init_struct->period;
 1001524:	7822      	ldrb	r2, [r4, #0]
 1001526:	4b0c      	ldr	r3, [pc, #48]	; (1001558 <TIM_Init+0x50>)
 1001528:	6861      	ldr	r1, [r4, #4]
 100152a:	18d3      	adds	r3, r2, r3
 100152c:	00db      	lsls	r3, r3, #3
 100152e:	6019      	str	r1, [r3, #0]
 1001530:	230c      	movs	r3, #12
    if (TIM_init_struct->TIMx < TIM8)
 1001532:	2a07      	cmp	r2, #7
 1001534:	d806      	bhi.n	1001544 <TIM_Init+0x3c>
        TIM_CTRL |= (((((uint32_t)1) << TIM_CTRL_MODE) | (((uint32_t)1) << TIM_CTRL_AUTO_RELOAD)) << TIM_init_struct->TIMx * 4);
 1001536:	0092      	lsls	r2, r2, #2
 1001538:	4093      	lsls	r3, r2
 100153a:	4908      	ldr	r1, [pc, #32]	; (100155c <TIM_Init+0x54>)
 100153c:	6808      	ldr	r0, [r1, #0]
 100153e:	4303      	orrs	r3, r0
 1001540:	600b      	str	r3, [r1, #0]
    else
        TIM_CTRL1 |= (((((uint32_t)1) << TIM_CTRL_MODE) | (((uint32_t)1) << TIM_CTRL_AUTO_RELOAD)) << 0);
}
 1001542:	bd10      	pop	{r4, pc}
        TIM_CTRL1 |= (((((uint32_t)1) << TIM_CTRL_MODE) | (((uint32_t)1) << TIM_CTRL_AUTO_RELOAD)) << 0);
 1001544:	4a06      	ldr	r2, [pc, #24]	; (1001560 <TIM_Init+0x58>)
 1001546:	6811      	ldr	r1, [r2, #0]
 1001548:	430b      	orrs	r3, r1
 100154a:	6013      	str	r3, [r2, #0]
}
 100154c:	e7f9      	b.n	1001542 <TIM_Init+0x3a>
 100154e:	46c0      	nop			; (mov r8, r8)
 1001550:	0100262a 	.word	0x0100262a
 1001554:	01002602 	.word	0x01002602
 1001558:	0001e180 	.word	0x0001e180
 100155c:	000f0c48 	.word	0x000f0c48
 1001560:	000f0c4c 	.word	0x000f0c4c

01001564 <TIM_DeInit>:
    SYSCTRL_CLK_CLS |= 1 << id;
 1001564:	2310      	movs	r3, #16
 1001566:	4a02      	ldr	r2, [pc, #8]	; (1001570 <TIM_DeInit+0xc>)
 1001568:	6811      	ldr	r1, [r2, #0]
 100156a:	430b      	orrs	r3, r1
 100156c:	6013      	str	r3, [r2, #0]

void TIM_DeInit()
{
    disable_clock(CLKCLS_TIM);
}
 100156e:	4770      	bx	lr
 1001570:	000f856c 	.word	0x000f856c

01001574 <TIM_Cmd>:

void TIM_Cmd(TIM_NumTypeDef TIMx, FunctionalState NewState)
{
 1001574:	b570      	push	{r4, r5, r6, lr}
 1001576:	0004      	movs	r4, r0
 1001578:	000d      	movs	r5, r1
    _ASSERT(ISTIMERNUM(TIMx));
 100157a:	2808      	cmp	r0, #8
 100157c:	d904      	bls.n	1001588 <TIM_Cmd+0x14>
 100157e:	4a10      	ldr	r2, [pc, #64]	; (10015c0 <TIM_Cmd+0x4c>)
 1001580:	2121      	movs	r1, #33	; 0x21
 1001582:	4810      	ldr	r0, [pc, #64]	; (10015c4 <TIM_Cmd+0x50>)
 1001584:	f7ff f83c 	bl	1000600 <_assert_handler>

    if (NewState == ENABLE)
 1001588:	2d01      	cmp	r5, #1
 100158a:	d10b      	bne.n	10015a4 <TIM_Cmd+0x30>
    {
        if (TIMx < TIM8)
 100158c:	2c07      	cmp	r4, #7
 100158e:	d806      	bhi.n	100159e <TIM_Cmd+0x2a>
            TIM_CTRL |= ((((uint32_t)1) << TIM_CTRL_ENABLE) << TIMx * 4);
 1001590:	00a4      	lsls	r4, r4, #2
 1001592:	40a5      	lsls	r5, r4
 1001594:	4b0c      	ldr	r3, [pc, #48]	; (10015c8 <TIM_Cmd+0x54>)
 1001596:	681a      	ldr	r2, [r3, #0]
        else
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 1001598:	4315      	orrs	r5, r2
 100159a:	601d      	str	r5, [r3, #0]
        if (TIMx < TIM8)
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << TIMx * 4);
        else
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
    }
}
 100159c:	bd70      	pop	{r4, r5, r6, pc}
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 100159e:	4b0b      	ldr	r3, [pc, #44]	; (10015cc <TIM_Cmd+0x58>)
 10015a0:	681a      	ldr	r2, [r3, #0]
 10015a2:	e7f9      	b.n	1001598 <TIM_Cmd+0x24>
 10015a4:	2301      	movs	r3, #1
        if (TIMx < TIM8)
 10015a6:	2c07      	cmp	r4, #7
 10015a8:	d806      	bhi.n	10015b8 <TIM_Cmd+0x44>
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << TIMx * 4);
 10015aa:	00a4      	lsls	r4, r4, #2
 10015ac:	40a3      	lsls	r3, r4
 10015ae:	4906      	ldr	r1, [pc, #24]	; (10015c8 <TIM_Cmd+0x54>)
 10015b0:	680a      	ldr	r2, [r1, #0]
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 10015b2:	439a      	bics	r2, r3
 10015b4:	600a      	str	r2, [r1, #0]
}
 10015b6:	e7f1      	b.n	100159c <TIM_Cmd+0x28>
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_ENABLE) << 0);
 10015b8:	4904      	ldr	r1, [pc, #16]	; (10015cc <TIM_Cmd+0x58>)
 10015ba:	680a      	ldr	r2, [r1, #0]
 10015bc:	e7f9      	b.n	10015b2 <TIM_Cmd+0x3e>
 10015be:	46c0      	nop			; (mov r8, r8)
 10015c0:	01002633 	.word	0x01002633
 10015c4:	01002602 	.word	0x01002602
 10015c8:	000f0c48 	.word	0x000f0c48
 10015cc:	000f0c4c 	.word	0x000f0c4c

010015d0 <TIM_ModeConfig>:

void TIM_ModeConfig(TIM_NumTypeDef TIMx, TIM_ModeTypeDef TIM_Mode)
{
 10015d0:	b570      	push	{r4, r5, r6, lr}
 10015d2:	0004      	movs	r4, r0
 10015d4:	000d      	movs	r5, r1
    _ASSERT(ISTIMERNUM(TIMx));
 10015d6:	2808      	cmp	r0, #8
 10015d8:	d904      	bls.n	10015e4 <TIM_ModeConfig+0x14>
 10015da:	4a14      	ldr	r2, [pc, #80]	; (100162c <TIM_ModeConfig+0x5c>)
 10015dc:	2135      	movs	r1, #53	; 0x35
 10015de:	4814      	ldr	r0, [pc, #80]	; (1001630 <TIM_ModeConfig+0x60>)
 10015e0:	f7ff f80e 	bl	1000600 <_assert_handler>
    _ASSERT(IS_TIM_MODE(TIM_Mode));
 10015e4:	2d01      	cmp	r5, #1
 10015e6:	d90e      	bls.n	1001606 <TIM_ModeConfig+0x36>
 10015e8:	4a10      	ldr	r2, [pc, #64]	; (100162c <TIM_ModeConfig+0x5c>)
 10015ea:	2136      	movs	r1, #54	; 0x36
 10015ec:	4810      	ldr	r0, [pc, #64]	; (1001630 <TIM_ModeConfig+0x60>)
 10015ee:	f7ff f807 	bl	1000600 <_assert_handler>
 10015f2:	2304      	movs	r3, #4
        else
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_MODE) << 0);
    }
    else
    {
        if (TIMx < TIM8)
 10015f4:	2c07      	cmp	r4, #7
 10015f6:	d815      	bhi.n	1001624 <TIM_ModeConfig+0x54>
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_MODE) << TIMx * 4);
 10015f8:	00a4      	lsls	r4, r4, #2
 10015fa:	40a3      	lsls	r3, r4
 10015fc:	490d      	ldr	r1, [pc, #52]	; (1001634 <TIM_ModeConfig+0x64>)
 10015fe:	680a      	ldr	r2, [r1, #0]
        else
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1001600:	439a      	bics	r2, r3
 1001602:	600a      	str	r2, [r1, #0]
    }
}
 1001604:	e00a      	b.n	100161c <TIM_ModeConfig+0x4c>
    if (TIM_Mode == TIM_Mode_TIMER)
 1001606:	2d01      	cmp	r5, #1
 1001608:	d1f3      	bne.n	10015f2 <TIM_ModeConfig+0x22>
 100160a:	2304      	movs	r3, #4
        if (TIMx < TIM8)
 100160c:	2c07      	cmp	r4, #7
 100160e:	d806      	bhi.n	100161e <TIM_ModeConfig+0x4e>
            TIM_CTRL |= ((((uint32_t)1) << TIM_CTRL_MODE) << TIMx * 4);
 1001610:	00a4      	lsls	r4, r4, #2
 1001612:	40a3      	lsls	r3, r4
 1001614:	4a07      	ldr	r2, [pc, #28]	; (1001634 <TIM_ModeConfig+0x64>)
 1001616:	6811      	ldr	r1, [r2, #0]
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1001618:	430b      	orrs	r3, r1
 100161a:	6013      	str	r3, [r2, #0]
}
 100161c:	bd70      	pop	{r4, r5, r6, pc}
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 100161e:	4a06      	ldr	r2, [pc, #24]	; (1001638 <TIM_ModeConfig+0x68>)
 1001620:	6811      	ldr	r1, [r2, #0]
 1001622:	e7f9      	b.n	1001618 <TIM_ModeConfig+0x48>
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 1001624:	4904      	ldr	r1, [pc, #16]	; (1001638 <TIM_ModeConfig+0x68>)
 1001626:	680a      	ldr	r2, [r1, #0]
 1001628:	e7ea      	b.n	1001600 <TIM_ModeConfig+0x30>
 100162a:	46c0      	nop			; (mov r8, r8)
 100162c:	0100263b 	.word	0x0100263b
 1001630:	01002602 	.word	0x01002602
 1001634:	000f0c48 	.word	0x000f0c48
 1001638:	000f0c4c 	.word	0x000f0c4c

0100163c <TIM_SetPeriod>:

void TIM_SetPeriod(TIM_NumTypeDef TIMx, uint32_t Period)
{
 100163c:	b570      	push	{r4, r5, r6, lr}
 100163e:	0004      	movs	r4, r0
 1001640:	000d      	movs	r5, r1
    _ASSERT(ISTIMERNUM(TIMx));
 1001642:	2808      	cmp	r0, #8
 1001644:	d904      	bls.n	1001650 <TIM_SetPeriod+0x14>
 1001646:	4a05      	ldr	r2, [pc, #20]	; (100165c <TIM_SetPeriod+0x20>)
 1001648:	214a      	movs	r1, #74	; 0x4a
 100164a:	4805      	ldr	r0, [pc, #20]	; (1001660 <TIM_SetPeriod+0x24>)
 100164c:	f7fe ffd8 	bl	1000600 <_assert_handler>

    TIM_PCNT(TIMx) = Period;
 1001650:	4b04      	ldr	r3, [pc, #16]	; (1001664 <TIM_SetPeriod+0x28>)
 1001652:	18e4      	adds	r4, r4, r3
 1001654:	00e4      	lsls	r4, r4, #3
 1001656:	6025      	str	r5, [r4, #0]
}
 1001658:	bd70      	pop	{r4, r5, r6, pc}
 100165a:	46c0      	nop			; (mov r8, r8)
 100165c:	0100264a 	.word	0x0100264a
 1001660:	01002602 	.word	0x01002602
 1001664:	0001e180 	.word	0x0001e180

01001668 <TIM_PWMInit>:

void TIM_PWMInit(PWM_InitTypeDef *PWM_init_struct)
{
    _ASSERT(ISTIMERNUM(PWM_init_struct->TIMx));
 1001668:	7803      	ldrb	r3, [r0, #0]
{
 100166a:	b510      	push	{r4, lr}
 100166c:	0004      	movs	r4, r0
    _ASSERT(ISTIMERNUM(PWM_init_struct->TIMx));
 100166e:	2b08      	cmp	r3, #8
 1001670:	d904      	bls.n	100167c <TIM_PWMInit+0x14>
 1001672:	4a1e      	ldr	r2, [pc, #120]	; (10016ec <TIM_PWMInit+0x84>)
 1001674:	2151      	movs	r1, #81	; 0x51
 1001676:	481e      	ldr	r0, [pc, #120]	; (10016f0 <TIM_PWMInit+0x88>)
 1001678:	f7fe ffc2 	bl	1000600 <_assert_handler>

    TIM_Cmd(PWM_init_struct->TIMx, DISABLE);
 100167c:	2100      	movs	r1, #0
 100167e:	7820      	ldrb	r0, [r4, #0]
 1001680:	f7ff ff78 	bl	1001574 <TIM_Cmd>
    TIM_PCNT(PWM_init_struct->TIMx) = PWM_init_struct->HighLevelPeriod;
 1001684:	7821      	ldrb	r1, [r4, #0]
 1001686:	4b1b      	ldr	r3, [pc, #108]	; (10016f4 <TIM_PWMInit+0x8c>)
 1001688:	18ca      	adds	r2, r1, r3
 100168a:	68a3      	ldr	r3, [r4, #8]
 100168c:	00d2      	lsls	r2, r2, #3
 100168e:	6013      	str	r3, [r2, #0]
    TIM_NCNT(PWM_init_struct->TIMx) = PWM_init_struct->LowLevelPeriod;
 1001690:	6863      	ldr	r3, [r4, #4]
 1001692:	6053      	str	r3, [r2, #4]
    if (PWM_init_struct->SatrtLevel == OutputHigh)
 1001694:	7b22      	ldrb	r2, [r4, #12]
 1001696:	2302      	movs	r3, #2
 1001698:	2a01      	cmp	r2, #1
 100169a:	d119      	bne.n	10016d0 <TIM_PWMInit+0x68>
    {
        if (PWM_init_struct->TIMx < TIM8)
 100169c:	2907      	cmp	r1, #7
 100169e:	d80d      	bhi.n	10016bc <TIM_PWMInit+0x54>
            TIM_CTRL |= ((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
 10016a0:	008c      	lsls	r4, r1, #2
 10016a2:	40a3      	lsls	r3, r4
 10016a4:	4814      	ldr	r0, [pc, #80]	; (10016f8 <TIM_PWMInit+0x90>)
 10016a6:	6802      	ldr	r2, [r0, #0]
 10016a8:	431a      	orrs	r2, r3
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
        else
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << 0);
    }
    if (PWM_init_struct->TIMx < TIM8)
        TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_MODE) << PWM_init_struct->TIMx * 4);
 10016aa:	008b      	lsls	r3, r1, #2
 10016ac:	2104      	movs	r1, #4
 10016ae:	4099      	lsls	r1, r3
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
 10016b0:	6002      	str	r2, [r0, #0]
        TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_MODE) << PWM_init_struct->TIMx * 4);
 10016b2:	4811      	ldr	r0, [pc, #68]	; (10016f8 <TIM_PWMInit+0x90>)
 10016b4:	6802      	ldr	r2, [r0, #0]
 10016b6:	438a      	bics	r2, r1
 10016b8:	6002      	str	r2, [r0, #0]
    else
        TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
}
 10016ba:	bd10      	pop	{r4, pc}
            TIM_CTRL1 |= ((((uint32_t)1) << TIM_CTRL_START_LEVEL) << 0);
 10016bc:	490f      	ldr	r1, [pc, #60]	; (10016fc <TIM_PWMInit+0x94>)
 10016be:	680a      	ldr	r2, [r1, #0]
 10016c0:	4313      	orrs	r3, r2
 10016c2:	600b      	str	r3, [r1, #0]
        TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_MODE) << 0);
 10016c4:	2104      	movs	r1, #4
 10016c6:	4a0d      	ldr	r2, [pc, #52]	; (10016fc <TIM_PWMInit+0x94>)
 10016c8:	6813      	ldr	r3, [r2, #0]
 10016ca:	438b      	bics	r3, r1
 10016cc:	6013      	str	r3, [r2, #0]
 10016ce:	e7f4      	b.n	10016ba <TIM_PWMInit+0x52>
        if (PWM_init_struct->TIMx < TIM8)
 10016d0:	2907      	cmp	r1, #7
 10016d2:	d805      	bhi.n	10016e0 <TIM_PWMInit+0x78>
            TIM_CTRL &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << PWM_init_struct->TIMx * 4);
 10016d4:	008c      	lsls	r4, r1, #2
 10016d6:	40a3      	lsls	r3, r4
 10016d8:	4807      	ldr	r0, [pc, #28]	; (10016f8 <TIM_PWMInit+0x90>)
 10016da:	6802      	ldr	r2, [r0, #0]
 10016dc:	439a      	bics	r2, r3
 10016de:	e7e4      	b.n	10016aa <TIM_PWMInit+0x42>
            TIM_CTRL1 &= ~((((uint32_t)1) << TIM_CTRL_START_LEVEL) << 0);
 10016e0:	4906      	ldr	r1, [pc, #24]	; (10016fc <TIM_PWMInit+0x94>)
 10016e2:	680a      	ldr	r2, [r1, #0]
 10016e4:	439a      	bics	r2, r3
 10016e6:	600a      	str	r2, [r1, #0]
 10016e8:	e7ec      	b.n	10016c4 <TIM_PWMInit+0x5c>
 10016ea:	46c0      	nop			; (mov r8, r8)
 10016ec:	01002658 	.word	0x01002658
 10016f0:	01002602 	.word	0x01002602
 10016f4:	0001e180 	.word	0x0001e180
 10016f8:	000f0c48 	.word	0x000f0c48
 10016fc:	000f0c4c 	.word	0x000f0c4c

01001700 <TIM_SetPWMPeriod>:

void TIM_SetPWMPeriod(TIM_NumTypeDef TIMx, uint32_t LowLevelPeriod, uint32_t HighLevelPeriod)
{
 1001700:	b570      	push	{r4, r5, r6, lr}
 1001702:	0004      	movs	r4, r0
 1001704:	000d      	movs	r5, r1
 1001706:	0016      	movs	r6, r2
    _ASSERT(ISTIMERNUM(TIMx));
 1001708:	2808      	cmp	r0, #8
 100170a:	d904      	bls.n	1001716 <TIM_SetPWMPeriod+0x16>
 100170c:	4a05      	ldr	r2, [pc, #20]	; (1001724 <TIM_SetPWMPeriod+0x24>)
 100170e:	216c      	movs	r1, #108	; 0x6c
 1001710:	4805      	ldr	r0, [pc, #20]	; (1001728 <TIM_SetPWMPeriod+0x28>)
 1001712:	f7fe ff75 	bl	1000600 <_assert_handler>

    TIM_PCNT(TIMx) = HighLevelPeriod;
 1001716:	4b05      	ldr	r3, [pc, #20]	; (100172c <TIM_SetPWMPeriod+0x2c>)
 1001718:	18e4      	adds	r4, r4, r3
 100171a:	00e4      	lsls	r4, r4, #3
 100171c:	6026      	str	r6, [r4, #0]
    TIM_NCNT(TIMx) = LowLevelPeriod;
 100171e:	6065      	str	r5, [r4, #4]
}
 1001720:	bd70      	pop	{r4, r5, r6, pc}
 1001722:	46c0      	nop			; (mov r8, r8)
 1001724:	01002664 	.word	0x01002664
 1001728:	01002602 	.word	0x01002602
 100172c:	0001e180 	.word	0x0001e180

01001730 <TIM_PWMDifferential>:

void TIM_PWMDifferential(TIM_NumTypeDef TIMx, TIM_NumTypeDef TIMy, uint32_t LowLevelPeriod, uint32_t HighLevelPeriod)
{
 1001730:	b5f0      	push	{r4, r5, r6, r7, lr}
 1001732:	b085      	sub	sp, #20
 1001734:	0006      	movs	r6, r0
 1001736:	000d      	movs	r5, r1
 1001738:	0017      	movs	r7, r2
 100173a:	9301      	str	r3, [sp, #4]
    _ASSERT(ISTIMERNUM(TIMx));
 100173c:	2808      	cmp	r0, #8
 100173e:	d904      	bls.n	100174a <TIM_PWMDifferential+0x1a>
 1001740:	4a20      	ldr	r2, [pc, #128]	; (10017c4 <TIM_PWMDifferential+0x94>)
 1001742:	2174      	movs	r1, #116	; 0x74
 1001744:	4820      	ldr	r0, [pc, #128]	; (10017c8 <TIM_PWMDifferential+0x98>)
 1001746:	f7fe ff5b 	bl	1000600 <_assert_handler>
    _ASSERT(ISTIMERNUM(TIMy));
 100174a:	2d08      	cmp	r5, #8
 100174c:	d904      	bls.n	1001758 <TIM_PWMDifferential+0x28>
 100174e:	4a1d      	ldr	r2, [pc, #116]	; (10017c4 <TIM_PWMDifferential+0x94>)
 1001750:	2175      	movs	r1, #117	; 0x75
 1001752:	481d      	ldr	r0, [pc, #116]	; (10017c8 <TIM_PWMDifferential+0x98>)
 1001754:	f7fe ff54 	bl	1000600 <_assert_handler>

    uint32_t TDifferentialConfig;

    TIM_CTRL &= ~((1 << (TIMy * 4)) | (1 << (TIMx * 4)));
 1001758:	4c1c      	ldr	r4, [pc, #112]	; (10017cc <TIM_PWMDifferential+0x9c>)
 100175a:	00b1      	lsls	r1, r6, #2
 100175c:	6823      	ldr	r3, [r4, #0]
 100175e:	00aa      	lsls	r2, r5, #2
 1001760:	9302      	str	r3, [sp, #8]
 1001762:	00b3      	lsls	r3, r6, #2
 1001764:	9303      	str	r3, [sp, #12]
 1001766:	2301      	movs	r3, #1
 1001768:	0018      	movs	r0, r3
 100176a:	4088      	lsls	r0, r1
 100176c:	4684      	mov	ip, r0
 100176e:	0018      	movs	r0, r3
 1001770:	4661      	mov	r1, ip
 1001772:	4090      	lsls	r0, r2
 1001774:	4308      	orrs	r0, r1
 1001776:	9902      	ldr	r1, [sp, #8]
 1001778:	4381      	bics	r1, r0
 100177a:	6021      	str	r1, [r4, #0]
    TIM_PCNT(TIMx) = HighLevelPeriod;
 100177c:	4914      	ldr	r1, [pc, #80]	; (10017d0 <TIM_PWMDifferential+0xa0>)
 100177e:	9801      	ldr	r0, [sp, #4]
 1001780:	1876      	adds	r6, r6, r1
    TIM_NCNT(TIMx) = LowLevelPeriod;
    TIM_PCNT(TIMy) = LowLevelPeriod;
 1001782:	186d      	adds	r5, r5, r1
    TIM_PCNT(TIMx) = HighLevelPeriod;
 1001784:	00f6      	lsls	r6, r6, #3
    TIM_PCNT(TIMy) = LowLevelPeriod;
 1001786:	00ed      	lsls	r5, r5, #3
    TIM_PCNT(TIMx) = HighLevelPeriod;
 1001788:	6030      	str	r0, [r6, #0]
    TIM_NCNT(TIMx) = LowLevelPeriod;
 100178a:	6077      	str	r7, [r6, #4]
    TIM_PCNT(TIMy) = LowLevelPeriod;
 100178c:	602f      	str	r7, [r5, #0]
    TIM_NCNT(TIMy) = HighLevelPeriod;
 100178e:	6068      	str	r0, [r5, #4]
    TIM_CTRL &= ~(1 << (TIMx * 4 + 1));
 1001790:	001d      	movs	r5, r3
 1001792:	9903      	ldr	r1, [sp, #12]
 1001794:	6820      	ldr	r0, [r4, #0]
 1001796:	18c9      	adds	r1, r1, r3
 1001798:	408d      	lsls	r5, r1
 100179a:	43a8      	bics	r0, r5
    TDifferentialConfig = TIM_CTRL;
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 100179c:	2503      	movs	r5, #3
    TIM_CTRL &= ~(1 << (TIMx * 4 + 1));
 100179e:	6020      	str	r0, [r4, #0]
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 10017a0:	4095      	lsls	r5, r2
 10017a2:	4660      	mov	r0, ip
    TIM_CTRL |= 1 << (TIMy * 4 + 1);
 10017a4:	18d2      	adds	r2, r2, r3
 10017a6:	4093      	lsls	r3, r2
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 10017a8:	4305      	orrs	r5, r0
    delay((LowLevelPeriod - 8) / 4);
 10017aa:	0038      	movs	r0, r7
    TDifferentialConfig = TIM_CTRL;
 10017ac:	6821      	ldr	r1, [r4, #0]
    delay((LowLevelPeriod - 8) / 4);
 10017ae:	3808      	subs	r0, #8
    TDifferentialConfig |= ((3 << (TIMy * 4)) | (1 << (TIMx * 4)));
 10017b0:	430d      	orrs	r5, r1
    TIM_CTRL |= 1 << (TIMy * 4 + 1);
 10017b2:	6821      	ldr	r1, [r4, #0]
    delay((LowLevelPeriod - 8) / 4);
 10017b4:	0880      	lsrs	r0, r0, #2
    TIM_CTRL |= 1 << (TIMy * 4 + 1);
 10017b6:	430b      	orrs	r3, r1
 10017b8:	6023      	str	r3, [r4, #0]
    delay((LowLevelPeriod - 8) / 4);
 10017ba:	f7fe fdc4 	bl	1000346 <delay>
    TIM_CTRL = TDifferentialConfig;
 10017be:	6025      	str	r5, [r4, #0]
}
 10017c0:	b005      	add	sp, #20
 10017c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 10017c4:	01002675 	.word	0x01002675
 10017c8:	01002602 	.word	0x01002602
 10017cc:	000f0c48 	.word	0x000f0c48
 10017d0:	0001e180 	.word	0x0001e180

010017d4 <usb0_tx>:
    USB_TRG =  1 << ep;
    return;
}

static void usb0_tx()
{
 10017d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    byte len, i;

    if (remain)
 10017d6:	4918      	ldr	r1, [pc, #96]	; (1001838 <usb0_tx+0x64>)
 10017d8:	780a      	ldrb	r2, [r1, #0]
 10017da:	2a00      	cmp	r2, #0
 10017dc:	d029      	beq.n	1001832 <usb0_tx+0x5e>
    {
        len = remain > EP0_PACKET_SIZE ? EP0_PACKET_SIZE : remain;
 10017de:	1c13      	adds	r3, r2, #0
 10017e0:	2a40      	cmp	r2, #64	; 0x40
 10017e2:	d900      	bls.n	10017e6 <usb0_tx+0x12>
 10017e4:	2340      	movs	r3, #64	; 0x40
 10017e6:	2200      	movs	r2, #0
        for (i = 0; i < len; i++)
        {
            USB_EP(0) = bufptr[i];
 10017e8:	4814      	ldr	r0, [pc, #80]	; (100183c <usb0_tx+0x68>)
 10017ea:	4c15      	ldr	r4, [pc, #84]	; (1001840 <usb0_tx+0x6c>)
            if (isstr) USB_EP(0) = 0;
 10017ec:	4e15      	ldr	r6, [pc, #84]	; (1001844 <usb0_tx+0x70>)
        len = remain > EP0_PACKET_SIZE ? EP0_PACKET_SIZE : remain;
 10017ee:	b2db      	uxtb	r3, r3
            USB_EP(0) = bufptr[i];
 10017f0:	6805      	ldr	r5, [r0, #0]
 10017f2:	5cad      	ldrb	r5, [r5, r2]
 10017f4:	7025      	strb	r5, [r4, #0]
            if (isstr) USB_EP(0) = 0;
 10017f6:	7835      	ldrb	r5, [r6, #0]
 10017f8:	2d00      	cmp	r5, #0
 10017fa:	d001      	beq.n	1001800 <usb0_tx+0x2c>
 10017fc:	2500      	movs	r5, #0
 10017fe:	7025      	strb	r5, [r4, #0]
 1001800:	3201      	adds	r2, #1
        for (i = 0; i < len; i++)
 1001802:	b2d5      	uxtb	r5, r2
 1001804:	42ab      	cmp	r3, r5
 1001806:	d8f3      	bhi.n	10017f0 <usb0_tx+0x1c>
        }
        bufptr += len;
 1001808:	6802      	ldr	r2, [r0, #0]
 100180a:	18d2      	adds	r2, r2, r3
 100180c:	6002      	str	r2, [r0, #0]
        remain -= len;
 100180e:	780a      	ldrb	r2, [r1, #0]
 1001810:	1ad3      	subs	r3, r2, r3
 1001812:	700b      	strb	r3, [r1, #0]
    for (i = 0; i < 90; i++);
 1001814:	2300      	movs	r3, #0
 1001816:	9301      	str	r3, [sp, #4]
 1001818:	9b01      	ldr	r3, [sp, #4]
 100181a:	2b59      	cmp	r3, #89	; 0x59
 100181c:	dd06      	ble.n	100182c <usb0_tx+0x58>
    USB_TRG =  1 << ep;
 100181e:	2201      	movs	r2, #1
 1001820:	4b09      	ldr	r3, [pc, #36]	; (1001848 <usb0_tx+0x74>)
 1001822:	701a      	strb	r2, [r3, #0]
        usb_trig(0);
        USB_INT_MASK(1) =  0xfe;
 1001824:	4b09      	ldr	r3, [pc, #36]	; (100184c <usb0_tx+0x78>)
 1001826:	32fd      	adds	r2, #253	; 0xfd
    }
    else
    {
        USB_INT_MASK(1) =  0xff;
 1001828:	701a      	strb	r2, [r3, #0]
    }
}
 100182a:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
    for (i = 0; i < 90; i++);
 100182c:	9b01      	ldr	r3, [sp, #4]
 100182e:	3301      	adds	r3, #1
 1001830:	e7f1      	b.n	1001816 <usb0_tx+0x42>
        USB_INT_MASK(1) =  0xff;
 1001832:	4b06      	ldr	r3, [pc, #24]	; (100184c <usb0_tx+0x78>)
 1001834:	22ff      	movs	r2, #255	; 0xff
 1001836:	e7f7      	b.n	1001828 <usb0_tx+0x54>
 1001838:	00020a50 	.word	0x00020a50
 100183c:	00020a04 	.word	0x00020a04
 1001840:	000f6018 	.word	0x000f6018
 1001844:	00020a00 	.word	0x00020a00
 1001848:	000f6010 	.word	0x000f6010
 100184c:	000f6002 	.word	0x000f6002

01001850 <usb0_respond>:


static void usb0_respond(byte const *buff, byte size)
{
 1001850:	b510      	push	{r4, lr}
    if (isstr)
 1001852:	4b0b      	ldr	r3, [pc, #44]	; (1001880 <usb0_respond+0x30>)
 1001854:	781b      	ldrb	r3, [r3, #0]
 1001856:	2b00      	cmp	r3, #0
 1001858:	d006      	beq.n	1001868 <usb0_respond+0x18>
    {
        USB_EP(0) = (size + 1) * 2;
 100185a:	1c4b      	adds	r3, r1, #1
 100185c:	4a09      	ldr	r2, [pc, #36]	; (1001884 <usb0_respond+0x34>)
 100185e:	005b      	lsls	r3, r3, #1
 1001860:	b2db      	uxtb	r3, r3
 1001862:	7013      	strb	r3, [r2, #0]
        USB_EP(0) = 3;
 1001864:	2303      	movs	r3, #3
 1001866:	7013      	strb	r3, [r2, #0]
    }
    if (size > usb0_setup.wLength)
 1001868:	4b07      	ldr	r3, [pc, #28]	; (1001888 <usb0_respond+0x38>)
 100186a:	88db      	ldrh	r3, [r3, #6]
 100186c:	4299      	cmp	r1, r3
 100186e:	d900      	bls.n	1001872 <usb0_respond+0x22>
        size = usb0_setup.wLength;
 1001870:	b2d9      	uxtb	r1, r3
    bufptr = buff;
 1001872:	4b06      	ldr	r3, [pc, #24]	; (100188c <usb0_respond+0x3c>)
 1001874:	6018      	str	r0, [r3, #0]
    remain = size;
 1001876:	4b06      	ldr	r3, [pc, #24]	; (1001890 <usb0_respond+0x40>)
 1001878:	7019      	strb	r1, [r3, #0]
    usb0_tx();
 100187a:	f7ff ffab 	bl	10017d4 <usb0_tx>
}
 100187e:	bd10      	pop	{r4, pc}
 1001880:	00020a00 	.word	0x00020a00
 1001884:	000f6018 	.word	0x000f6018
 1001888:	000218bc 	.word	0x000218bc
 100188c:	00020a04 	.word	0x00020a04
 1001890:	00020a50 	.word	0x00020a50

01001894 <buflen>:
#define INCPTR(x, inc)      (x + inc >= sizeof(usbbuf) ? x + inc - sizeof(usbbuf) : x + inc)

#define INTXCPTR(x, inc)      (x + inc >= sizeof(usbtxbuf) ? x + inc - sizeof(usbtxbuf) : x + inc)
int buflen()
{
    return uwp < urp ? uwp - urp + sizeof(usbbuf) : uwp - urp;
 1001894:	4b04      	ldr	r3, [pc, #16]	; (10018a8 <buflen+0x14>)
 1001896:	681a      	ldr	r2, [r3, #0]
 1001898:	4b04      	ldr	r3, [pc, #16]	; (10018ac <buflen+0x18>)
 100189a:	681b      	ldr	r3, [r3, #0]
 100189c:	1ad0      	subs	r0, r2, r3
 100189e:	429a      	cmp	r2, r3
 10018a0:	da00      	bge.n	10018a4 <buflen+0x10>
 10018a2:	3041      	adds	r0, #65	; 0x41
}
 10018a4:	4770      	bx	lr
 10018a6:	46c0      	nop			; (mov r8, r8)
 10018a8:	000218b8 	.word	0x000218b8
 10018ac:	00020a4c 	.word	0x00020a4c

010018b0 <txbuflen>:

int txbuflen()
{
    return utxwp < utxrp ? utxwp - utxrp + sizeof(usbtxbuf) : utxwp - utxrp;
 10018b0:	4b04      	ldr	r3, [pc, #16]	; (10018c4 <txbuflen+0x14>)
 10018b2:	681a      	ldr	r2, [r3, #0]
 10018b4:	4b04      	ldr	r3, [pc, #16]	; (10018c8 <txbuflen+0x18>)
 10018b6:	681b      	ldr	r3, [r3, #0]
 10018b8:	1ad0      	subs	r0, r2, r3
 10018ba:	429a      	cmp	r2, r3
 10018bc:	da00      	bge.n	10018c0 <txbuflen+0x10>
 10018be:	3080      	adds	r0, #128	; 0x80
}
 10018c0:	4770      	bx	lr
 10018c2:	46c0      	nop			; (mov r8, r8)
 10018c4:	00020c6c 	.word	0x00020c6c
 10018c8:	000218dc 	.word	0x000218dc

010018cc <usb2buf>:

void usb2buf(int len)
{
    int i;
    for (i = 0; i < len; i++, uwp = INCPTR(uwp, 1))
 10018cc:	2300      	movs	r3, #0
{
 10018ce:	b570      	push	{r4, r5, r6, lr}
        usbbuf[uwp] = USB_EP(1);
 10018d0:	4c07      	ldr	r4, [pc, #28]	; (10018f0 <usb2buf+0x24>)
 10018d2:	4d08      	ldr	r5, [pc, #32]	; (10018f4 <usb2buf+0x28>)
 10018d4:	4e08      	ldr	r6, [pc, #32]	; (10018f8 <usb2buf+0x2c>)
    for (i = 0; i < len; i++, uwp = INCPTR(uwp, 1))
 10018d6:	4283      	cmp	r3, r0
 10018d8:	db00      	blt.n	10018dc <usb2buf+0x10>
}
 10018da:	bd70      	pop	{r4, r5, r6, pc}
        usbbuf[uwp] = USB_EP(1);
 10018dc:	6821      	ldr	r1, [r4, #0]
 10018de:	782a      	ldrb	r2, [r5, #0]
    for (i = 0; i < len; i++, uwp = INCPTR(uwp, 1))
 10018e0:	3301      	adds	r3, #1
        usbbuf[uwp] = USB_EP(1);
 10018e2:	5472      	strb	r2, [r6, r1]
    for (i = 0; i < len; i++, uwp = INCPTR(uwp, 1))
 10018e4:	1c4a      	adds	r2, r1, #1
 10018e6:	2a40      	cmp	r2, #64	; 0x40
 10018e8:	d900      	bls.n	10018ec <usb2buf+0x20>
 10018ea:	3a41      	subs	r2, #65	; 0x41
 10018ec:	6022      	str	r2, [r4, #0]
 10018ee:	e7f2      	b.n	10018d6 <usb2buf+0xa>
 10018f0:	000218b8 	.word	0x000218b8
 10018f4:	000f6019 	.word	0x000f6019
 10018f8:	00020a08 	.word	0x00020a08

010018fc <usb2txbuf>:

void usb2txbuf(int txlen)
{
 10018fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    byte len, i;
    if (txlen)
 10018fe:	2800      	cmp	r0, #0
 1001900:	d034      	beq.n	100196c <usb2txbuf+0x70>
    {
        len = txlen > EP1_PACKET_SIZE ? EP1_PACKET_SIZE : txlen;
 1001902:	2840      	cmp	r0, #64	; 0x40
 1001904:	dd00      	ble.n	1001908 <usb2txbuf+0xc>
 1001906:	2040      	movs	r0, #64	; 0x40
        for (i = 0; i < len; i++, utxrp = INTXCPTR(utxrp, 1))
        {
            USB_EP(1)  = usbtxbuf[utxrp];
 1001908:	491a      	ldr	r1, [pc, #104]	; (1001974 <usb2txbuf+0x78>)
        for (i = 0; i < len; i++, utxrp = INTXCPTR(utxrp, 1))
 100190a:	2300      	movs	r3, #0
            USB_EP(1)  = usbtxbuf[utxrp];
 100190c:	468c      	mov	ip, r1
 100190e:	4a1a      	ldr	r2, [pc, #104]	; (1001978 <usb2txbuf+0x7c>)
            totaltxlen_chksum = totaltxlen_chksum + usbtxbuf[utxrp];
 1001910:	4e1a      	ldr	r6, [pc, #104]	; (100197c <usb2txbuf+0x80>)
        len = txlen > EP1_PACKET_SIZE ? EP1_PACKET_SIZE : txlen;
 1001912:	b2c7      	uxtb	r7, r0
        for (i = 0; i < len; i++, utxrp = INTXCPTR(utxrp, 1))
 1001914:	429f      	cmp	r7, r3
 1001916:	d813      	bhi.n	1001940 <usb2txbuf+0x44>
        }
        totaltxlen += len;
 1001918:	4b19      	ldr	r3, [pc, #100]	; (1001980 <usb2txbuf+0x84>)
 100191a:	b2c0      	uxtb	r0, r0
 100191c:	681a      	ldr	r2, [r3, #0]
 100191e:	1880      	adds	r0, r0, r2
 1001920:	6018      	str	r0, [r3, #0]
    for (i = 0; i < 90; i++);
 1001922:	2300      	movs	r3, #0
 1001924:	9301      	str	r3, [sp, #4]
 1001926:	9b01      	ldr	r3, [sp, #4]
 1001928:	2b59      	cmp	r3, #89	; 0x59
 100192a:	dd1c      	ble.n	1001966 <usb2txbuf+0x6a>
    USB_TRG =  1 << ep;
 100192c:	2202      	movs	r2, #2
 100192e:	4b15      	ldr	r3, [pc, #84]	; (1001984 <usb2txbuf+0x88>)
 1001930:	701a      	strb	r2, [r3, #0]
        usb_trig(1);
        usb1_send_flag = 0;
 1001932:	2200      	movs	r2, #0
 1001934:	4b14      	ldr	r3, [pc, #80]	; (1001988 <usb2txbuf+0x8c>)
 1001936:	701a      	strb	r2, [r3, #0]
        USB_INT_MASK(1) =  0xfd;
 1001938:	4b14      	ldr	r3, [pc, #80]	; (100198c <usb2txbuf+0x90>)
 100193a:	32fd      	adds	r2, #253	; 0xfd
    }
    else
    {
        USB_INT_MASK(1) =  0xff;
 100193c:	701a      	strb	r2, [r3, #0]
    }
}
 100193e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
            USB_EP(1)  = usbtxbuf[utxrp];
 1001940:	6811      	ldr	r1, [r2, #0]
 1001942:	4c13      	ldr	r4, [pc, #76]	; (1001990 <usb2txbuf+0x94>)
        for (i = 0; i < len; i++, utxrp = INTXCPTR(utxrp, 1))
 1001944:	3301      	adds	r3, #1
            USB_EP(1)  = usbtxbuf[utxrp];
 1001946:	5c61      	ldrb	r1, [r4, r1]
 1001948:	4664      	mov	r4, ip
 100194a:	7021      	strb	r1, [r4, #0]
            totaltxlen_chksum = totaltxlen_chksum + usbtxbuf[utxrp];
 100194c:	6814      	ldr	r4, [r2, #0]
 100194e:	4910      	ldr	r1, [pc, #64]	; (1001990 <usb2txbuf+0x94>)
 1001950:	6835      	ldr	r5, [r6, #0]
 1001952:	5d09      	ldrb	r1, [r1, r4]
        for (i = 0; i < len; i++, utxrp = INTXCPTR(utxrp, 1))
 1001954:	b2db      	uxtb	r3, r3
            totaltxlen_chksum = totaltxlen_chksum + usbtxbuf[utxrp];
 1001956:	1949      	adds	r1, r1, r5
 1001958:	6031      	str	r1, [r6, #0]
        for (i = 0; i < len; i++, utxrp = INTXCPTR(utxrp, 1))
 100195a:	1c61      	adds	r1, r4, #1
 100195c:	297f      	cmp	r1, #127	; 0x7f
 100195e:	d900      	bls.n	1001962 <usb2txbuf+0x66>
 1001960:	3980      	subs	r1, #128	; 0x80
 1001962:	6011      	str	r1, [r2, #0]
 1001964:	e7d6      	b.n	1001914 <usb2txbuf+0x18>
    for (i = 0; i < 90; i++);
 1001966:	9b01      	ldr	r3, [sp, #4]
 1001968:	3301      	adds	r3, #1
 100196a:	e7db      	b.n	1001924 <usb2txbuf+0x28>
        USB_INT_MASK(1) =  0xff;
 100196c:	4b07      	ldr	r3, [pc, #28]	; (100198c <usb2txbuf+0x90>)
 100196e:	22ff      	movs	r2, #255	; 0xff
 1001970:	e7e4      	b.n	100193c <usb2txbuf+0x40>
 1001972:	46c0      	nop			; (mov r8, r8)
 1001974:	000f6019 	.word	0x000f6019
 1001978:	000218dc 	.word	0x000218dc
 100197c:	00020904 	.word	0x00020904
 1001980:	00020900 	.word	0x00020900
 1001984:	000f6010 	.word	0x000f6010
 1001988:	00020000 	.word	0x00020000
 100198c:	000f6002 	.word	0x000f6002
 1001990:	00020a60 	.word	0x00020a60

01001994 <txbufreeelen>:

int txbufreeelen()
{
    return sizeof(usbtxbuf) - (utxwp < utxrp ? utxwp - utxrp + sizeof(usbtxbuf) : utxwp - utxrp);
 1001994:	4b05      	ldr	r3, [pc, #20]	; (10019ac <txbufreeelen+0x18>)
 1001996:	681a      	ldr	r2, [r3, #0]
 1001998:	4b05      	ldr	r3, [pc, #20]	; (10019b0 <txbufreeelen+0x1c>)
 100199a:	681b      	ldr	r3, [r3, #0]
 100199c:	1ad0      	subs	r0, r2, r3
 100199e:	429a      	cmp	r2, r3
 10019a0:	da01      	bge.n	10019a6 <txbufreeelen+0x12>
 10019a2:	4240      	negs	r0, r0
}
 10019a4:	4770      	bx	lr
    return sizeof(usbtxbuf) - (utxwp < utxrp ? utxwp - utxrp + sizeof(usbtxbuf) : utxwp - utxrp);
 10019a6:	2380      	movs	r3, #128	; 0x80
 10019a8:	1a18      	subs	r0, r3, r0
 10019aa:	e7fb      	b.n	10019a4 <txbufreeelen+0x10>
 10019ac:	00020c6c 	.word	0x00020c6c
 10019b0:	000218dc 	.word	0x000218dc

010019b4 <USB_IRQHandler>:

void USB_IRQHandler()
{
 10019b4:	b570      	push	{r4, r5, r6, lr}
    int i, len;
    int txlen;
    byte status, empty, full;
    byte *buf = (byte *)&usb0_setup;
    status = USB_STATUS;
    empty = USB_FIFO_EMPTY;
 10019b6:	496c      	ldr	r1, [pc, #432]	; (1001b68 <USB_IRQHandler+0x1b4>)
    status = USB_STATUS;
 10019b8:	4c6c      	ldr	r4, [pc, #432]	; (1001b6c <USB_IRQHandler+0x1b8>)
    full = USB_FIFO_FULL;
 10019ba:	4a6d      	ldr	r2, [pc, #436]	; (1001b70 <USB_IRQHandler+0x1bc>)
    status = USB_STATUS;
 10019bc:	7825      	ldrb	r5, [r4, #0]
    empty = USB_FIFO_EMPTY;
 10019be:	780e      	ldrb	r6, [r1, #0]
    full = USB_FIFO_FULL;
 10019c0:	7813      	ldrb	r3, [r2, #0]
    status = USB_STATUS;
 10019c2:	b2ed      	uxtb	r5, r5
    full = USB_FIFO_FULL;
 10019c4:	b2db      	uxtb	r3, r3
    empty = USB_FIFO_EMPTY;
 10019c6:	b2f6      	uxtb	r6, r6
    USB_FIFO_EMPTY =  empty;
 10019c8:	700e      	strb	r6, [r1, #0]
    USB_STATUS =  status;
 10019ca:	7025      	strb	r5, [r4, #0]
    USB_FIFO_FULL = full;
 10019cc:	7013      	strb	r3, [r2, #0]
    if (status & USB_STATUS_RESET)
 10019ce:	b26b      	sxtb	r3, r5
 10019d0:	2b00      	cmp	r3, #0
 10019d2:	da02      	bge.n	10019da <USB_IRQHandler+0x26>
    {
        USB_ADDR = 0x00;
 10019d4:	2200      	movs	r2, #0
 10019d6:	4b67      	ldr	r3, [pc, #412]	; (1001b74 <USB_IRQHandler+0x1c0>)
 10019d8:	701a      	strb	r2, [r3, #0]
    }
    if (empty & 1)
 10019da:	07f3      	lsls	r3, r6, #31
 10019dc:	d501      	bpl.n	10019e2 <USB_IRQHandler+0x2e>
    {
        usb0_tx();
 10019de:	f7ff fef9 	bl	10017d4 <usb0_tx>
    }
    if (empty & 2)
 10019e2:	07b3      	lsls	r3, r6, #30
 10019e4:	d505      	bpl.n	10019f2 <USB_IRQHandler+0x3e>
    {
        usb1_send_flag = 1;
 10019e6:	2201      	movs	r2, #1
 10019e8:	4b63      	ldr	r3, [pc, #396]	; (1001b78 <USB_IRQHandler+0x1c4>)
 10019ea:	701a      	strb	r2, [r3, #0]
        USB_INT_MASK(1) =  0xff;
 10019ec:	4b63      	ldr	r3, [pc, #396]	; (1001b7c <USB_IRQHandler+0x1c8>)
 10019ee:	32fe      	adds	r2, #254	; 0xfe
 10019f0:	701a      	strb	r2, [r3, #0]
    }
    if (status & USB_STATUS_FIFO0_READY)
 10019f2:	07eb      	lsls	r3, r5, #31
 10019f4:	d51f      	bpl.n	1001a36 <USB_IRQHandler+0x82>
    {
        len = USB_EP_LEN(0);
 10019f6:	4b62      	ldr	r3, [pc, #392]	; (1001b80 <USB_IRQHandler+0x1cc>)
        for (i = 0; i < len; i++)
            buf[i] = USB_EP(0);
 10019f8:	4962      	ldr	r1, [pc, #392]	; (1001b84 <USB_IRQHandler+0x1d0>)
        len = USB_EP_LEN(0);
 10019fa:	781a      	ldrb	r2, [r3, #0]
        for (i = 0; i < len; i++)
 10019fc:	2300      	movs	r3, #0
            buf[i] = USB_EP(0);
 10019fe:	4862      	ldr	r0, [pc, #392]	; (1001b88 <USB_IRQHandler+0x1d4>)
        len = USB_EP_LEN(0);
 1001a00:	b2d2      	uxtb	r2, r2
        for (i = 0; i < len; i++)
 1001a02:	4293      	cmp	r3, r2
 1001a04:	db0c      	blt.n	1001a20 <USB_IRQHandler+0x6c>
        if (status & USB_STATUS_SETUP)
 1001a06:	2110      	movs	r1, #16
 1001a08:	420d      	tst	r5, r1
 1001a0a:	d014      	beq.n	1001a36 <USB_IRQHandler+0x82>
        {
            usb0_setup.wLength = usb0_setup.wLength;
            usb0_setup.wValue = usb0_setup.wValue;
            if ((usb0_setup.bmRequestType & ~0x80) == HCI_CLASS_REQUEST_TYPE)
 1001a0c:	4b5e      	ldr	r3, [pc, #376]	; (1001b88 <USB_IRQHandler+0x1d4>)
 1001a0e:	2080      	movs	r0, #128	; 0x80
 1001a10:	781a      	ldrb	r2, [r3, #0]
 1001a12:	0016      	movs	r6, r2
 1001a14:	4386      	bics	r6, r0
 1001a16:	2e20      	cmp	r6, #32
 1001a18:	d106      	bne.n	1001a28 <USB_IRQHandler+0x74>
            else if ((usb0_setup.bmRequestType & ~0x80) == HID_CLASS_REQUEST_TYPE)
            {
                switch (usb0_setup.bRequest)
                {
                case SET_IDLE:
                    USB_TRG = 0x10;
 1001a1a:	4b5c      	ldr	r3, [pc, #368]	; (1001b8c <USB_IRQHandler+0x1d8>)
 1001a1c:	7019      	strb	r1, [r3, #0]
                    break;
 1001a1e:	e00a      	b.n	1001a36 <USB_IRQHandler+0x82>
            buf[i] = USB_EP(0);
 1001a20:	780e      	ldrb	r6, [r1, #0]
 1001a22:	54c6      	strb	r6, [r0, r3]
        for (i = 0; i < len; i++)
 1001a24:	3301      	adds	r3, #1
 1001a26:	e7ec      	b.n	1001a02 <USB_IRQHandler+0x4e>
 1001a28:	7858      	ldrb	r0, [r3, #1]
            else if ((usb0_setup.bmRequestType & ~0x80) == HID_CLASS_REQUEST_TYPE)
 1001a2a:	2e21      	cmp	r6, #33	; 0x21
 1001a2c:	d131      	bne.n	1001a92 <USB_IRQHandler+0xde>
                switch (usb0_setup.bRequest)
 1001a2e:	2800      	cmp	r0, #0
 1001a30:	d028      	beq.n	1001a84 <USB_IRQHandler+0xd0>
 1001a32:	280a      	cmp	r0, #10
 1001a34:	d0f1      	beq.n	1001a1a <USB_IRQHandler+0x66>
            }

        }

    }
    if (status & USB_STATUS_FIFO1_READY)
 1001a36:	2302      	movs	r3, #2
 1001a38:	421d      	tst	r5, r3
 1001a3a:	d022      	beq.n	1001a82 <USB_IRQHandler+0xce>
    {
        USB_STATUS =  USB_STATUS_FIFO1_READY;
        len = USB_EP_LEN(1);
        timeout = 0;
 1001a3c:	2200      	movs	r2, #0
        USB_STATUS =  USB_STATUS_FIFO1_READY;
 1001a3e:	7023      	strb	r3, [r4, #0]
        len = USB_EP_LEN(1);
 1001a40:	4b53      	ldr	r3, [pc, #332]	; (1001b90 <USB_IRQHandler+0x1dc>)
 1001a42:	781c      	ldrb	r4, [r3, #0]
        timeout = 0;
 1001a44:	4b53      	ldr	r3, [pc, #332]	; (1001b94 <USB_IRQHandler+0x1e0>)
        len = USB_EP_LEN(1);
 1001a46:	b2e4      	uxtb	r4, r4
        timeout = 0;
 1001a48:	601a      	str	r2, [r3, #0]

        if (status & USB_STATUS_NAK)
 1001a4a:	2340      	movs	r3, #64	; 0x40
 1001a4c:	401d      	ands	r5, r3
 1001a4e:	4295      	cmp	r5, r2
 1001a50:	d100      	bne.n	1001a54 <USB_IRQHandler+0xa0>
 1001a52:	e079      	b.n	1001b48 <USB_IRQHandler+0x194>
        {
            if (rxlen == 0)
 1001a54:	4d50      	ldr	r5, [pc, #320]	; (1001b98 <USB_IRQHandler+0x1e4>)
 1001a56:	782b      	ldrb	r3, [r5, #0]
 1001a58:	4293      	cmp	r3, r2
 1001a5a:	d100      	bne.n	1001a5e <USB_IRQHandler+0xaa>
            {
                rxlen = len;
 1001a5c:	702c      	strb	r4, [r5, #0]
            }
            if (buflen() + rxlen < sizeof(usbbuf))
 1001a5e:	f7ff ff19 	bl	1001894 <buflen>
 1001a62:	0003      	movs	r3, r0
 1001a64:	7828      	ldrb	r0, [r5, #0]
 1001a66:	181b      	adds	r3, r3, r0
 1001a68:	2b40      	cmp	r3, #64	; 0x40
 1001a6a:	d80a      	bhi.n	1001a82 <USB_IRQHandler+0xce>
            {
                usb2buf(rxlen);
 1001a6c:	f7ff ff2e 	bl	10018cc <usb2buf>
                for (i = 0; i < len - rxlen; i++) USB_EP(1);
 1001a70:	782b      	ldrb	r3, [r5, #0]
 1001a72:	4a4a      	ldr	r2, [pc, #296]	; (1001b9c <USB_IRQHandler+0x1e8>)
 1001a74:	1ae4      	subs	r4, r4, r3
 1001a76:	2300      	movs	r3, #0
 1001a78:	429c      	cmp	r4, r3
 1001a7a:	dd00      	ble.n	1001a7e <USB_IRQHandler+0xca>
 1001a7c:	e061      	b.n	1001b42 <USB_IRQHandler+0x18e>
                rxlen = 0;
 1001a7e:	2300      	movs	r3, #0
 1001a80:	702b      	strb	r3, [r5, #0]
            {
                rxlen = len;
            }
        }
    }
}
 1001a82:	bd70      	pop	{r4, r5, r6, pc}
                    usb0_respond(id, sizeof(id) - 1);
 1001a84:	210a      	movs	r1, #10
                    isstr = 0;
 1001a86:	4b46      	ldr	r3, [pc, #280]	; (1001ba0 <USB_IRQHandler+0x1ec>)
 1001a88:	7018      	strb	r0, [r3, #0]
                    usb0_respond(id, sizeof(id) - 1);
 1001a8a:	4846      	ldr	r0, [pc, #280]	; (1001ba4 <USB_IRQHandler+0x1f0>)
        usb0_respond((byte const *)string[index], strlength[index] - 1);
 1001a8c:	f7ff fee0 	bl	1001850 <usb0_respond>
 1001a90:	e7d1      	b.n	1001a36 <USB_IRQHandler+0x82>
                switch (usb0_setup.bRequest)
 1001a92:	3805      	subs	r0, #5
 1001a94:	2806      	cmp	r0, #6
 1001a96:	d851      	bhi.n	1001b3c <USB_IRQHandler+0x188>
 1001a98:	f000 faf4 	bl	1002084 <__gnu_thumb1_case_uqi>
 1001a9c:	50501304 	.word	0x50501304
 1001aa0:	503a      	.short	0x503a
 1001aa2:	48          	.byte	0x48
 1001aa3:	00          	.byte	0x00
    if (usb0_setup.bmRequestType == IN_DEVICE && usb0_setup.wIndex == 0
 1001aa4:	2a00      	cmp	r2, #0
 1001aa6:	d149      	bne.n	1001b3c <USB_IRQHandler+0x188>
 1001aa8:	889a      	ldrh	r2, [r3, #4]
 1001aaa:	2a00      	cmp	r2, #0
 1001aac:	d146      	bne.n	1001b3c <USB_IRQHandler+0x188>
            && usb0_setup.wLength == 0)
 1001aae:	88da      	ldrh	r2, [r3, #6]
 1001ab0:	2a00      	cmp	r2, #0
 1001ab2:	d143      	bne.n	1001b3c <USB_IRQHandler+0x188>
        USB_TRG = 0x10;
 1001ab4:	2110      	movs	r1, #16
 1001ab6:	4a35      	ldr	r2, [pc, #212]	; (1001b8c <USB_IRQHandler+0x1d8>)
 1001ab8:	7011      	strb	r1, [r2, #0]
        USB_ADDR = usb0_setup.wValue;
 1001aba:	789a      	ldrb	r2, [r3, #2]
 1001abc:	4b2d      	ldr	r3, [pc, #180]	; (1001b74 <USB_IRQHandler+0x1c0>)
    USB_STALL =  1;
 1001abe:	701a      	strb	r2, [r3, #0]
 1001ac0:	e7b9      	b.n	1001a36 <USB_IRQHandler+0x82>
    isstr = 0;
 1001ac2:	2200      	movs	r2, #0
 1001ac4:	4936      	ldr	r1, [pc, #216]	; (1001ba0 <USB_IRQHandler+0x1ec>)
 1001ac6:	700a      	strb	r2, [r1, #0]
    switch (usb0_setup.wValue >> 8)
 1001ac8:	885a      	ldrh	r2, [r3, #2]
 1001aca:	0a13      	lsrs	r3, r2, #8
 1001acc:	2b02      	cmp	r3, #2
 1001ace:	d00f      	beq.n	1001af0 <USB_IRQHandler+0x13c>
 1001ad0:	2b03      	cmp	r3, #3
 1001ad2:	d010      	beq.n	1001af6 <USB_IRQHandler+0x142>
 1001ad4:	2b01      	cmp	r3, #1
 1001ad6:	d131      	bne.n	1001b3c <USB_IRQHandler+0x188>
        usb0_respond((byte const *)&devicedesc, sizeof(devicedesc));
 1001ad8:	2112      	movs	r1, #18
 1001ada:	4833      	ldr	r0, [pc, #204]	; (1001ba8 <USB_IRQHandler+0x1f4>)
 1001adc:	f7ff feb8 	bl	1001850 <usb0_respond>
        if (USB_ADDR > 0) USB_ADDR |= 0x80;
 1001ae0:	4b24      	ldr	r3, [pc, #144]	; (1001b74 <USB_IRQHandler+0x1c0>)
 1001ae2:	781a      	ldrb	r2, [r3, #0]
 1001ae4:	2a00      	cmp	r2, #0
 1001ae6:	d0a6      	beq.n	1001a36 <USB_IRQHandler+0x82>
 1001ae8:	2180      	movs	r1, #128	; 0x80
 1001aea:	781a      	ldrb	r2, [r3, #0]
 1001aec:	430a      	orrs	r2, r1
 1001aee:	e7e6      	b.n	1001abe <USB_IRQHandler+0x10a>
        usb0_respond(confdesc, sizeof(confdesc));
 1001af0:	2120      	movs	r1, #32
 1001af2:	482e      	ldr	r0, [pc, #184]	; (1001bac <USB_IRQHandler+0x1f8>)
 1001af4:	e7ca      	b.n	1001a8c <USB_IRQHandler+0xd8>
        index = usb0_setup.wValue  & 3;
 1001af6:	4013      	ands	r3, r2
        isstr = index > 0;
 1001af8:	001a      	movs	r2, r3
 1001afa:	1e50      	subs	r0, r2, #1
 1001afc:	4182      	sbcs	r2, r0
 1001afe:	700a      	strb	r2, [r1, #0]
        usb0_respond((byte const *)string[index], strlength[index] - 1);
 1001b00:	4a2b      	ldr	r2, [pc, #172]	; (1001bb0 <USB_IRQHandler+0x1fc>)
 1001b02:	5cd1      	ldrb	r1, [r2, r3]
 1001b04:	4a2b      	ldr	r2, [pc, #172]	; (1001bb4 <USB_IRQHandler+0x200>)
 1001b06:	3901      	subs	r1, #1
 1001b08:	009b      	lsls	r3, r3, #2
 1001b0a:	b2c9      	uxtb	r1, r1
 1001b0c:	5898      	ldr	r0, [r3, r2]
 1001b0e:	e7bd      	b.n	1001a8c <USB_IRQHandler+0xd8>
    if (usb0_setup.bmRequestType == IN_DEVICE
 1001b10:	2a00      	cmp	r2, #0
 1001b12:	d113      	bne.n	1001b3c <USB_IRQHandler+0x188>
            && usb0_setup.wIndex == 0 && usb0_setup.wLength == 0
 1001b14:	889a      	ldrh	r2, [r3, #4]
 1001b16:	2a00      	cmp	r2, #0
 1001b18:	d110      	bne.n	1001b3c <USB_IRQHandler+0x188>
 1001b1a:	88da      	ldrh	r2, [r3, #6]
 1001b1c:	2a00      	cmp	r2, #0
 1001b1e:	d10d      	bne.n	1001b3c <USB_IRQHandler+0x188>
            && usb0_setup.wValue <= 1)
 1001b20:	885b      	ldrh	r3, [r3, #2]
 1001b22:	2b01      	cmp	r3, #1
 1001b24:	d80a      	bhi.n	1001b3c <USB_IRQHandler+0x188>
        USB_TRG = 0x10;
 1001b26:	4b19      	ldr	r3, [pc, #100]	; (1001b8c <USB_IRQHandler+0x1d8>)
 1001b28:	3210      	adds	r2, #16
 1001b2a:	e7c8      	b.n	1001abe <USB_IRQHandler+0x10a>
    if (usb0_setup.bmRequestType == IN_INTERFACE
 1001b2c:	2a01      	cmp	r2, #1
 1001b2e:	d105      	bne.n	1001b3c <USB_IRQHandler+0x188>
            && usb0_setup.wValue == 0
 1001b30:	885a      	ldrh	r2, [r3, #2]
 1001b32:	2a00      	cmp	r2, #0
 1001b34:	d102      	bne.n	1001b3c <USB_IRQHandler+0x188>
            && usb0_setup.wLength == 0)
 1001b36:	88db      	ldrh	r3, [r3, #6]
 1001b38:	2b00      	cmp	r3, #0
 1001b3a:	d0f4      	beq.n	1001b26 <USB_IRQHandler+0x172>
    USB_STALL =  1;
 1001b3c:	4b1e      	ldr	r3, [pc, #120]	; (1001bb8 <USB_IRQHandler+0x204>)
 1001b3e:	2201      	movs	r2, #1
 1001b40:	e7bd      	b.n	1001abe <USB_IRQHandler+0x10a>
                for (i = 0; i < len - rxlen; i++) USB_EP(1);
 1001b42:	7811      	ldrb	r1, [r2, #0]
 1001b44:	3301      	adds	r3, #1
 1001b46:	e797      	b.n	1001a78 <USB_IRQHandler+0xc4>
        else if (len > 0)
 1001b48:	2c00      	cmp	r4, #0
 1001b4a:	d100      	bne.n	1001b4e <USB_IRQHandler+0x19a>
 1001b4c:	e799      	b.n	1001a82 <USB_IRQHandler+0xce>
            if (buflen() + len < sizeof(usbbuf))
 1001b4e:	f7ff fea1 	bl	1001894 <buflen>
 1001b52:	1900      	adds	r0, r0, r4
 1001b54:	4e10      	ldr	r6, [pc, #64]	; (1001b98 <USB_IRQHandler+0x1e4>)
 1001b56:	2840      	cmp	r0, #64	; 0x40
 1001b58:	d804      	bhi.n	1001b64 <USB_IRQHandler+0x1b0>
                usb2buf(len);
 1001b5a:	0020      	movs	r0, r4
 1001b5c:	f7ff feb6 	bl	10018cc <usb2buf>
                rxlen = 0;
 1001b60:	7035      	strb	r5, [r6, #0]
 1001b62:	e78e      	b.n	1001a82 <USB_IRQHandler+0xce>
                rxlen = len;
 1001b64:	7034      	strb	r4, [r6, #0]
}
 1001b66:	e78c      	b.n	1001a82 <USB_IRQHandler+0xce>
 1001b68:	000f6027 	.word	0x000f6027
 1001b6c:	000f6026 	.word	0x000f6026
 1001b70:	000f6028 	.word	0x000f6028
 1001b74:	000f6004 	.word	0x000f6004
 1001b78:	00020000 	.word	0x00020000
 1001b7c:	000f6002 	.word	0x000f6002
 1001b80:	000f6020 	.word	0x000f6020
 1001b84:	000f6018 	.word	0x000f6018
 1001b88:	000218bc 	.word	0x000218bc
 1001b8c:	000f6010 	.word	0x000f6010
 1001b90:	000f6021 	.word	0x000f6021
 1001b94:	00020c70 	.word	0x00020c70
 1001b98:	00020c00 	.word	0x00020c00
 1001b9c:	000f6019 	.word	0x000f6019
 1001ba0:	00020a00 	.word	0x00020a00
 1001ba4:	010026fc 	.word	0x010026fc
 1001ba8:	0100268c 	.word	0x0100268c
 1001bac:	0100269e 	.word	0x0100269e
 1001bb0:	01002707 	.word	0x01002707
 1001bb4:	010026ec 	.word	0x010026ec
 1001bb8:	000f6011 	.word	0x000f6011

01001bbc <enable_systick>:


void enable_systick(int counter)
{
    SYST_RVR = SYST_CVR = counter;
    SYST_CSR = 7;
 1001bbc:	2207      	movs	r2, #7
    SYST_RVR = SYST_CVR = counter;
 1001bbe:	4b03      	ldr	r3, [pc, #12]	; (1001bcc <enable_systick+0x10>)
 1001bc0:	6018      	str	r0, [r3, #0]
 1001bc2:	4b03      	ldr	r3, [pc, #12]	; (1001bd0 <enable_systick+0x14>)
 1001bc4:	6018      	str	r0, [r3, #0]
    SYST_CSR = 7;
 1001bc6:	4b03      	ldr	r3, [pc, #12]	; (1001bd4 <enable_systick+0x18>)
 1001bc8:	601a      	str	r2, [r3, #0]
}
 1001bca:	4770      	bx	lr
 1001bcc:	e000e018 	.word	0xe000e018
 1001bd0:	e000e014 	.word	0xe000e014
 1001bd4:	e000e010 	.word	0xe000e010

01001bd8 <usb_main>:
int i, len, dataLen, usbTotallen;
uint32_t increse = 0;
void usb_main()
{

    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001bd8:	2300      	movs	r3, #0
    next_urp = -1;
 1001bda:	2101      	movs	r1, #1
    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001bdc:	4a65      	ldr	r2, [pc, #404]	; (1001d74 <usb_main+0x19c>)
{
 1001bde:	b5f0      	push	{r4, r5, r6, r7, lr}
    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001be0:	6013      	str	r3, [r2, #0]
 1001be2:	4a65      	ldr	r2, [pc, #404]	; (1001d78 <usb_main+0x1a0>)
    next_urp = -1;
 1001be4:	4249      	negs	r1, r1
    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001be6:	6013      	str	r3, [r2, #0]
 1001be8:	4a64      	ldr	r2, [pc, #400]	; (1001d7c <usb_main+0x1a4>)
{
 1001bea:	4c65      	ldr	r4, [pc, #404]	; (1001d80 <usb_main+0x1a8>)
    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001bec:	6013      	str	r3, [r2, #0]
 1001bee:	4a65      	ldr	r2, [pc, #404]	; (1001d84 <usb_main+0x1ac>)
 1001bf0:	4e65      	ldr	r6, [pc, #404]	; (1001d88 <usb_main+0x1b0>)
 1001bf2:	6013      	str	r3, [r2, #0]
 1001bf4:	4a65      	ldr	r2, [pc, #404]	; (1001d8c <usb_main+0x1b4>)
{
 1001bf6:	44a5      	add	sp, r4
    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001bf8:	6013      	str	r3, [r2, #0]
 1001bfa:	4a65      	ldr	r2, [pc, #404]	; (1001d90 <usb_main+0x1b8>)
    for (int i = 0; i < sizeof(pcnt) / sizeof(pcnt[0]); i++) pcnt[i] = 0;
 1001bfc:	4c65      	ldr	r4, [pc, #404]	; (1001d94 <usb_main+0x1bc>)
    remain = mcmd = rxlen = clear_fifo = tptr = uwp = urp = timeout = totallen = pcp = tc = chksum = utxwp = utxrp = 0;
 1001bfe:	6013      	str	r3, [r2, #0]
 1001c00:	4a65      	ldr	r2, [pc, #404]	; (1001d98 <usb_main+0x1c0>)
 1001c02:	6033      	str	r3, [r6, #0]
 1001c04:	6013      	str	r3, [r2, #0]
 1001c06:	4a65      	ldr	r2, [pc, #404]	; (1001d9c <usb_main+0x1c4>)
 1001c08:	6013      	str	r3, [r2, #0]
 1001c0a:	4a65      	ldr	r2, [pc, #404]	; (1001da0 <usb_main+0x1c8>)
 1001c0c:	6013      	str	r3, [r2, #0]
 1001c0e:	4a65      	ldr	r2, [pc, #404]	; (1001da4 <usb_main+0x1cc>)
 1001c10:	7013      	strb	r3, [r2, #0]
 1001c12:	4a65      	ldr	r2, [pc, #404]	; (1001da8 <usb_main+0x1d0>)
 1001c14:	7013      	strb	r3, [r2, #0]
 1001c16:	4a65      	ldr	r2, [pc, #404]	; (1001dac <usb_main+0x1d4>)
 1001c18:	7013      	strb	r3, [r2, #0]
 1001c1a:	4a65      	ldr	r2, [pc, #404]	; (1001db0 <usb_main+0x1d8>)
 1001c1c:	7013      	strb	r3, [r2, #0]
    next_urp = -1;
 1001c1e:	4a65      	ldr	r2, [pc, #404]	; (1001db4 <usb_main+0x1dc>)
 1001c20:	6011      	str	r1, [r2, #0]
    for (int i = 0; i < sizeof(pcnt) / sizeof(pcnt[0]); i++) pcnt[i] = 0;
 1001c22:	0019      	movs	r1, r3
 1001c24:	4a64      	ldr	r2, [pc, #400]	; (1001db8 <usb_main+0x1e0>)
 1001c26:	1918      	adds	r0, r3, r4
 1001c28:	3301      	adds	r3, #1
 1001c2a:	7001      	strb	r1, [r0, #0]
 1001c2c:	4293      	cmp	r3, r2
 1001c2e:	d1fa      	bne.n	1001c26 <usb_main+0x4e>
    SYSCTRL_CLK_CLS &= ~(1 << id);
 1001c30:	4b62      	ldr	r3, [pc, #392]	; (1001dbc <usb_main+0x1e4>)
 1001c32:	4863      	ldr	r0, [pc, #396]	; (1001dc0 <usb_main+0x1e8>)
 1001c34:	681a      	ldr	r2, [r3, #0]
    enable_clock(CLKCLS_BT);
    enable_clock(CLKCLS_UART);
    enable_clock(CLKCLS_USB);
    USB_CONFIG =  0x00;
 1001c36:	24f6      	movs	r4, #246	; 0xf6
 1001c38:	4002      	ands	r2, r0
 1001c3a:	601a      	str	r2, [r3, #0]
 1001c3c:	681a      	ldr	r2, [r3, #0]
 1001c3e:	4861      	ldr	r0, [pc, #388]	; (1001dc4 <usb_main+0x1ec>)
 1001c40:	0324      	lsls	r4, r4, #12
 1001c42:	4002      	ands	r2, r0
 1001c44:	2040      	movs	r0, #64	; 0x40
 1001c46:	601a      	str	r2, [r3, #0]
 1001c48:	681a      	ldr	r2, [r3, #0]
    delay_ms(1);
    USB_CONFIG =  0x30;
    USB_INT_MASK(0) =  0x30;
    USB_INT_MASK(1) =  0xff;
 1001c4a:	25ff      	movs	r5, #255	; 0xff
 1001c4c:	4382      	bics	r2, r0
 1001c4e:	601a      	str	r2, [r3, #0]
    delay_ms(1);
 1001c50:	383f      	subs	r0, #63	; 0x3f
    USB_CONFIG =  0x00;
 1001c52:	7021      	strb	r1, [r4, #0]
    delay_ms(1);
 1001c54:	f7ff fc52 	bl	10014fc <delay_ms>
    USB_CONFIG =  0x30;
 1001c58:	2330      	movs	r3, #48	; 0x30
 1001c5a:	7023      	strb	r3, [r4, #0]
    NVIC_ISER |= 1 << intid;
 1001c5c:	2401      	movs	r4, #1
    USB_INT_MASK(0) =  0x30;
 1001c5e:	4a5a      	ldr	r2, [pc, #360]	; (1001dc8 <usb_main+0x1f0>)
    USB_INT_MASK(2) =  0xff;

    enable_intr(INTR_USB);
    NVIC_EnableIRQ(TIM0_IRQn);
 1001c60:	200d      	movs	r0, #13
    USB_INT_MASK(0) =  0x30;
 1001c62:	7013      	strb	r3, [r2, #0]
    USB_INT_MASK(1) =  0xff;
 1001c64:	4b59      	ldr	r3, [pc, #356]	; (1001dcc <usb_main+0x1f4>)
 1001c66:	4a5a      	ldr	r2, [pc, #360]	; (1001dd0 <usb_main+0x1f8>)
 1001c68:	701d      	strb	r5, [r3, #0]
    USB_INT_MASK(2) =  0xff;
 1001c6a:	4b5a      	ldr	r3, [pc, #360]	; (1001dd4 <usb_main+0x1fc>)
 1001c6c:	701d      	strb	r5, [r3, #0]
 1001c6e:	6813      	ldr	r3, [r2, #0]
 1001c70:	4323      	orrs	r3, r4
 1001c72:	6013      	str	r3, [r2, #0]
    NVIC_EnableIRQ(TIM0_IRQn);
 1001c74:	f7fe fcfa 	bl	100066c <NVIC_EnableIRQ>

    NVIC_SetPriority(USB_IRQn, 0);
 1001c78:	2100      	movs	r1, #0
 1001c7a:	0008      	movs	r0, r1
 1001c7c:	f7fe fcc2 	bl	1000604 <NVIC_SetPriority>
    NVIC_SetPriority(TIM0_IRQn, 1);
 1001c80:	0021      	movs	r1, r4
 1001c82:	200d      	movs	r0, #13
 1001c84:	f7fe fcbe 	bl	1000604 <NVIC_SetPriority>

    TIMER_Configuration();
 1001c88:	f000 f916 	bl	1001eb8 <TIMER_Configuration>

    uint8_t uartretval;
    uint8_t recvlen;
    uint32_t recvtotallen = 0;
    uint8_t buf[65] = {0};
 1001c8c:	2241      	movs	r2, #65	; 0x41
 1001c8e:	2100      	movs	r1, #0
 1001c90:	a803      	add	r0, sp, #12
 1001c92:	f000 f9a9 	bl	1001fe8 <memset>
    uint8_t big_buffer_have_space = 1;
    uint8_t big_buffer[1024] = {0};
 1001c96:	2280      	movs	r2, #128	; 0x80
 1001c98:	2100      	movs	r1, #0
 1001c9a:	00d2      	lsls	r2, r2, #3
 1001c9c:	a814      	add	r0, sp, #80	; 0x50
 1001c9e:	f000 f9a3 	bl	1001fe8 <memset>
    uint8_t big_buffer_have_space = 1;
 1001ca2:	9400      	str	r4, [sp, #0]
    uint32_t recvtotallen = 0;
 1001ca4:	2400      	movs	r4, #0
 1001ca6:	9501      	str	r5, [sp, #4]
    while (1)
    {

        recvlen = buflen();
 1001ca8:	f7ff fdf4 	bl	1001894 <buflen>

        if (recvlen > 0)
 1001cac:	b2c0      	uxtb	r0, r0
 1001cae:	2800      	cmp	r0, #0
 1001cb0:	d012      	beq.n	1001cd8 <usb_main+0x100>
        {
            if (big_buffer_have_space)
 1001cb2:	9b00      	ldr	r3, [sp, #0]
 1001cb4:	2b00      	cmp	r3, #0
 1001cb6:	d00f      	beq.n	1001cd8 <usb_main+0x100>
            {
                /*receive data in to big buffer*/
                recvlen = usb_get_buffer(buf);
 1001cb8:	a803      	add	r0, sp, #12
 1001cba:	f000 f8a1 	bl	1001e00 <usb_get_buffer>
 1001cbe:	9d01      	ldr	r5, [sp, #4]
                
                memcpy(big_buffer,buf,recvlen);
 1001cc0:	a903      	add	r1, sp, #12
 1001cc2:	4005      	ands	r5, r0
 1001cc4:	002a      	movs	r2, r5
 1001cc6:	a814      	add	r0, sp, #80	; 0x50

                recvtotallen += recvlen;
 1001cc8:	1964      	adds	r4, r4, r5
                memcpy(big_buffer,buf,recvlen);
 1001cca:	f000 f949 	bl	1001f60 <memcpy>
                MyPrintf("recvlen = %d recvtotallen = %d\r\n", recvlen, recvtotallen);
 1001cce:	0022      	movs	r2, r4
 1001cd0:	0029      	movs	r1, r5
 1001cd2:	4841      	ldr	r0, [pc, #260]	; (1001dd8 <usb_main+0x200>)
 1001cd4:	f7fe fb77 	bl	10003c6 <MyPrintf>
                /*big_buffer_have_no_space*/
            }

        }

        if (txbuflen() > 0)
 1001cd8:	f7ff fdea 	bl	10018b0 <txbuflen>
 1001cdc:	2800      	cmp	r0, #0
 1001cde:	dd05      	ble.n	1001cec <usb_main+0x114>
        {
            if (usb1_send_flag == 1)
 1001ce0:	4b3e      	ldr	r3, [pc, #248]	; (1001ddc <usb_main+0x204>)
 1001ce2:	781b      	ldrb	r3, [r3, #0]
 1001ce4:	2b01      	cmp	r3, #1
 1001ce6:	d101      	bne.n	1001cec <usb_main+0x114>
            {
                usb2txbuf(txbuflen());
 1001ce8:	f7ff fe08 	bl	10018fc <usb2txbuf>
        /*usb_last_packet in TIMER0_IRQHandler*/

        //usb_last_packet();
        

        if (UART_IsRXFIFONotEmpty(UART0))
 1001cec:	2000      	movs	r0, #0
 1001cee:	f7ff f9ab 	bl	1001048 <UART_IsRXFIFONotEmpty>
 1001cf2:	2800      	cmp	r0, #0
 1001cf4:	d0d8      	beq.n	1001ca8 <usb_main+0xd0>
        {
            uartretval = UART_ReceiveData(UART0);
 1001cf6:	2000      	movs	r0, #0
 1001cf8:	f7ff fa22 	bl	1001140 <UART_ReceiveData>
            switch (uartretval)
 1001cfc:	2832      	cmp	r0, #50	; 0x32
 1001cfe:	d02d      	beq.n	1001d5c <usb_main+0x184>
 1001d00:	d812      	bhi.n	1001d28 <usb_main+0x150>
 1001d02:	2831      	cmp	r0, #49	; 0x31
 1001d04:	d1d0      	bne.n	1001ca8 <usb_main+0xd0>
            {
            case '1':
                MyPrintf("case '1' !\n\n");
 1001d06:	4836      	ldr	r0, [pc, #216]	; (1001de0 <usb_main+0x208>)
 1001d08:	f7fe fb5d 	bl	10003c6 <MyPrintf>
                /*prapare usb tx send data*/
                for (int i = 0; i < 100; i++, utxwp = INTXCPTR(utxwp, 1))
 1001d0c:	2200      	movs	r2, #0
 1001d0e:	6831      	ldr	r1, [r6, #0]
                    usbtxbuf[utxwp]  = i;
 1001d10:	4834      	ldr	r0, [pc, #208]	; (1001de4 <usb_main+0x20c>)
                for (int i = 0; i < 100; i++, utxwp = INTXCPTR(utxwp, 1))
 1001d12:	1c4b      	adds	r3, r1, #1
                    usbtxbuf[utxwp]  = i;
 1001d14:	5442      	strb	r2, [r0, r1]
                for (int i = 0; i < 100; i++, utxwp = INTXCPTR(utxwp, 1))
 1001d16:	3201      	adds	r2, #1
 1001d18:	2b7f      	cmp	r3, #127	; 0x7f
 1001d1a:	d900      	bls.n	1001d1e <usb_main+0x146>
 1001d1c:	3b80      	subs	r3, #128	; 0x80
 1001d1e:	0019      	movs	r1, r3
 1001d20:	2a64      	cmp	r2, #100	; 0x64
 1001d22:	d1f6      	bne.n	1001d12 <usb_main+0x13a>
 1001d24:	6033      	str	r3, [r6, #0]
 1001d26:	e7bf      	b.n	1001ca8 <usb_main+0xd0>
            switch (uartretval)
 1001d28:	2833      	cmp	r0, #51	; 0x33
 1001d2a:	d01d      	beq.n	1001d68 <usb_main+0x190>
 1001d2c:	2863      	cmp	r0, #99	; 0x63
 1001d2e:	d1bb      	bne.n	1001ca8 <usb_main+0xd0>
            case '3':
                MyPrintf("big_buffer_have_space '0' !\n\n");
                big_buffer_have_space = 0;
                break;
            case 'c':
                MyPrintf("totallen = %d chksum = %d \n\n", totallen, chksum);
 1001d30:	4b11      	ldr	r3, [pc, #68]	; (1001d78 <usb_main+0x1a0>)
 1001d32:	4f16      	ldr	r7, [pc, #88]	; (1001d8c <usb_main+0x1b4>)
 1001d34:	681a      	ldr	r2, [r3, #0]
 1001d36:	6839      	ldr	r1, [r7, #0]
 1001d38:	482b      	ldr	r0, [pc, #172]	; (1001de8 <usb_main+0x210>)
 1001d3a:	f7fe fb44 	bl	10003c6 <MyPrintf>
                MyPrintf("totaltxlen = %d totaltxlen_chksum = %d \n\n", totaltxlen, totaltxlen_chksum);
 1001d3e:	4c2b      	ldr	r4, [pc, #172]	; (1001dec <usb_main+0x214>)
 1001d40:	4d2b      	ldr	r5, [pc, #172]	; (1001df0 <usb_main+0x218>)
 1001d42:	6822      	ldr	r2, [r4, #0]
 1001d44:	6829      	ldr	r1, [r5, #0]
 1001d46:	482b      	ldr	r0, [pc, #172]	; (1001df4 <usb_main+0x21c>)
 1001d48:	f7fe fb3d 	bl	10003c6 <MyPrintf>
                recvtotallen  = 0;
                totallen = 0;
 1001d4c:	2300      	movs	r3, #0
                chksum = 0;
 1001d4e:	4a0a      	ldr	r2, [pc, #40]	; (1001d78 <usb_main+0x1a0>)
                totaltxlen = 0;
                totaltxlen_chksum = 0; 
 1001d50:	6023      	str	r3, [r4, #0]
                totallen = 0;
 1001d52:	603b      	str	r3, [r7, #0]
                chksum = 0;
 1001d54:	6013      	str	r3, [r2, #0]
                totaltxlen = 0;
 1001d56:	602b      	str	r3, [r5, #0]
                recvtotallen  = 0;
 1001d58:	001c      	movs	r4, r3
                break;
 1001d5a:	e7a5      	b.n	1001ca8 <usb_main+0xd0>
                MyPrintf("big_buffer_have_space '1' !\n\n");
 1001d5c:	4826      	ldr	r0, [pc, #152]	; (1001df8 <usb_main+0x220>)
 1001d5e:	f7fe fb32 	bl	10003c6 <MyPrintf>
                big_buffer_have_space = 1;
 1001d62:	2301      	movs	r3, #1
                big_buffer_have_space = 0;
 1001d64:	9300      	str	r3, [sp, #0]
                break;
 1001d66:	e79f      	b.n	1001ca8 <usb_main+0xd0>
                MyPrintf("big_buffer_have_space '0' !\n\n");
 1001d68:	4824      	ldr	r0, [pc, #144]	; (1001dfc <usb_main+0x224>)
 1001d6a:	f7fe fb2c 	bl	10003c6 <MyPrintf>
                big_buffer_have_space = 0;
 1001d6e:	2300      	movs	r3, #0
 1001d70:	e7f8      	b.n	1001d64 <usb_main+0x18c>
 1001d72:	46c0      	nop			; (mov r8, r8)
 1001d74:	000218dc 	.word	0x000218dc
 1001d78:	000218c8 	.word	0x000218c8
 1001d7c:	00020a54 	.word	0x00020a54
 1001d80:	fffffbac 	.word	0xfffffbac
 1001d84:	000218d0 	.word	0x000218d0
 1001d88:	00020c6c 	.word	0x00020c6c
 1001d8c:	00020a5c 	.word	0x00020a5c
 1001d90:	00020c70 	.word	0x00020c70
 1001d94:	00020d00 	.word	0x00020d00
 1001d98:	00020a4c 	.word	0x00020a4c
 1001d9c:	000218b8 	.word	0x000218b8
 1001da0:	000218c4 	.word	0x000218c4
 1001da4:	00020a58 	.word	0x00020a58
 1001da8:	00020c00 	.word	0x00020c00
 1001dac:	00020a01 	.word	0x00020a01
 1001db0:	00020a50 	.word	0x00020a50
 1001db4:	000218cc 	.word	0x000218cc
 1001db8:	00000bb8 	.word	0x00000bb8
 1001dbc:	000f856c 	.word	0x000f856c
 1001dc0:	ffffdfff 	.word	0xffffdfff
 1001dc4:	ffff7fff 	.word	0xffff7fff
 1001dc8:	000f6001 	.word	0x000f6001
 1001dcc:	000f6002 	.word	0x000f6002
 1001dd0:	e000e100 	.word	0xe000e100
 1001dd4:	000f6003 	.word	0x000f6003
 1001dd8:	0100270b 	.word	0x0100270b
 1001ddc:	00020000 	.word	0x00020000
 1001de0:	0100272c 	.word	0x0100272c
 1001de4:	00020a60 	.word	0x00020a60
 1001de8:	01002775 	.word	0x01002775
 1001dec:	00020904 	.word	0x00020904
 1001df0:	00020900 	.word	0x00020900
 1001df4:	01002792 	.word	0x01002792
 1001df8:	01002739 	.word	0x01002739
 1001dfc:	01002757 	.word	0x01002757

01001e00 <usb_get_buffer>:
}



int usb_get_buffer(uint8_t *buf)
{
 1001e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1001e02:	0004      	movs	r4, r0
    int len;

    len = buflen();
 1001e04:	f7ff fd46 	bl	1001894 <buflen>
    if (len > 0)
 1001e08:	2800      	cmp	r0, #0
 1001e0a:	dd17      	ble.n	1001e3c <usb_get_buffer+0x3c>
 1001e0c:	0023      	movs	r3, r4
 1001e0e:	1826      	adds	r6, r4, r0
    {

        for (int i = 0; i < len; i++, urp = INCPTR(urp, 1))
        {
            buf[i] = usbbuf[urp];
 1001e10:	4f0b      	ldr	r7, [pc, #44]	; (1001e40 <usb_get_buffer+0x40>)
 1001e12:	4a0c      	ldr	r2, [pc, #48]	; (1001e44 <usb_get_buffer+0x44>)
            chksum += buf[i];
 1001e14:	4c0c      	ldr	r4, [pc, #48]	; (1001e48 <usb_get_buffer+0x48>)
            buf[i] = usbbuf[urp];
 1001e16:	6811      	ldr	r1, [r2, #0]
 1001e18:	5c79      	ldrb	r1, [r7, r1]
 1001e1a:	7019      	strb	r1, [r3, #0]
            chksum += buf[i];
 1001e1c:	6825      	ldr	r5, [r4, #0]
 1001e1e:	1869      	adds	r1, r5, r1
        for (int i = 0; i < len; i++, urp = INCPTR(urp, 1))
 1001e20:	6815      	ldr	r5, [r2, #0]
            chksum += buf[i];
 1001e22:	6021      	str	r1, [r4, #0]
        for (int i = 0; i < len; i++, urp = INCPTR(urp, 1))
 1001e24:	1c69      	adds	r1, r5, #1
 1001e26:	2940      	cmp	r1, #64	; 0x40
 1001e28:	d900      	bls.n	1001e2c <usb_get_buffer+0x2c>
 1001e2a:	3941      	subs	r1, #65	; 0x41
 1001e2c:	3301      	adds	r3, #1
 1001e2e:	6011      	str	r1, [r2, #0]
 1001e30:	429e      	cmp	r6, r3
 1001e32:	d1f0      	bne.n	1001e16 <usb_get_buffer+0x16>
        }
        totallen += len;
 1001e34:	4a05      	ldr	r2, [pc, #20]	; (1001e4c <usb_get_buffer+0x4c>)
 1001e36:	6813      	ldr	r3, [r2, #0]
 1001e38:	181b      	adds	r3, r3, r0
 1001e3a:	6013      	str	r3, [r2, #0]

    }
    return len;
}
 1001e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1001e3e:	46c0      	nop			; (mov r8, r8)
 1001e40:	00020a08 	.word	0x00020a08
 1001e44:	00020a4c 	.word	0x00020a4c
 1001e48:	000218c8 	.word	0x000218c8
 1001e4c:	00020a5c 	.word	0x00020a5c

01001e50 <usb_last_packet>:

void usb_last_packet(void)
{
 1001e50:	b570      	push	{r4, r5, r6, lr}
    /*please put usb_last_packet(); into Timer interrupt*/
    if (rxlen && buflen() + rxlen < sizeof(usbbuf))
 1001e52:	4d14      	ldr	r5, [pc, #80]	; (1001ea4 <usb_last_packet+0x54>)
 1001e54:	782e      	ldrb	r6, [r5, #0]
 1001e56:	2e00      	cmp	r6, #0
 1001e58:	d01e      	beq.n	1001e98 <usb_last_packet+0x48>
 1001e5a:	f7ff fd1b 	bl	1001894 <buflen>
 1001e5e:	1980      	adds	r0, r0, r6
 1001e60:	2840      	cmp	r0, #64	; 0x40
 1001e62:	d819      	bhi.n	1001e98 <usb_last_packet+0x48>
    {
        /*The expected value of the timeout is 100ms;
          timeout = 100ms/each into Timer interrupt time*/
        if (timeout++ > 100)
 1001e64:	4c10      	ldr	r4, [pc, #64]	; (1001ea8 <usb_last_packet+0x58>)
 1001e66:	6823      	ldr	r3, [r4, #0]
 1001e68:	1c5a      	adds	r2, r3, #1
 1001e6a:	6022      	str	r2, [r4, #0]
 1001e6c:	2b64      	cmp	r3, #100	; 0x64
 1001e6e:	dd13      	ble.n	1001e98 <usb_last_packet+0x48>
        {
            usb2buf(rxlen);
 1001e70:	0030      	movs	r0, r6
 1001e72:	f7ff fd2b 	bl	10018cc <usb2buf>
            for (i = 0; i < 64 - rxlen; i++) USB_EP(1);
 1001e76:	2300      	movs	r3, #0
 1001e78:	2240      	movs	r2, #64	; 0x40
 1001e7a:	490c      	ldr	r1, [pc, #48]	; (1001eac <usb_last_packet+0x5c>)
 1001e7c:	480c      	ldr	r0, [pc, #48]	; (1001eb0 <usb_last_packet+0x60>)
 1001e7e:	600b      	str	r3, [r1, #0]
 1001e80:	782b      	ldrb	r3, [r5, #0]
 1001e82:	1ad2      	subs	r2, r2, r3
 1001e84:	680b      	ldr	r3, [r1, #0]
 1001e86:	429a      	cmp	r2, r3
 1001e88:	dc07      	bgt.n	1001e9a <usb_last_packet+0x4a>
            rxlen = 0;
 1001e8a:	2200      	movs	r2, #0
            tc++;
 1001e8c:	4909      	ldr	r1, [pc, #36]	; (1001eb4 <usb_last_packet+0x64>)
            rxlen = 0;
 1001e8e:	702a      	strb	r2, [r5, #0]
            tc++;
 1001e90:	680b      	ldr	r3, [r1, #0]
            timeout = 0;
 1001e92:	6022      	str	r2, [r4, #0]
            tc++;
 1001e94:	3301      	adds	r3, #1
 1001e96:	600b      	str	r3, [r1, #0]
        }
    }
}
 1001e98:	bd70      	pop	{r4, r5, r6, pc}
            for (i = 0; i < 64 - rxlen; i++) USB_EP(1);
 1001e9a:	3301      	adds	r3, #1
 1001e9c:	7806      	ldrb	r6, [r0, #0]
 1001e9e:	600b      	str	r3, [r1, #0]
 1001ea0:	e7f0      	b.n	1001e84 <usb_last_packet+0x34>
 1001ea2:	46c0      	nop			; (mov r8, r8)
 1001ea4:	00020c00 	.word	0x00020c00
 1001ea8:	00020c70 	.word	0x00020c70
 1001eac:	00020c04 	.word	0x00020c04
 1001eb0:	000f6019 	.word	0x000f6019
 1001eb4:	00020a54 	.word	0x00020a54

01001eb8 <TIMER_Configuration>:
  * @brief  TIM configuration function.
  * @param  None
  * @retval None
  */
void TIMER_Configuration(void)
{
 1001eb8:	b513      	push	{r0, r1, r4, lr}
    TIM_InitTypeDef TIM_InitStruct;

    TIM_InitStruct.period = 96000;
 1001eba:	4b08      	ldr	r3, [pc, #32]	; (1001edc <TIMER_Configuration+0x24>)

    TIM_InitStruct.TIMx = TIM0;
 1001ebc:	2400      	movs	r4, #0
    TIM_InitStruct.period = 96000;
 1001ebe:	9301      	str	r3, [sp, #4]
    TIM_InitStruct.TIMx = TIM0;
 1001ec0:	466b      	mov	r3, sp
    TIM_Init(&TIM_InitStruct);
 1001ec2:	4668      	mov	r0, sp
    TIM_InitStruct.TIMx = TIM0;
 1001ec4:	701c      	strb	r4, [r3, #0]
    TIM_Init(&TIM_InitStruct);
 1001ec6:	f7ff fb1f 	bl	1001508 <TIM_Init>

    /* Configure timer for counting mode */
    TIM_ModeConfig(TIM0, TIM_Mode_TIMER);
 1001eca:	0020      	movs	r0, r4
 1001ecc:	2101      	movs	r1, #1
 1001ece:	f7ff fb7f 	bl	10015d0 <TIM_ModeConfig>


    /* The last step must be enabled */
    TIM_Cmd(TIM0, ENABLE);
 1001ed2:	2101      	movs	r1, #1
 1001ed4:	0020      	movs	r0, r4
 1001ed6:	f7ff fb4d 	bl	1001574 <TIM_Cmd>
}
 1001eda:	bd13      	pop	{r0, r1, r4, pc}
 1001edc:	00017700 	.word	0x00017700

01001ee0 <TIMER0_IRQHandler>:
  * @brief  TIM0~TIM8 Interrupt service function.
  * @param  None
  * @retval None
  */
void TIMER0_IRQHandler(void)
{
 1001ee0:	b510      	push	{r4, lr}
    usb_last_packet();
 1001ee2:	f7ff ffb5 	bl	1001e50 <usb_last_packet>
}
 1001ee6:	bd10      	pop	{r4, pc}

01001ee8 <UART_Configuration>:
  * @brief  Serial port 0 initialization function.
  * @param  None
  * @retval None
  */
void UART_Configuration(void)
{
 1001ee8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	UART_InitTypeDef UART_InitStruct;

	/* Configure serial ports RX and TX for IO. */
	GPIO_Config(GPIOA, GPIO_Pin_1, UART0_TXD);
 1001eea:	2208      	movs	r2, #8
 1001eec:	2102      	movs	r1, #2
 1001eee:	2000      	movs	r0, #0
 1001ef0:	f7fe fbe6 	bl	10006c0 <GPIO_Config>
	GPIO_Config(GPIOA, GPIO_Pin_0, UART0_RXD);
 1001ef4:	2209      	movs	r2, #9
 1001ef6:	2101      	movs	r1, #1
 1001ef8:	2000      	movs	r0, #0
 1001efa:	f7fe fbe1 	bl	10006c0 <GPIO_Config>
  - Stop Bit = 1 Stop Bit
  - Parity = No Parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
	UART_InitStruct.BaudRate = uartBaud;			//Configure serial port baud rate, the baud rate defaults to 128000.
 1001efe:	23e1      	movs	r3, #225	; 0xe1
 1001f00:	025b      	lsls	r3, r3, #9
 1001f02:	2000      	movs	r0, #0
 1001f04:	9301      	str	r3, [sp, #4]
	UART_InitStruct.DataBits = Databits_8b;
	UART_InitStruct.StopBits = StopBits_1;
	UART_InitStruct.Parity = Parity_None;
	UART_InitStruct.FlowCtrl = FlowCtrl_None;
	UART_InitStruct.Mode = Mode_duplex;
 1001f06:	466b      	mov	r3, sp

	UART_Init(UART0, &UART_InitStruct);
 1001f08:	4669      	mov	r1, sp
	UART_InitStruct.BaudRate = uartBaud;			//Configure serial port baud rate, the baud rate defaults to 128000.
 1001f0a:	9002      	str	r0, [sp, #8]
	UART_InitStruct.Mode = Mode_duplex;
 1001f0c:	7018      	strb	r0, [r3, #0]
	UART_Init(UART0, &UART_InitStruct);
 1001f0e:	f7fe ffe5 	bl	1000edc <UART_Init>
}
 1001f12:	b005      	add	sp, #20
 1001f14:	bd00      	pop	{pc}

01001f16 <UART_SendData_test>:
  * @brief  Serial port 0 single byte data send test function.
  * @param  None
  * @retval None
  */
void UART_SendData_test(void)
{
 1001f16:	b510      	push	{r4, lr}
	uint8_t Data[10] = {0};
	
	MyPrintf("UART_SendData:");
 1001f18:	4807      	ldr	r0, [pc, #28]	; (1001f38 <UART_SendData_test+0x22>)
 1001f1a:	f7fe fa54 	bl	10003c6 <MyPrintf>
 1001f1e:	2430      	movs	r4, #48	; 0x30
	
	for (int i = 0; i < 10; i++)
	{
		Data[i] = 0x30+i;
		/* Please use HEX mode for the host side */
		UART_SendData(UART0, Data[i]);
 1001f20:	0021      	movs	r1, r4
 1001f22:	3401      	adds	r4, #1
 1001f24:	2000      	movs	r0, #0
 1001f26:	b2e4      	uxtb	r4, r4
 1001f28:	f7ff f9ae 	bl	1001288 <UART_SendData>
	for (int i = 0; i < 10; i++)
 1001f2c:	2c3a      	cmp	r4, #58	; 0x3a
 1001f2e:	d1f7      	bne.n	1001f20 <UART_SendData_test+0xa>
	}
		MyPrintf("\r\n");
 1001f30:	4802      	ldr	r0, [pc, #8]	; (1001f3c <UART_SendData_test+0x26>)
 1001f32:	f7fe fa48 	bl	10003c6 <MyPrintf>
}
 1001f36:	bd10      	pop	{r4, pc}
 1001f38:	010027d6 	.word	0x010027d6
 1001f3c:	01002729 	.word	0x01002729

01001f40 <main>:
{
 1001f40:	b510      	push	{r4, lr}
    UART_Configuration();
 1001f42:	f7ff ffd1 	bl	1001ee8 <UART_Configuration>
    MyPrintf("UART TX SendData Demo !\n\n");
 1001f46:	4805      	ldr	r0, [pc, #20]	; (1001f5c <main+0x1c>)
 1001f48:	f7fe fa3d 	bl	10003c6 <MyPrintf>
    SYSCTRL_HCLKConfig(SYSCTRL_HCLK_Div_None);
 1001f4c:	2000      	movs	r0, #0
 1001f4e:	f7ff fa5f 	bl	1001410 <SYSCTRL_HCLKConfig>
    usb_main();
 1001f52:	f7ff fe41 	bl	1001bd8 <usb_main>
	UART_SendData_test();
 1001f56:	f7ff ffde 	bl	1001f16 <UART_SendData_test>
 1001f5a:	e7fe      	b.n	1001f5a <main+0x1a>
 1001f5c:	010027bc 	.word	0x010027bc

01001f60 <memcpy>:
 1001f60:	b5f0      	push	{r4, r5, r6, r7, lr}
 1001f62:	2a0f      	cmp	r2, #15
 1001f64:	d937      	bls.n	1001fd6 <memcpy+0x76>
 1001f66:	000d      	movs	r5, r1
 1001f68:	4305      	orrs	r5, r0
 1001f6a:	000c      	movs	r4, r1
 1001f6c:	0003      	movs	r3, r0
 1001f6e:	07ad      	lsls	r5, r5, #30
 1001f70:	d135      	bne.n	1001fde <memcpy+0x7e>
 1001f72:	0015      	movs	r5, r2
 1001f74:	3d10      	subs	r5, #16
 1001f76:	092d      	lsrs	r5, r5, #4
 1001f78:	012e      	lsls	r6, r5, #4
 1001f7a:	1836      	adds	r6, r6, r0
 1001f7c:	3610      	adds	r6, #16
 1001f7e:	6827      	ldr	r7, [r4, #0]
 1001f80:	601f      	str	r7, [r3, #0]
 1001f82:	6867      	ldr	r7, [r4, #4]
 1001f84:	605f      	str	r7, [r3, #4]
 1001f86:	68a7      	ldr	r7, [r4, #8]
 1001f88:	609f      	str	r7, [r3, #8]
 1001f8a:	68e7      	ldr	r7, [r4, #12]
 1001f8c:	3410      	adds	r4, #16
 1001f8e:	60df      	str	r7, [r3, #12]
 1001f90:	3310      	adds	r3, #16
 1001f92:	42b3      	cmp	r3, r6
 1001f94:	d1f3      	bne.n	1001f7e <memcpy+0x1e>
 1001f96:	240f      	movs	r4, #15
 1001f98:	3501      	adds	r5, #1
 1001f9a:	012d      	lsls	r5, r5, #4
 1001f9c:	1949      	adds	r1, r1, r5
 1001f9e:	4014      	ands	r4, r2
 1001fa0:	1945      	adds	r5, r0, r5
 1001fa2:	2c03      	cmp	r4, #3
 1001fa4:	d91d      	bls.n	1001fe2 <memcpy+0x82>
 1001fa6:	2300      	movs	r3, #0
 1001fa8:	58ce      	ldr	r6, [r1, r3]
 1001faa:	50ee      	str	r6, [r5, r3]
 1001fac:	3304      	adds	r3, #4
 1001fae:	1ae6      	subs	r6, r4, r3
 1001fb0:	2e03      	cmp	r6, #3
 1001fb2:	d8f9      	bhi.n	1001fa8 <memcpy+0x48>
 1001fb4:	2303      	movs	r3, #3
 1001fb6:	3c04      	subs	r4, #4
 1001fb8:	08a4      	lsrs	r4, r4, #2
 1001fba:	3401      	adds	r4, #1
 1001fbc:	00a4      	lsls	r4, r4, #2
 1001fbe:	401a      	ands	r2, r3
 1001fc0:	192d      	adds	r5, r5, r4
 1001fc2:	1909      	adds	r1, r1, r4
 1001fc4:	2a00      	cmp	r2, #0
 1001fc6:	d005      	beq.n	1001fd4 <memcpy+0x74>
 1001fc8:	2300      	movs	r3, #0
 1001fca:	5ccc      	ldrb	r4, [r1, r3]
 1001fcc:	54ec      	strb	r4, [r5, r3]
 1001fce:	3301      	adds	r3, #1
 1001fd0:	4293      	cmp	r3, r2
 1001fd2:	d1fa      	bne.n	1001fca <memcpy+0x6a>
 1001fd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1001fd6:	0005      	movs	r5, r0
 1001fd8:	2a00      	cmp	r2, #0
 1001fda:	d1f5      	bne.n	1001fc8 <memcpy+0x68>
 1001fdc:	e7fa      	b.n	1001fd4 <memcpy+0x74>
 1001fde:	0005      	movs	r5, r0
 1001fe0:	e7f2      	b.n	1001fc8 <memcpy+0x68>
 1001fe2:	0022      	movs	r2, r4
 1001fe4:	e7f8      	b.n	1001fd8 <memcpy+0x78>
 1001fe6:	46c0      	nop			; (mov r8, r8)

01001fe8 <memset>:
 1001fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
 1001fea:	0783      	lsls	r3, r0, #30
 1001fec:	d046      	beq.n	100207c <memset+0x94>
 1001fee:	1e54      	subs	r4, r2, #1
 1001ff0:	2a00      	cmp	r2, #0
 1001ff2:	d042      	beq.n	100207a <memset+0x92>
 1001ff4:	b2ce      	uxtb	r6, r1
 1001ff6:	0002      	movs	r2, r0
 1001ff8:	2503      	movs	r5, #3
 1001ffa:	e002      	b.n	1002002 <memset+0x1a>
 1001ffc:	001a      	movs	r2, r3
 1001ffe:	3c01      	subs	r4, #1
 1002000:	d33b      	bcc.n	100207a <memset+0x92>
 1002002:	1c53      	adds	r3, r2, #1
 1002004:	7016      	strb	r6, [r2, #0]
 1002006:	422b      	tst	r3, r5
 1002008:	d1f8      	bne.n	1001ffc <memset+0x14>
 100200a:	2c03      	cmp	r4, #3
 100200c:	d92d      	bls.n	100206a <memset+0x82>
 100200e:	22ff      	movs	r2, #255	; 0xff
 1002010:	400a      	ands	r2, r1
 1002012:	0215      	lsls	r5, r2, #8
 1002014:	4315      	orrs	r5, r2
 1002016:	042a      	lsls	r2, r5, #16
 1002018:	4315      	orrs	r5, r2
 100201a:	2c0f      	cmp	r4, #15
 100201c:	d916      	bls.n	100204c <memset+0x64>
 100201e:	0027      	movs	r7, r4
 1002020:	3f10      	subs	r7, #16
 1002022:	093f      	lsrs	r7, r7, #4
 1002024:	013e      	lsls	r6, r7, #4
 1002026:	46b4      	mov	ip, r6
 1002028:	001e      	movs	r6, r3
 100202a:	001a      	movs	r2, r3
 100202c:	3610      	adds	r6, #16
 100202e:	4466      	add	r6, ip
 1002030:	6015      	str	r5, [r2, #0]
 1002032:	6055      	str	r5, [r2, #4]
 1002034:	6095      	str	r5, [r2, #8]
 1002036:	60d5      	str	r5, [r2, #12]
 1002038:	3210      	adds	r2, #16
 100203a:	42b2      	cmp	r2, r6
 100203c:	d1f8      	bne.n	1002030 <memset+0x48>
 100203e:	220f      	movs	r2, #15
 1002040:	3701      	adds	r7, #1
 1002042:	013f      	lsls	r7, r7, #4
 1002044:	19db      	adds	r3, r3, r7
 1002046:	4014      	ands	r4, r2
 1002048:	2c03      	cmp	r4, #3
 100204a:	d90e      	bls.n	100206a <memset+0x82>
 100204c:	1f26      	subs	r6, r4, #4
 100204e:	08b6      	lsrs	r6, r6, #2
 1002050:	00b7      	lsls	r7, r6, #2
 1002052:	46bc      	mov	ip, r7
 1002054:	001a      	movs	r2, r3
 1002056:	1d1f      	adds	r7, r3, #4
 1002058:	4467      	add	r7, ip
 100205a:	c220      	stmia	r2!, {r5}
 100205c:	42ba      	cmp	r2, r7
 100205e:	d1fc      	bne.n	100205a <memset+0x72>
 1002060:	2203      	movs	r2, #3
 1002062:	3601      	adds	r6, #1
 1002064:	00b6      	lsls	r6, r6, #2
 1002066:	199b      	adds	r3, r3, r6
 1002068:	4014      	ands	r4, r2
 100206a:	2c00      	cmp	r4, #0
 100206c:	d005      	beq.n	100207a <memset+0x92>
 100206e:	b2c9      	uxtb	r1, r1
 1002070:	191c      	adds	r4, r3, r4
 1002072:	7019      	strb	r1, [r3, #0]
 1002074:	3301      	adds	r3, #1
 1002076:	429c      	cmp	r4, r3
 1002078:	d1fb      	bne.n	1002072 <memset+0x8a>
 100207a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100207c:	0014      	movs	r4, r2
 100207e:	0003      	movs	r3, r0
 1002080:	e7c3      	b.n	100200a <memset+0x22>
 1002082:	46c0      	nop			; (mov r8, r8)

01002084 <__gnu_thumb1_case_uqi>:
 1002084:	b402      	push	{r1}
 1002086:	4671      	mov	r1, lr
 1002088:	0849      	lsrs	r1, r1, #1
 100208a:	0049      	lsls	r1, r1, #1
 100208c:	5c09      	ldrb	r1, [r1, r0]
 100208e:	0049      	lsls	r1, r1, #1
 1002090:	448e      	add	lr, r1
 1002092:	bc02      	pop	{r1}
 1002094:	4770      	bx	lr
 1002096:	46c0      	nop			; (mov r8, r8)

01002098 <__udivsi3>:
 1002098:	2200      	movs	r2, #0
 100209a:	0843      	lsrs	r3, r0, #1
 100209c:	428b      	cmp	r3, r1
 100209e:	d374      	bcc.n	100218a <__udivsi3+0xf2>
 10020a0:	0903      	lsrs	r3, r0, #4
 10020a2:	428b      	cmp	r3, r1
 10020a4:	d35f      	bcc.n	1002166 <__udivsi3+0xce>
 10020a6:	0a03      	lsrs	r3, r0, #8
 10020a8:	428b      	cmp	r3, r1
 10020aa:	d344      	bcc.n	1002136 <__udivsi3+0x9e>
 10020ac:	0b03      	lsrs	r3, r0, #12
 10020ae:	428b      	cmp	r3, r1
 10020b0:	d328      	bcc.n	1002104 <__udivsi3+0x6c>
 10020b2:	0c03      	lsrs	r3, r0, #16
 10020b4:	428b      	cmp	r3, r1
 10020b6:	d30d      	bcc.n	10020d4 <__udivsi3+0x3c>
 10020b8:	22ff      	movs	r2, #255	; 0xff
 10020ba:	0209      	lsls	r1, r1, #8
 10020bc:	ba12      	rev	r2, r2
 10020be:	0c03      	lsrs	r3, r0, #16
 10020c0:	428b      	cmp	r3, r1
 10020c2:	d302      	bcc.n	10020ca <__udivsi3+0x32>
 10020c4:	1212      	asrs	r2, r2, #8
 10020c6:	0209      	lsls	r1, r1, #8
 10020c8:	d065      	beq.n	1002196 <__udivsi3+0xfe>
 10020ca:	0b03      	lsrs	r3, r0, #12
 10020cc:	428b      	cmp	r3, r1
 10020ce:	d319      	bcc.n	1002104 <__udivsi3+0x6c>
 10020d0:	e000      	b.n	10020d4 <__udivsi3+0x3c>
 10020d2:	0a09      	lsrs	r1, r1, #8
 10020d4:	0bc3      	lsrs	r3, r0, #15
 10020d6:	428b      	cmp	r3, r1
 10020d8:	d301      	bcc.n	10020de <__udivsi3+0x46>
 10020da:	03cb      	lsls	r3, r1, #15
 10020dc:	1ac0      	subs	r0, r0, r3
 10020de:	4152      	adcs	r2, r2
 10020e0:	0b83      	lsrs	r3, r0, #14
 10020e2:	428b      	cmp	r3, r1
 10020e4:	d301      	bcc.n	10020ea <__udivsi3+0x52>
 10020e6:	038b      	lsls	r3, r1, #14
 10020e8:	1ac0      	subs	r0, r0, r3
 10020ea:	4152      	adcs	r2, r2
 10020ec:	0b43      	lsrs	r3, r0, #13
 10020ee:	428b      	cmp	r3, r1
 10020f0:	d301      	bcc.n	10020f6 <__udivsi3+0x5e>
 10020f2:	034b      	lsls	r3, r1, #13
 10020f4:	1ac0      	subs	r0, r0, r3
 10020f6:	4152      	adcs	r2, r2
 10020f8:	0b03      	lsrs	r3, r0, #12
 10020fa:	428b      	cmp	r3, r1
 10020fc:	d301      	bcc.n	1002102 <__udivsi3+0x6a>
 10020fe:	030b      	lsls	r3, r1, #12
 1002100:	1ac0      	subs	r0, r0, r3
 1002102:	4152      	adcs	r2, r2
 1002104:	0ac3      	lsrs	r3, r0, #11
 1002106:	428b      	cmp	r3, r1
 1002108:	d301      	bcc.n	100210e <__udivsi3+0x76>
 100210a:	02cb      	lsls	r3, r1, #11
 100210c:	1ac0      	subs	r0, r0, r3
 100210e:	4152      	adcs	r2, r2
 1002110:	0a83      	lsrs	r3, r0, #10
 1002112:	428b      	cmp	r3, r1
 1002114:	d301      	bcc.n	100211a <__udivsi3+0x82>
 1002116:	028b      	lsls	r3, r1, #10
 1002118:	1ac0      	subs	r0, r0, r3
 100211a:	4152      	adcs	r2, r2
 100211c:	0a43      	lsrs	r3, r0, #9
 100211e:	428b      	cmp	r3, r1
 1002120:	d301      	bcc.n	1002126 <__udivsi3+0x8e>
 1002122:	024b      	lsls	r3, r1, #9
 1002124:	1ac0      	subs	r0, r0, r3
 1002126:	4152      	adcs	r2, r2
 1002128:	0a03      	lsrs	r3, r0, #8
 100212a:	428b      	cmp	r3, r1
 100212c:	d301      	bcc.n	1002132 <__udivsi3+0x9a>
 100212e:	020b      	lsls	r3, r1, #8
 1002130:	1ac0      	subs	r0, r0, r3
 1002132:	4152      	adcs	r2, r2
 1002134:	d2cd      	bcs.n	10020d2 <__udivsi3+0x3a>
 1002136:	09c3      	lsrs	r3, r0, #7
 1002138:	428b      	cmp	r3, r1
 100213a:	d301      	bcc.n	1002140 <__udivsi3+0xa8>
 100213c:	01cb      	lsls	r3, r1, #7
 100213e:	1ac0      	subs	r0, r0, r3
 1002140:	4152      	adcs	r2, r2
 1002142:	0983      	lsrs	r3, r0, #6
 1002144:	428b      	cmp	r3, r1
 1002146:	d301      	bcc.n	100214c <__udivsi3+0xb4>
 1002148:	018b      	lsls	r3, r1, #6
 100214a:	1ac0      	subs	r0, r0, r3
 100214c:	4152      	adcs	r2, r2
 100214e:	0943      	lsrs	r3, r0, #5
 1002150:	428b      	cmp	r3, r1
 1002152:	d301      	bcc.n	1002158 <__udivsi3+0xc0>
 1002154:	014b      	lsls	r3, r1, #5
 1002156:	1ac0      	subs	r0, r0, r3
 1002158:	4152      	adcs	r2, r2
 100215a:	0903      	lsrs	r3, r0, #4
 100215c:	428b      	cmp	r3, r1
 100215e:	d301      	bcc.n	1002164 <__udivsi3+0xcc>
 1002160:	010b      	lsls	r3, r1, #4
 1002162:	1ac0      	subs	r0, r0, r3
 1002164:	4152      	adcs	r2, r2
 1002166:	08c3      	lsrs	r3, r0, #3
 1002168:	428b      	cmp	r3, r1
 100216a:	d301      	bcc.n	1002170 <__udivsi3+0xd8>
 100216c:	00cb      	lsls	r3, r1, #3
 100216e:	1ac0      	subs	r0, r0, r3
 1002170:	4152      	adcs	r2, r2
 1002172:	0883      	lsrs	r3, r0, #2
 1002174:	428b      	cmp	r3, r1
 1002176:	d301      	bcc.n	100217c <__udivsi3+0xe4>
 1002178:	008b      	lsls	r3, r1, #2
 100217a:	1ac0      	subs	r0, r0, r3
 100217c:	4152      	adcs	r2, r2
 100217e:	0843      	lsrs	r3, r0, #1
 1002180:	428b      	cmp	r3, r1
 1002182:	d301      	bcc.n	1002188 <__udivsi3+0xf0>
 1002184:	004b      	lsls	r3, r1, #1
 1002186:	1ac0      	subs	r0, r0, r3
 1002188:	4152      	adcs	r2, r2
 100218a:	1a41      	subs	r1, r0, r1
 100218c:	d200      	bcs.n	1002190 <__udivsi3+0xf8>
 100218e:	4601      	mov	r1, r0
 1002190:	4152      	adcs	r2, r2
 1002192:	4610      	mov	r0, r2
 1002194:	4770      	bx	lr
 1002196:	e7ff      	b.n	1002198 <__udivsi3+0x100>
 1002198:	b501      	push	{r0, lr}
 100219a:	2000      	movs	r0, #0
 100219c:	f000 f8f0 	bl	1002380 <__aeabi_idiv0>
 10021a0:	bd02      	pop	{r1, pc}
 10021a2:	46c0      	nop			; (mov r8, r8)

010021a4 <__aeabi_uidivmod>:
 10021a4:	2900      	cmp	r1, #0
 10021a6:	d0f7      	beq.n	1002198 <__udivsi3+0x100>
 10021a8:	e776      	b.n	1002098 <__udivsi3>
 10021aa:	4770      	bx	lr

010021ac <__divsi3>:
 10021ac:	4603      	mov	r3, r0
 10021ae:	430b      	orrs	r3, r1
 10021b0:	d47f      	bmi.n	10022b2 <__divsi3+0x106>
 10021b2:	2200      	movs	r2, #0
 10021b4:	0843      	lsrs	r3, r0, #1
 10021b6:	428b      	cmp	r3, r1
 10021b8:	d374      	bcc.n	10022a4 <__divsi3+0xf8>
 10021ba:	0903      	lsrs	r3, r0, #4
 10021bc:	428b      	cmp	r3, r1
 10021be:	d35f      	bcc.n	1002280 <__divsi3+0xd4>
 10021c0:	0a03      	lsrs	r3, r0, #8
 10021c2:	428b      	cmp	r3, r1
 10021c4:	d344      	bcc.n	1002250 <__divsi3+0xa4>
 10021c6:	0b03      	lsrs	r3, r0, #12
 10021c8:	428b      	cmp	r3, r1
 10021ca:	d328      	bcc.n	100221e <__divsi3+0x72>
 10021cc:	0c03      	lsrs	r3, r0, #16
 10021ce:	428b      	cmp	r3, r1
 10021d0:	d30d      	bcc.n	10021ee <__divsi3+0x42>
 10021d2:	22ff      	movs	r2, #255	; 0xff
 10021d4:	0209      	lsls	r1, r1, #8
 10021d6:	ba12      	rev	r2, r2
 10021d8:	0c03      	lsrs	r3, r0, #16
 10021da:	428b      	cmp	r3, r1
 10021dc:	d302      	bcc.n	10021e4 <__divsi3+0x38>
 10021de:	1212      	asrs	r2, r2, #8
 10021e0:	0209      	lsls	r1, r1, #8
 10021e2:	d065      	beq.n	10022b0 <__divsi3+0x104>
 10021e4:	0b03      	lsrs	r3, r0, #12
 10021e6:	428b      	cmp	r3, r1
 10021e8:	d319      	bcc.n	100221e <__divsi3+0x72>
 10021ea:	e000      	b.n	10021ee <__divsi3+0x42>
 10021ec:	0a09      	lsrs	r1, r1, #8
 10021ee:	0bc3      	lsrs	r3, r0, #15
 10021f0:	428b      	cmp	r3, r1
 10021f2:	d301      	bcc.n	10021f8 <__divsi3+0x4c>
 10021f4:	03cb      	lsls	r3, r1, #15
 10021f6:	1ac0      	subs	r0, r0, r3
 10021f8:	4152      	adcs	r2, r2
 10021fa:	0b83      	lsrs	r3, r0, #14
 10021fc:	428b      	cmp	r3, r1
 10021fe:	d301      	bcc.n	1002204 <__divsi3+0x58>
 1002200:	038b      	lsls	r3, r1, #14
 1002202:	1ac0      	subs	r0, r0, r3
 1002204:	4152      	adcs	r2, r2
 1002206:	0b43      	lsrs	r3, r0, #13
 1002208:	428b      	cmp	r3, r1
 100220a:	d301      	bcc.n	1002210 <__divsi3+0x64>
 100220c:	034b      	lsls	r3, r1, #13
 100220e:	1ac0      	subs	r0, r0, r3
 1002210:	4152      	adcs	r2, r2
 1002212:	0b03      	lsrs	r3, r0, #12
 1002214:	428b      	cmp	r3, r1
 1002216:	d301      	bcc.n	100221c <__divsi3+0x70>
 1002218:	030b      	lsls	r3, r1, #12
 100221a:	1ac0      	subs	r0, r0, r3
 100221c:	4152      	adcs	r2, r2
 100221e:	0ac3      	lsrs	r3, r0, #11
 1002220:	428b      	cmp	r3, r1
 1002222:	d301      	bcc.n	1002228 <__divsi3+0x7c>
 1002224:	02cb      	lsls	r3, r1, #11
 1002226:	1ac0      	subs	r0, r0, r3
 1002228:	4152      	adcs	r2, r2
 100222a:	0a83      	lsrs	r3, r0, #10
 100222c:	428b      	cmp	r3, r1
 100222e:	d301      	bcc.n	1002234 <__divsi3+0x88>
 1002230:	028b      	lsls	r3, r1, #10
 1002232:	1ac0      	subs	r0, r0, r3
 1002234:	4152      	adcs	r2, r2
 1002236:	0a43      	lsrs	r3, r0, #9
 1002238:	428b      	cmp	r3, r1
 100223a:	d301      	bcc.n	1002240 <__divsi3+0x94>
 100223c:	024b      	lsls	r3, r1, #9
 100223e:	1ac0      	subs	r0, r0, r3
 1002240:	4152      	adcs	r2, r2
 1002242:	0a03      	lsrs	r3, r0, #8
 1002244:	428b      	cmp	r3, r1
 1002246:	d301      	bcc.n	100224c <__divsi3+0xa0>
 1002248:	020b      	lsls	r3, r1, #8
 100224a:	1ac0      	subs	r0, r0, r3
 100224c:	4152      	adcs	r2, r2
 100224e:	d2cd      	bcs.n	10021ec <__divsi3+0x40>
 1002250:	09c3      	lsrs	r3, r0, #7
 1002252:	428b      	cmp	r3, r1
 1002254:	d301      	bcc.n	100225a <__divsi3+0xae>
 1002256:	01cb      	lsls	r3, r1, #7
 1002258:	1ac0      	subs	r0, r0, r3
 100225a:	4152      	adcs	r2, r2
 100225c:	0983      	lsrs	r3, r0, #6
 100225e:	428b      	cmp	r3, r1
 1002260:	d301      	bcc.n	1002266 <__divsi3+0xba>
 1002262:	018b      	lsls	r3, r1, #6
 1002264:	1ac0      	subs	r0, r0, r3
 1002266:	4152      	adcs	r2, r2
 1002268:	0943      	lsrs	r3, r0, #5
 100226a:	428b      	cmp	r3, r1
 100226c:	d301      	bcc.n	1002272 <__divsi3+0xc6>
 100226e:	014b      	lsls	r3, r1, #5
 1002270:	1ac0      	subs	r0, r0, r3
 1002272:	4152      	adcs	r2, r2
 1002274:	0903      	lsrs	r3, r0, #4
 1002276:	428b      	cmp	r3, r1
 1002278:	d301      	bcc.n	100227e <__divsi3+0xd2>
 100227a:	010b      	lsls	r3, r1, #4
 100227c:	1ac0      	subs	r0, r0, r3
 100227e:	4152      	adcs	r2, r2
 1002280:	08c3      	lsrs	r3, r0, #3
 1002282:	428b      	cmp	r3, r1
 1002284:	d301      	bcc.n	100228a <__divsi3+0xde>
 1002286:	00cb      	lsls	r3, r1, #3
 1002288:	1ac0      	subs	r0, r0, r3
 100228a:	4152      	adcs	r2, r2
 100228c:	0883      	lsrs	r3, r0, #2
 100228e:	428b      	cmp	r3, r1
 1002290:	d301      	bcc.n	1002296 <__divsi3+0xea>
 1002292:	008b      	lsls	r3, r1, #2
 1002294:	1ac0      	subs	r0, r0, r3
 1002296:	4152      	adcs	r2, r2
 1002298:	0843      	lsrs	r3, r0, #1
 100229a:	428b      	cmp	r3, r1
 100229c:	d301      	bcc.n	10022a2 <__divsi3+0xf6>
 100229e:	004b      	lsls	r3, r1, #1
 10022a0:	1ac0      	subs	r0, r0, r3
 10022a2:	4152      	adcs	r2, r2
 10022a4:	1a41      	subs	r1, r0, r1
 10022a6:	d200      	bcs.n	10022aa <__divsi3+0xfe>
 10022a8:	4601      	mov	r1, r0
 10022aa:	4152      	adcs	r2, r2
 10022ac:	4610      	mov	r0, r2
 10022ae:	4770      	bx	lr
 10022b0:	e05d      	b.n	100236e <__divsi3+0x1c2>
 10022b2:	0fca      	lsrs	r2, r1, #31
 10022b4:	d000      	beq.n	10022b8 <__divsi3+0x10c>
 10022b6:	4249      	negs	r1, r1
 10022b8:	1003      	asrs	r3, r0, #32
 10022ba:	d300      	bcc.n	10022be <__divsi3+0x112>
 10022bc:	4240      	negs	r0, r0
 10022be:	4053      	eors	r3, r2
 10022c0:	2200      	movs	r2, #0
 10022c2:	469c      	mov	ip, r3
 10022c4:	0903      	lsrs	r3, r0, #4
 10022c6:	428b      	cmp	r3, r1
 10022c8:	d32d      	bcc.n	1002326 <__divsi3+0x17a>
 10022ca:	0a03      	lsrs	r3, r0, #8
 10022cc:	428b      	cmp	r3, r1
 10022ce:	d312      	bcc.n	10022f6 <__divsi3+0x14a>
 10022d0:	22fc      	movs	r2, #252	; 0xfc
 10022d2:	0189      	lsls	r1, r1, #6
 10022d4:	ba12      	rev	r2, r2
 10022d6:	0a03      	lsrs	r3, r0, #8
 10022d8:	428b      	cmp	r3, r1
 10022da:	d30c      	bcc.n	10022f6 <__divsi3+0x14a>
 10022dc:	0189      	lsls	r1, r1, #6
 10022de:	1192      	asrs	r2, r2, #6
 10022e0:	428b      	cmp	r3, r1
 10022e2:	d308      	bcc.n	10022f6 <__divsi3+0x14a>
 10022e4:	0189      	lsls	r1, r1, #6
 10022e6:	1192      	asrs	r2, r2, #6
 10022e8:	428b      	cmp	r3, r1
 10022ea:	d304      	bcc.n	10022f6 <__divsi3+0x14a>
 10022ec:	0189      	lsls	r1, r1, #6
 10022ee:	d03a      	beq.n	1002366 <__divsi3+0x1ba>
 10022f0:	1192      	asrs	r2, r2, #6
 10022f2:	e000      	b.n	10022f6 <__divsi3+0x14a>
 10022f4:	0989      	lsrs	r1, r1, #6
 10022f6:	09c3      	lsrs	r3, r0, #7
 10022f8:	428b      	cmp	r3, r1
 10022fa:	d301      	bcc.n	1002300 <__divsi3+0x154>
 10022fc:	01cb      	lsls	r3, r1, #7
 10022fe:	1ac0      	subs	r0, r0, r3
 1002300:	4152      	adcs	r2, r2
 1002302:	0983      	lsrs	r3, r0, #6
 1002304:	428b      	cmp	r3, r1
 1002306:	d301      	bcc.n	100230c <__divsi3+0x160>
 1002308:	018b      	lsls	r3, r1, #6
 100230a:	1ac0      	subs	r0, r0, r3
 100230c:	4152      	adcs	r2, r2
 100230e:	0943      	lsrs	r3, r0, #5
 1002310:	428b      	cmp	r3, r1
 1002312:	d301      	bcc.n	1002318 <__divsi3+0x16c>
 1002314:	014b      	lsls	r3, r1, #5
 1002316:	1ac0      	subs	r0, r0, r3
 1002318:	4152      	adcs	r2, r2
 100231a:	0903      	lsrs	r3, r0, #4
 100231c:	428b      	cmp	r3, r1
 100231e:	d301      	bcc.n	1002324 <__divsi3+0x178>
 1002320:	010b      	lsls	r3, r1, #4
 1002322:	1ac0      	subs	r0, r0, r3
 1002324:	4152      	adcs	r2, r2
 1002326:	08c3      	lsrs	r3, r0, #3
 1002328:	428b      	cmp	r3, r1
 100232a:	d301      	bcc.n	1002330 <__divsi3+0x184>
 100232c:	00cb      	lsls	r3, r1, #3
 100232e:	1ac0      	subs	r0, r0, r3
 1002330:	4152      	adcs	r2, r2
 1002332:	0883      	lsrs	r3, r0, #2
 1002334:	428b      	cmp	r3, r1
 1002336:	d301      	bcc.n	100233c <__divsi3+0x190>
 1002338:	008b      	lsls	r3, r1, #2
 100233a:	1ac0      	subs	r0, r0, r3
 100233c:	4152      	adcs	r2, r2
 100233e:	d2d9      	bcs.n	10022f4 <__divsi3+0x148>
 1002340:	0843      	lsrs	r3, r0, #1
 1002342:	428b      	cmp	r3, r1
 1002344:	d301      	bcc.n	100234a <__divsi3+0x19e>
 1002346:	004b      	lsls	r3, r1, #1
 1002348:	1ac0      	subs	r0, r0, r3
 100234a:	4152      	adcs	r2, r2
 100234c:	1a41      	subs	r1, r0, r1
 100234e:	d200      	bcs.n	1002352 <__divsi3+0x1a6>
 1002350:	4601      	mov	r1, r0
 1002352:	4663      	mov	r3, ip
 1002354:	4152      	adcs	r2, r2
 1002356:	105b      	asrs	r3, r3, #1
 1002358:	4610      	mov	r0, r2
 100235a:	d301      	bcc.n	1002360 <__divsi3+0x1b4>
 100235c:	4240      	negs	r0, r0
 100235e:	2b00      	cmp	r3, #0
 1002360:	d500      	bpl.n	1002364 <__divsi3+0x1b8>
 1002362:	4249      	negs	r1, r1
 1002364:	4770      	bx	lr
 1002366:	4663      	mov	r3, ip
 1002368:	105b      	asrs	r3, r3, #1
 100236a:	d300      	bcc.n	100236e <__divsi3+0x1c2>
 100236c:	4240      	negs	r0, r0
 100236e:	b501      	push	{r0, lr}
 1002370:	2000      	movs	r0, #0
 1002372:	f000 f805 	bl	1002380 <__aeabi_idiv0>
 1002376:	bd02      	pop	{r1, pc}

01002378 <__aeabi_idivmod>:
 1002378:	2900      	cmp	r1, #0
 100237a:	d0f8      	beq.n	100236e <__divsi3+0x1c2>
 100237c:	e716      	b.n	10021ac <__divsi3>
 100237e:	4770      	bx	lr

01002380 <__aeabi_idiv0>:
 1002380:	4770      	bx	lr
 1002382:	46c0      	nop			; (mov r8, r8)
 1002384:	33323130 	.word	0x33323130
 1002388:	37363534 	.word	0x37363534
 100238c:	62613938 	.word	0x62613938
 1002390:	66656463 	.word	0x66656463
 1002394:	32313000 	.word	0x32313000
 1002398:	36353433 	.word	0x36353433
 100239c:	41393837 	.word	0x41393837
 10023a0:	45444342 	.word	0x45444342
 10023a4:	52450046 	.word	0x52450046
 10023a8:	00524f52 	.word	0x00524f52
 10023ac:	25200a0d 	.word	0x25200a0d
 10023b0:	0d003a73 	.word	0x0d003a73
 10023b4:	3830250a 	.word	0x3830250a
 10023b8:	25003a78 	.word	0x25003a78
 10023bc:	20783230 	.word	0x20783230
 10023c0:	00000000 	.word	0x00000000

010023c4 <g_pcHex1>:
 10023c4:	01002384                                .#..

010023c8 <g_pcHex2>:
 10023c8:	01002395 2e2f2e2e 2e2e2f2e 2f2e2e2f     .#..../../../../
 10023d8:	4c2f2e2e 61726269 72656972 6b64732f     ../Librarier/sdk
 10023e8:	5f63792f 6f697067                        /yc_gpio.c.

010023f3 <__FUNCTION__.5786>:
 10023f3:	4f495047 6e6f435f 00676966              GPIO_Config.

010023ff <__FUNCTION__.5795>:
 10023ff:	4f495047 696e495f                        GPIO_Init.

01002409 <__FUNCTION__.5824>:
 1002409:	4f495047 6c75505f 4370556c               GPIO_PullUpCmd.

01002418 <__FUNCTION__.5832>:
 1002418:	4f495047 6165525f 706e4964 61447475     GPIO_ReadInputDa
 1002428:	                                         ta.

0100242b <__FUNCTION__.5837>:
 100242b:	4f495047 6165525f 706e4964 61447475     GPIO_ReadInputDa
 100243b:	69426174                                 taBit.

01002441 <__FUNCTION__.5841>:
 1002441:	4f495047 6165525f 74754f64 44747570     GPIO_ReadOutputD
 1002451:	00617461                                ata.

01002455 <__FUNCTION__.5846>:
 1002455:	4f495047 6165525f 74754f64 44747570     GPIO_ReadOutputD
 1002465:	42617461                                 ataBit.

0100246c <__FUNCTION__.5851>:
 100246c:	4f495047 7365525f 69427465               GPIO_ResetBits.

0100247b <__FUNCTION__.5861>:
 100247b:	4f495047 7465535f 73746942               GPIO_SetBits.

01002488 <__FUNCTION__.5873>:
 1002488:	4f495047 6972575f                        GPIO_Write.

01002493 <__FUNCTION__.5883>:
 1002493:	4f495047 6972575f 69426574 2e2e0074     GPIO_WriteBit...
 10024a3:	2f2e2e2f 2e2f2e2e 2e2e2f2e 62694c2f     /../../../../Lib
 10024b3:	69726172 732f7265 792f6b64 61755f63     rarier/sdk/yc_ua
 10024c3:	632e7472                                 rt.c.

010024c8 <__FUNCTION__.5473>:
 10024c8:	54524155 7475415f 6f6c466f 72744377     UART_AutoFlowCtr
 10024d8:	646d436c                                 lCmd.

010024dd <__FUNCTION__.5487>:
 10024dd:	54524155 4965445f 0074696e              UART_DeInit.

010024e9 <__FUNCTION__.5496>:
 10024e9:	54524155 414d445f 646e6553 00667542     UART_DMASendBuf.

010024f9 <__FUNCTION__.5510>:
 10024f9:	54524155 696e495f                        UART_Init.

01002503 <__FUNCTION__.5514>:
 1002503:	54524155 5273495f 46494658 6c75464f     UART_IsRXFIFOFul
 1002513:	                                         l.

01002515 <__FUNCTION__.5518>:
 1002515:	54524155 5273495f 46494658 746f4e4f     UART_IsRXFIFONot
 1002525:	74706d45                                 Empty.

0100252b <__FUNCTION__.5522>:
 100252b:	54524155 5573495f 42545241 00797375     UART_IsUARTBusy.

0100253b <__FUNCTION__.5528>:
 100253b:	54524155 4354495f 69666e6f               UART_ITConfig.

01002549 <__FUNCTION__.5535>:
 1002549:	54524155 6365525f 65766965 61746144     UART_ReceiveData
	...

0100255a <__FUNCTION__.5544>:
 100255a:	54524155 6365525f 66754276               UART_RecvBuf.

01002567 <__FUNCTION__.5553>:
 1002567:	54524155 6e65535f 66754264               UART_SendBuf.

01002574 <__FUNCTION__.5579>:
 1002574:	54524155 7465535f 54497852 006d754e     UART_SetRxITNum.

01002584 <__FUNCTION__.5586>:
 1002584:	54524155 6365525f 65766965 61746144     UART_ReceiveData
 1002594:	006e654c 2e2f2e2e 2e2e2f2e 2f2e2e2f     Len.../../../../
 10025a4:	4c2f2e2e 61726269 72656972 6b64732f     ../Librarier/sdk
 10025b4:	5f63792f 63737973 2e6c7274               /yc_sysctrl.c.

010025c2 <__FUNCTION__.5488>:
 10025c2:	43535953 5f4c5254 50424841 70697265     SYSCTRL_AHBPerip
 10025d2:	6f6c4368 6d436b63                        hClockCmd.

010025dc <__FUNCTION__.5492>:
 10025dc:	43535953 5f4c5254 65746e45 656c5372     SYSCTRL_EnterSle
 10025ec:	                                         ep.

010025ef <__FUNCTION__.5500>:
 10025ef:	43535953 5f4c5254 4b4c4348 666e6f43     SYSCTRL_HCLKConf
 10025ff:	2e006769 2e2e2f2e 2f2e2e2f 2e2f2e2e     ig.../../../../.
 100260f:	694c2f2e 72617262 2f726569 2f6b6473     ./Librarier/sdk/
 100261f:	745f6379 72656d69                        yc_timer.c.

0100262a <__FUNCTION__.5642>:
 100262a:	5f4d4954 74696e49                        TIM_Init.

01002633 <__FUNCTION__.5649>:
 1002633:	5f4d4954 00646d43                       TIM_Cmd.

0100263b <__FUNCTION__.5654>:
 100263b:	5f4d4954 65646f4d 666e6f43               TIM_ModeConfig.

0100264a <__FUNCTION__.5659>:
 100264a:	5f4d4954 50746553 6f697265               TIM_SetPeriod.

01002658 <__FUNCTION__.5663>:
 1002658:	5f4d4954 494d5750 0074696e              TIM_PWMInit.

01002664 <__FUNCTION__.5669>:
 1002664:	5f4d4954 50746553 65504d57 646f6972     TIM_SetPWMPeriod
	...

01002675 <__FUNCTION__.5676>:
 1002675:	5f4d4954 444d5750 65666669 746e6572     TIM_PWMDifferent
 1002685:	006c6169                                 ial....

0100268c <devicedesc>:
 100268c:	01100112 40000000 57200483 02010200     .......@.. W....
 100269c:	                                         ..

0100269e <confdesc>:
 100269e:	00200209 c0000101 00040932 01070200     .. .....2.......
 10026ae:	05070402 00400201 81050700 02004003     ......@......@..

010026be <string0>:
 10026be:	04090304                                 .....

010026c3 <string1>:
 10026c3:	48434959                                 YICHIP.

010026ca <string2>:
 10026ca:	31334359 50203132 746e6972 64207265     YC3121 Printer d
 10026da:	006f6d65                                emo.

010026de <string3>:
 10026de:	30303030 30303030 34303030               000000000004..

010026ec <string>:
 10026ec:	010026be 010026c3 010026ca 010026de     .&...&...&...&..

010026fc <id>:
 10026fc:	72700a00 65746e69                        ..printer;.

01002707 <strlength>:
 1002707:	0d140705 76636572 206e656c 6425203d     ....recvlen = %d
 1002717:	63657220 746f7476 656c6c61 203d206e      recvtotallen = 
 1002727:	0a0d6425 73616300 31272065 0a212027     %d...case '1' !.
 1002737:	6962000a 75625f67 72656666 7661685f     ..big_buffer_hav
 1002747:	70735f65 20656361 20273127 000a0a21     e_space '1' !...
 1002757:	5f676962 66667562 685f7265 5f657661     big_buffer_have_
 1002767:	63617073 30272065 0a212027 6f74000a     space '0' !...to
 1002777:	6c6c6174 3d206e65 20642520 736b6863     tallen = %d chks
 1002787:	3d206d75 20642520 74000a0a 6c61746f     um = %d ...total
 1002797:	656c7874 203d206e 74206425 6c61746f     txlen = %d total
 10027a7:	656c7874 68635f6e 6d75736b 25203d20     txlen_chksum = %
 10027b7:	0a0a2064 52415500 58542054 6e655320     d ...UART TX Sen
 10027c7:	74614464 65442061 21206f6d 55000a0a     dData Demo !...U
 10027d7:	5f545241 646e6553 61746144               ART_SendData:.

010027e5 <bt_code>:
 10027e5:	55aa0200 42c0037a 43c01980 43c01b00     ...Uz..B...C...C
 10027f5:	44c01f80 44c01d00 45c02880 02c02d00     ...D...D.(.E.-..
 1002805:	03c00d00 40200800 3624af57 4020a5d8     ...... @W.$6.. @
 1002815:	4020b500 20203649 8009a658 28781800     .. @I6  X.....x(
 1002825:	60db007c ef1f6406 f11f007e e6e7007e     |..`.d..~...~...
 1002835:	23200500 36784946 e26f00fc e01f1700     .. #FIx6..o.....
 1002845:	40200084 2020b900 40209758 2020b100     .. @..  X. @..  
 1002855:	4020f648 2020b300 40201649 2020b700     H. @..  I. @..  
 1002865:	42602249 20201700 4020bb00 20dabb00     I"`B..  .. @... 
 1002875:	40206089 20daa700 40201000 20daa700     .` @... .. @... 
 1002885:	20200000 4260d600 40201700 0058b900     ..  ..`B.. @..X.
 1002895:	40208403 20208e4a 89703649 8070ff07     .. @J.  I6p...p.
 10028a5:	00200542 e26fe803 7a24ef4f 4f700000     B. ...o.O.$z..pO
 10028b5:	897001ef 8970c24e 4020c04e 81c0ca00     ..p.N.p.N. @....
 10028c5:	00204300 40203075 81c0ca00 00204300     .C .u0 @.....C .
 10028d5:	20da1027 40da5689 4020f000 20dad100     '.. .V.@.. @... 
 10028e5:	40205589 20daa700 40200000 6020d600     .U @... .. @.. `
 10028f5:	20200000 40204300 20204600 4020f548     ..  .C @.F  H. @
 1002905:	40206e00 20797700 4678002a 2e7800fc     .n @.wy *.xF..x.
 1002915:	307800fc 5078007c 311900fc ec1f007e     ..x0|.xP...1~...
 1002925:	f11f00fe 000800fe 24782886 e26f00fc     .........(x$..o.
 1002935:	0008ae43 e2ef0886 e11f0600 00083f72     C...........r?..
 1002945:	22200886 e2ef5b80 00080600 00c20886     .. ".[..........
 1002955:	24785800 0008007c 44781886 d337007c     .Xx$|.....xD|.7.
 1002965:	00200082 60206400 3b780000 8970007c     .. ..d `..x;|.p.
 1002975:	60200714 5b780000 8970007c 60200314     .. `..x[|.p... `
 1002985:	71580000 ed1f4176 e11f007e 009829fe     ..XqvA..~....)..
 1002995:	55580012 e6675555 60206304 44780000     ..XUUUg..c `..xD
 10029a5:	437800fc e66f00fc 00986304 e26f001e     ..xC..o..c....o.
 10029b5:	ed1f1600 20790084 43180104 6020001c     ......y ...C.. `
 10029c5:	40200000 20207c00 40203049 40207c00     .. @.|  I0 @.| @
 10029d5:	20201c49 40202149 e26f1549 e31f1600     I.  I! @I.o.....
 10029e5:	60200084 40200000 40207900 56786e00     .. `.. @.y @.nxV
 10029f5:	267800fc 4e7800fc 307800fc 507800fc     ..x&..xN..x0..xP
 1002a05:	6219007c c1370036 2c240084 421bf548     |..b6.7...$,H..B
 1002a15:	20dd0004 221ce001 24780050 800900fc     ... ..."P.x$....
 1002a25:	89190800 e267007e 8009d502 89190800     ....~.g.........
 1002a35:	e2e7007e e11f0500 22203f72 80099a80     ~.......r? "....
 1002a45:	89190800 e2e7007e 00c20500 80099600     ....~...........
 1002a55:	28781800 60db007c ef1f6406 f11f007e     ..x(|..`.d..~...
 1002a65:	e6e7007e 40200500 2320ba49 3678f548     ~..... @I. #H.x6
 1002a75:	e26f00fc e01f1700 402002a2 20208049     ..o....... @I.  
 1002a85:	00581549 f0670000 20df960a 40da0800     I.X...g.... ...@
 1002a95:	4020960a e2e7cd00 401a1200 201a01a4     .. @.......@... 
 1002aa5:	00c201a2 6020ab00 40da0000 2020fe00     ...... `...@..  
 1002ab5:	40dad200 2020fd00 40dad200 2020fc00     ...@..  ...@..  
 1002ac5:	40dad200 2020fb00 4218d200 20200024     ...@..  ...B$.  
 1002ad5:	4118d200 202080a4 e267d200 89704b89     ...A..  ..g..Kp.
 1002ae5:	8970c54e e26fc44e 00c49189 20200080     N.p.N.o.......  
 1002af5:	e26fc000 00c39189 e26fc300 89709089     ..o.......o...p.
 1002b05:	8970c64e 0020c44e 6020e803 00580000     N.p.N. ... `..X.
 1002b15:	40200200 2020bd00 4020c300 0058d600     .. @..  .. @..X.
 1002b25:	40200600 2020bd00 4020c300 0058d600     .. @..  .. @..X.
 1002b35:	40200500 421abd00 2020007e 0058bd00     .. @...B~.  ..X.
 1002b45:	40200b00 2c1abd00 402000fe 0058bd00     .. @...,.. @..X.
 1002b55:	40200300 211abd00 2020ff7e c93fbd00     .. @...!~.  ..?.
 1002b65:	000155aa aa0a4092 54000155 55aa4046     .U...@..U..TF@.U
 1002b75:	42060001 0855aa13 ff409800 9bf88fff     ...B..U...@.....
 1002b85:	aa83599d 14000355 054a0742 000455aa     .Y..U...B.J..U..
 1002b95:	7f00453d 55aa0700 462d0003 aa040003     =E.....U..-F....
 1002ba5:	2c000155 55aa0146 46570006 30303004     U..,F..U..WF.000
 1002bb5:	55aa3030 4ff00010 1fff1c00 1c001c00     00.U...O........
 1002bc5:	4fe04c00 4c004c00 000255aa 01004668     .L.O.L.L.U..hF..
 1002bd5:	000155aa aa03466c 6f000155 55aa0746     .U..lF..U..oF..U
 1002be5:	40aa0003 aa040424 79000155 55aa0046     ...@$...U..yF..U
 1002bf5:	40910001 0355aa00 00415400 55aa0801     ...@..U..TA....U
 1002c05:	41740001 0155aa02 03409300 000155aa     ..tA..U...@..U..
 1002c15:	aa28466d a0000655 2a2aa740 aa3a1031     mF(.U...@.**1.:.
 1002c25:	e7000c55 69590b44 70696863 32313320     U...D.Yichip 312
 1002c35:	0355aa31 2041e400 55aa0100 41e80001     1.U...A ...U...A
 1002c45:	0155aa00 01449000 000155aa aa07445f     ..U...D..U.._D..
 1002c55:	98000155 55aa0144 46750004 002f0009     U...D..U..uF../.
 1002c65:	000155aa aa014340 54000255 aa00f044     .U..@C..U..TD...
 1002c75:	6e000155 55aa0546 44720006 33002221     U..nF..U..rD!".3
 1002c85:	55aa3a02 43810010 6369590f 20706968     .:.U...C.Yichip 
 1002c95:	31323133 756f4d20 000455aa 02034341     3121 Mou.U..AC..
 1002ca5:	55aa0e01 43610013 5909110e 69686369     ...U..aC...Yichi
 1002cb5:	30312070 20733132 aa756f4d 25000755     p 1021s Mou.U..%
 1002cc5:	00030244 03021005 000855aa 00084468     D........U..hD..
 1002cd5:	00000010 55aa012c 44780001 0155aab5     ....,..U..xD..U.
 1002ce5:	17447a00 000255aa 003144cc 000155aa     .zD..U...D1..U..
 1002cf5:	aa0140d1 49000c55 00030545 01010012     .@..U..IE.......
 1002d05:	03110100 0155aa00 00455f00 000255aa     ......U.._E..U..
 1002d15:	46834547 00b855aa 12034683 00000100     GE.F.U...F......
 1002d25:	00010001 52003601 0a000009 01000100     .....6.R........
 1002d35:	35010009 00121903 35040009 1906350d     ...5.......5.5..
 1002d45:	00090001 19033501 00090100 35083509     .....5.......5.5
 1002d55:	00121906 09000109 01090002 01020903     ................
 1002d65:	09ac0509 02090202 03020939 09440609     ........9.....D.
 1002d75:	01280402 09050209 11030200 01030001     ..(.............
 1002d85:	00010000 46003603 0a000009 03000100     .....6.F........
 1002d95:	35010009 01111903 0a020009 00000000     ...5............
 1002da5:	35040009 1903350c 05350001 08030019     ...5.5....5.....
 1002db5:	06000901 65090935 6a00096e 09000109     ....5..en..j....
 1002dc5:	0a250001 20505053 76616c73 00000065     ..%.SPP slave...
 1002dd5:	55aa0001 448e0002 55aa47af 47af008a     ...U...D.G.U...G
 1002de5:	00020001 18000228 03020002 030a0128     ....(.......(...
 1002df5:	2a000200 74734113 20454c20 73756f4d     ...*.Ast LE Mous
 1002e05:	20202065 20202020 00020004 e4551028     e       ....(.U.
 1002e15:	9fafd205 4ae58fa9 5343fe7d 00054953     .......J}.CSSI..
 1002e25:	01280302 02000610 00140587 00000000     ..(.............
	...
 1002e41:	07000000 29020200 08000002 28030200     .......).......(
 1002e51:	00090e01 14059802 00000000 00000000     ................
	...
 1002e6d:	55aa0000 40100002 55aa07e0 40200001     ...U...@...U.. @
 1002e7d:	0455aa50 0a417900 aa32b20b 57000255     P.U..yA...2.U..W
 1002e8d:	aa0b8b41 a1000855 00000000 00000000     A...U...........
 1002e9d:	0255aa00 0240bd00 0855aa24 2440ad00     ..U...@.$.U...@$
 1002ead:	24008000 aa008000 bb000255 aa002040     ...$....U...@ ..
 1002ebd:	b7000455 00002040 0455aa20 8040bf00     U...@ .. .U...@.
 1002ecd:	aa100004 e2000555 050e0844 55aa0004     ....U...D......U
 1002edd:	42020002 55aa1f30 42100001 0155aa20     ...B0..U...B .U.
 1002eed:	0141e000 000155aa aaff41e2 c3000255     ..A..U...A..U...
 1002efd:	9741e240                                 @.A..
